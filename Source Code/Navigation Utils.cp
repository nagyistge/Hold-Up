/***************************************************************************** * Copyright (c) 1999-2002, Pierre-Olivier Latour * http://www.pol-online.net * info@pol-online.net * * This program is free software; you can redistribute it and/or modify * it under the terms of the GNU General Public License as published by * the Free Software Foundation; either version 2 of the License, or * (at your option) any later version. *  * This program is distributed in the hope that it will be useful, * but WITHOUT ANY WARRANTY; without even the implied warranty of * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the * GNU General Public License for more details. * * You should have received a copy of the GNU General Public License * along with this program; if not, write to the Free Software * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111, USA. *****************************************************************************/#include	"Navigation Utils.h"//ROUTINES:#if !TARGET_API_MAC_CARBONinline void AEGetDescData(AEDesc* desc, void* ptr, long size){	BlockMove(*(desc->dataHandle), ptr, size);}#endifstatic pascal void NavEventProc(NavEventCallbackMessage callBackSelector, NavCBRecPtr callBackParms, NavCallBackUserData callBackUD){	switch(callBackSelector) {				case kNavCBEvent:		if((((NavigationParamsPtr) callBackUD)->eventCallback != NULL) && (((NavigationParamsPtr) callBackUD)->eventCallback != kFakeEventCallBack))		((NavigationParamsPtr) callBackUD)->eventCallback(callBackParms->eventData.eventDataParms.event, ((NavigationParamsPtr) callBackUD)->callbackRefcon);		break;				case kNavCBPopupMenuSelect:		((NavigationParamsPtr) callBackUD)->formatIndex = ((NavMenuItemSpec*) callBackParms->eventData.eventDataParms.param)->menuType;		break;			}}#if TARGET_API_MAC_CARBONstatic pascal void FakeEventProc(NavEventCallbackMessage callBackSelector, NavCBRecPtr callBackParms, NavCallBackUserData callBackUD){	;}#endifstatic pascal Boolean NavFilterProc(AEDesc* theItem, void* info, NavCallBackUserData callBackUD, NavFilterModes filterMode){	FSSpec					finalFSSpec;		NavFileOrFolderInfo*	objectInfo = (NavFileOrFolderInfo*) info;		//Make sure we have a FSSpec	if(theItem->descriptorType != typeFSS)	return true;		//Check for folder	if((objectInfo != NULL) && (objectInfo->isFolder))	return true;		//Check for file	AEGetDescData(theItem, &finalFSSpec, sizeof(FSSpec));	if(((NavigationParamsPtr) callBackUD)->filterCallback != NULL)	return ((NavigationParamsPtr) callBackUD)->filterCallback(&finalFSSpec, ((NavigationParamsPtr) callBackUD)->callbackRefcon);	else	return false;			return true;}static Handle NewOpenHandle(OSType applicationSignature, short numTypes, OSType typeList[]){	Handle hdl = NULL;		if(numTypes > 0) {		hdl = NewHandle(sizeof(NavTypeList) + numTypes * sizeof(OSType));		if (hdl != NULL) {			NavTypeListHandle open		= (NavTypeListHandle)hdl;						(*open)->componentSignature = applicationSignature;			(*open)->osTypeCount		= numTypes;			BlockMove(typeList, (*open)->osType, numTypes * sizeof(OSType));		}	}		return hdl;}OSErr NavigationGetFile(NavigationParamsPtr params, Str255 message){	NavReplyRecord		theReply;	NavDialogOptions	dialogOptions;	OSErr				theErr;	NavTypeListHandle	openList = NULL;	long				count = 0;	NavEventUPP			eventUPP = NULL;	NavObjectFilterUPP	filterUPP = NULL;		theErr = NavGetDefaultDialogOptions(&dialogOptions);	if(theErr)	return theErr;	dialogOptions.dialogOptionFlags &= ~kNavDontAddTranslateItems;	dialogOptions.dialogOptionFlags |= kNavNoTypePopup;	if(params->displayPreview)	dialogOptions.dialogOptionFlags |= kNavAllowPreviews;	else	dialogOptions.dialogOptionFlags &= ~kNavAllowPreviews;	//dialogOptions.preferenceKey = kSavePrefKey;	BlockMove(params->applicationName, dialogOptions.clientName, sizeof(Str63));		if(message != nil)	BlockMove(message, dialogOptions.message, sizeof(Str255));	else	dialogOptions.message[0] = 0;		if(params->eventCallback != NULL)	eventUPP = NewNavEventUPP(NavEventProc);		if(params->filterCallback != NULL)	filterUPP = NewNavObjectFilterUPP(NavFilterProc);		openList = (NavTypeListHandle) NewOpenHandle(params->applicationCreator, params->numTypes, params->typeList);	if(openList)	HLock((Handle) openList);		theErr = NavGetFile(NULL, &theReply, &dialogOptions, eventUPP, NULL, filterUPP, (NavTypeListHandle) openList, (NavCallBackUserData) params);	if((theErr == noErr) && theReply.validRecord) {		FSSpec	finalFSSpec;			AEDesc 	resultDesc;		FInfo	fileInfo;		resultDesc.dataHandle = 0L;		if((theErr = AEGetNthDesc(&theReply.selection, 1, typeFSS, NULL, &resultDesc)) == noErr) {			AEGetDescData(&resultDesc, &finalFSSpec, sizeof(FSSpec));						FSpGetFInfo(&finalFSSpec, &fileInfo);			params->outFileType = fileInfo.fdType;			BlockMove(&finalFSSpec, &params->outFile, sizeof(FSSpec));						AEDisposeDesc(&resultDesc);		}	}		NavDisposeReply(&theReply);	if(openList)	DisposeHandle((Handle) openList);	if(eventUPP)	DisposeNavEventUPP(eventUPP);	if(filterUPP)	DisposeNavObjectFilterUPP(filterUPP);		return theErr;}OSErr NavigationPutFile(NavigationParamsPtr params, Str255 message, Str255 defaultName){	OSErr				theErr;	NavReplyRecord		theReply;	NavDialogOptions	dialogOptions;	NavEventUPP			eventUPP = NULL;		theErr = NavGetDefaultDialogOptions(&dialogOptions);	if(theErr)	return theErr;	dialogOptions.dialogOptionFlags &= ~kNavDontAddTranslateItems;	dialogOptions.dialogOptionFlags |= kNavNoTypePopup;	//dialogOptions.preferenceKey = kSavePrefKey;	BlockMove(params->applicationName, dialogOptions.clientName, sizeof(Str63));	BlockMove(defaultName, dialogOptions.savedFileName, sizeof(Str255));		if(message != nil)	BlockMove(message, dialogOptions.message, sizeof(Str255));	else	dialogOptions.message[0] = 0;		if(params->eventCallback != NULL)	eventUPP = NewNavEventUPP(NavEventProc);		theErr = NavPutFile(NULL, &theReply, &dialogOptions, eventUPP, params->inFileType, params->applicationCreator, (NavCallBackUserData) params);	if((theErr == noErr) && theReply.validRecord) {		FSSpec	finalFSSpec;			AEDesc 	resultDesc;				resultDesc.dataHandle = 0L;		if((theErr = AEGetNthDesc(&theReply.selection, 1, typeFSS, NULL, &resultDesc)) == noErr) {			AEGetDescData(&resultDesc, &finalFSSpec, sizeof(FSSpec));			params->replacing = theReply.replacing;			BlockMove(&finalFSSpec, &params->outFile, sizeof(FSSpec));						AEDisposeDesc(&resultDesc);		}	}		NavDisposeReply(&theReply);		return theErr;}OSErr NavigationPutFileFormats(NavigationParamsPtr params, Str255 message, Str255 defaultName, short numFormats, Str255 formatNames[]){	OSErr						theErr;	NavReplyRecord				theReply;	NavDialogOptions			dialogOptions;	NavEventUPP					eventUPP = NULL;	NavMenuItemSpecArrayHandle	specHandle;	NavMenuItemSpecArrayPtr		specPtr;	long						i;		theErr = NavGetDefaultDialogOptions(&dialogOptions);	if(theErr)	return theErr;	//dialogOptions.preferenceKey = kSavePrefKey;	BlockMove(params->applicationName, dialogOptions.clientName, sizeof(Str63));	BlockMove(defaultName, dialogOptions.savedFileName, sizeof(Str255));		if(message != nil)	BlockMove(message, dialogOptions.message, sizeof(Str255));	else	dialogOptions.message[0] = 0;		if(params->eventCallback != NULL)	eventUPP = NewNavEventUPP(NavEventProc);		dialogOptions.dialogOptionFlags = kNavDontAddTranslateItems;	specHandle = (NavMenuItemSpecArrayHandle) NewHandleClear(numFormats * sizeof(NavMenuItemSpec));	if(specHandle == NULL)	return MemError();	specPtr = *specHandle;	for(i = 0; i < numFormats; ++i) {		specPtr[i].version = kNavMenuItemSpecVersion;		specPtr[i].menuCreator = kNavGenericSignature;		specPtr[i].menuType = i + 1;		BlockMove(formatNames[i], specPtr[i].menuItemName, sizeof(Str255));	}	dialogOptions.popupExtension = specHandle;		theErr = NavPutFile(NULL, &theReply, &dialogOptions, eventUPP, kNavGenericSignature, kNavGenericSignature, (NavCallBackUserData) params);	if((theErr == noErr) && theReply.validRecord) {		FSSpec	finalFSSpec;		AEDesc 	resultDesc;				resultDesc.dataHandle = 0L;		if((theErr = AEGetNthDesc(&theReply.selection, 1, typeFSS, NULL, &resultDesc)) == noErr) {			AEGetDescData(&resultDesc, &finalFSSpec, sizeof(FSSpec));			params->replacing = theReply.replacing;			BlockMove(&finalFSSpec, &params->outFile, sizeof(FSSpec));						AEDisposeDesc(&resultDesc);		}	}		NavDisposeReply(&theReply);	DisposeHandle((Handle) specHandle);		return theErr;}OSErr NavigationChooseFolder(FSSpec* folder, Str255 message){	OSErr				theErr;	NavReplyRecord		theReply;	NavDialogOptions	dialogOptions;		theErr = NavGetDefaultDialogOptions(&dialogOptions);	if(theErr)	return theErr;		if(message != nil)	BlockMove(message, dialogOptions.message, sizeof(Str255));	else	dialogOptions.message[0] = 0;	#if TARGET_API_MAC_CARBON	theErr = NavChooseFolder(NULL, &theReply, &dialogOptions, NewNavEventUPP(FakeEventProc), NULL, NULL);#else	theErr = NavChooseFolder(NULL, &theReply, &dialogOptions, NULL, NULL, NULL);#endif	if((theErr == noErr) && theReply.validRecord) {		AEDesc 	resultDesc;				resultDesc.dataHandle = 0L;		if((theErr = AEGetNthDesc(&theReply.selection, 1, typeFSS, NULL, &resultDesc)) == noErr) {			AEGetDescData(&resultDesc, folder, sizeof(FSSpec));						AEDisposeDesc(&resultDesc);		}	}		NavDisposeReply(&theReply);	folder->name[0] = 0;		return theErr;}