/***************************************************************************** * Copyright (c) 1999-2002, Pierre-Olivier Latour * http://www.pol-online.net * info@pol-online.net * * This program is free software; you can redistribute it and/or modify * it under the terms of the GNU General Public License as published by * the Free Software Foundation; either version 2 of the License, or * (at your option) any later version. *  * This program is distributed in the hope that it will be useful, * but WITHOUT ANY WARRANTY; without even the implied warranty of * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the * GNU General Public License for more details. * * You should have received a copy of the GNU General Public License * along with this program; if not, write to the Free Software * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111, USA. *****************************************************************************/#include			"Application.h"#include			"Command Server.h"#include			"Account.h"#include			"Filter.h"#include			"Error Manager.h"#include			"Utils.h"#include			"Preferences.h"#include			"Window Server.h"#include			"Print Server.h"#include			"Navigation Utils.h"#include			"Dialog Utils.h"#include			"Keys.h"//PREPROCESSOR CONSTANTS:#define	__CONVERT_IMPORTS_TO_LOWERCASE__	1#define	__AUTOCOMPLETE_ALPHABETICAL__	0//CONSTANTS:#define				kAboutDelay						(60 * 3)#define				kSuspendResumeEvent				0x01000000#define				kResumeEvent					0x00000001#define				kMenuStringResID				132#define				kExportFormatStringResID		134#define				kExportFileCreator				'ttxt'#define				kExportFileType					'TEXT'#define				kImportTabTextDialogID			136#define				kMultipleOperationEditDialogID	137#define				kImportQIFDialogID				139#define				kEditFlag_Description			(1 << 0)#define				kEditFlag_Date					(1 << 1)#define				kEditFlag_Amount				(1 << 2)#define				kEditFlag_PaymentType			(1 << 3)#define				kEditFlag_Custom				(1 << 4)#define				kEditFlag_Category				(1 << 5)#define				kEditFlag_Flags					(1 << 6)#define				kEditFlag_Note					(1 << 7)#define				kEditFlag_Conversion			(1 << 8)#if TARGET_API_MAC_CARBON#define				kMinimalCarbonVersion			0x0110#else#define				kMinimalOSVersion				0x0850#endif#if __CARBON_EVENTS__#define				kCarbonIdleFPS					15.0#else#define				kClassicSleepTime				20#endifenum {	kMenuFile_NewAccount = 1,	kMenuFile_NewFilter = 2,	kMenuFile_Delete = 4,	kMenuFile_PageSetup = 6,	kMenuFile_Print = 7,	kMenuFile_Quit = 9};enum {	kMenuEdit_Undo = 1,	kMenuEdit_Cut = 3,	kMenuEdit_Copy = 4,	kMenuEdit_Paste = 5,	kMenuEdit_Duplicate = 7,	kMenuEdit_Preferences = 9};enum {	kMenuDisplay_AccountList = 1,	kMenuDisplay_Category = 3,	kMenuDisplay_PaymentType = 4,	kMenuDisplay_CustomInfo = 5,	kMenuDisplay_Special = 6};enum {	kMenuAccount_Information = 1,	kMenuAccount_Password = 2,	kMenuAccount_Automatic = 3,	kMenuAccount_Import = 5,	kMenuAccount_Export = 6,	kMenuAccount_NewTransaction = 8,	kMenuAccount_EditTransaction = 9,	kMenuAccount_DeleteTransaction = 10};enum {	kExportFormat_TabText = 0,	kExportFormat_QIF,	kNumExportFormats};#if __DEMO__#define				kType					"Demo"#elif __BASIC__#define				kType					"Basic"#else#define				kType					"Pro"#endif#if TARGET_API_MAC_CARBON#define				kOS						"(Carbon)"#else#define				kOS						"(Classic)"#endif#define				kVersion				"\pVersion 1.7.6 " kType " " kOS//VRAIABLES:ApplicationPtr		application;ModalFilterUPP		ModalDialogRoutine = NULL;Boolean				dialogCharReceived = false;EventRecord			lastModalDialogEvent;//ROUTINES:inline unsigned char CharToSmall(unsigned char c){	if((c >= 'A') && (c <= 'Z'))	return c - 'A' + 'a';		return c;}OSErr Application::_InstallMenuBar(){	Handle				menuBar;	long				i;		//Load menu bar	menuBar = GetNewMBar(128);	if(menuBar == nil)	return ResError();	SetMenuBar(menuBar);	#if TARGET_API_MAC_CARBON	long 				response;	MenuHandle			theMenu;		//Adapt menus to MacOS X	if((Gestalt(gestaltMenuMgrAttr, &response) == noErr) && (response & gestaltMenuMgrAquaLayoutMask)) {		//Remove Quit item from File menu		theMenu = GetMenuHandle(MenuNumToID(kFileMenu));		DeleteMenuItem(theMenu, CountMenuItems(theMenu));		DeleteMenuItem(theMenu, CountMenuItems(theMenu));				//Remove Preferences item from Edit menu		theMenu = GetMenuHandle(MenuNumToID(kEditMenu));		DeleteMenuItem(theMenu, CountMenuItems(theMenu));		DeleteMenuItem(theMenu, CountMenuItems(theMenu));				//Enable Preferences item in Application menu		EnableMenuCommand(NULL, kHICommandPreferences);	}#else	//Append items to Apple menu	AppendResMenu(GetMenuHandle(MenuNumToID(kAppleMenu)), 'DRVR');#endif		//Draw menu bar	DrawMenuBar();		//Get menus	for(i = 0; i < kNumMenus; ++i)	menus[i] = GetMenuHandle(MenuNumToID(i));		//Insert dialog menus	InsertMenu(GetMenu(kCategoryMenuID), kInsertHierarchicalMenu);	InsertMenu(GetMenu(kPaymentMenuID), kInsertHierarchicalMenu);	InsertMenu(GetMenu(kFontMenuID), kInsertHierarchicalMenu);	InsertMenu(GetMenu(kAccountMenuID), kInsertHierarchicalMenu);	InsertMenu(GetMenu(kMacroMenuID), kInsertHierarchicalMenu);		//Build font menu	AppendResMenu(GetMenuHandle(kFontMenuID), 'FONT');		return noErr;}#if TARGET_API_MAC_CARBON && !__CARBON_EVENTS__static pascal OSErr PREF_Handler(const AppleEvent* theAppleEvent, AppleEvent* reply, long handlerRefCon){	return application->commandServer->Execute(kCommand_EditPreferences);}#endif#if !TARGET_API_MAC_CARBON || !__CARBON_EVENTS__static pascal OSErr QUIT_Handler(const AppleEvent* theAppleEvent, AppleEvent* reply, long handlerRefCon){	return application->commandServer->Execute(kCommand_Quit);}#endifOSErr Application::_NewAccountFromFile(FSSpec* file){	Boolean			conflict = false;	AccountPtr		theAccount;	OSErr			theError;	long			i;		//Make sure we have not reached the maximal number of accounts	if(accountCount >= kApplication_MaxAccounts) {		errorManager->StandardError(23, (void*) kApplication_MaxAccounts);		return paramErr;	}		//Create empty account	theAccount = new Account;	if(theAccount == NULL) {		errorManager->StandardError(24);		return -1;	}		//Load account from disk	theError = theAccount->ReadFromDisk(file);	if(theError) {		if(theError == paramErr)		errorManager->StandardError(49, file->name);		else		errorManager->StandardError(25, file->name, (void*) theError);		delete theAccount;		return theError;	}		//Check account unique ID	for(i = 0; i < accountCount; ++i)	if(accountList[i]->data->id == theAccount->data->id) {		conflict = true;		break;	}	for(i = 0; i < filterCount; ++i)	if(filterList[i]->data->id == theAccount->data->id) {		conflict = true;		break;	}	if(conflict) {		errorManager->StandardError(55, file->name);		delete theAccount;		return paramErr;	}		//Update accound list	accountList[accountCount] = theAccount;	++accountCount;		return noErr;}OSErr Application::_NewFilterFromFile(FSSpec* file){	Boolean			conflict = false;	FilterPtr		theFilter;	OSErr			theError;	long			i;		//Make sure we have not reached the maximal number of filters	if(filterCount >= kApplication_MaxFilters) {		errorManager->StandardError(36, (void*) kApplication_MaxFilters);		return paramErr;	}		//Create empty filter	theFilter = new Filter;	if(theFilter == NULL) {		errorManager->StandardError(37);		return -1;	}		//Load filter from disk	theError = theFilter->ReadFromDisk(file);	if(theError) {		if(theError == paramErr)		errorManager->StandardError(50, file->name);		else		errorManager->StandardError(48, file->name, (void*) theError);		delete theFilter;		return theError;	}		//Check filter unique ID	for(i = 0; i < accountCount; ++i)	if(accountList[i]->data->id == theFilter->data->id) {		conflict = true;		break;	}	for(i = 0; i < filterCount; ++i)	if(filterList[i]->data->id == theFilter->data->id) {		conflict = true;		break;	}	if(conflict) {		errorManager->StandardError(55, file->name);		delete theFilter;		return paramErr;	}		//Update filter list	filterList[filterCount] = theFilter;	++filterCount;		return noErr;}static void DrawAboutVersion(){	TextSize(12);	TextFace(0);	MoveTo(/*14*/ 500 - StringWidth(kVersion) - 6, 12 /*200 - 10*/);	ForeColor(whiteColor);	DrawString(kVersion);	ForeColor(blackColor);}Application::Application(){	OSErr				theError;	long				response;	Handle				printSettings;	Boolean				isTHPrint;#if !__DEBUG__	GrafPtr				savePort;	DialogPtr			theDialog;	unsigned long		startTime;#endif	#if !TARGET_API_MAC_CARBON	//Prepare memory	MaxApplZone();	MoreMasters();		//Init Toolbox	InitGraf(&qd.thePort);	InitFonts();	InitWindows();	InitMenus();	TEInit();	InitDialogs(nil);	GetDateTime((unsigned long*) &qd.randSeed);#else	GetDateTime((unsigned long*) &response);	SetQDGlobalsRandomSeed(response);#endif	InitCursor();	InitFastCompareStringCacheTable();		//Save our resource file ID	resFileID = CurResFile();	#if TARGET_API_MAC_CARBON	//Check Carbon version	if((Gestalt(gestaltCarbonVersion, &response) != noErr) || (response < kMinimalCarbonVersion))	PanicError(6);#else	//Check MacOS version	if((Gestalt(gestaltSystemVersion, &response) != noErr) || (response < kMinimalOSVersion))	PanicError(1);		//Init Appearance Manager	if(((RoutineDescriptorPtr) RegisterAppearanceClient == (RoutineDescriptorPtr) kUnresolvedCFragSymbolAddress) || (RegisterAppearanceClient() != noErr))	PanicError(2);		//Init Navigation Services	if(((RoutineDescriptorPtr) NavLoad == (RoutineDescriptorPtr) kUnresolvedCFragSymbolAddress) || (NavLoad() != noErr))	PanicError(3);#endif	#if TARGET_API_MAC_CARBON	//Are we running under MacOS Classic?	if((Gestalt(gestaltSystemVersion, &response) != noErr) || (response < 0x1000))	PanicError(7);#else	//Are we running under MacOS X Classic?	/*if((Gestalt(gestaltMacOSCompatibilityBoxAttr, &response) == noErr) && (response & (1 << gestaltMacOSCompatibilityBoxPresent)))	PanicError(8);*/#endif	//Init ID generator & start date	GetDateTime(&_idGenerator);	GetDateTime(&today);	today = DateToDay(today);		//Init menus	if(_InstallMenuBar())	PanicError(5);	#if !__DEBUG__	GetPort(&savePort);	theDialog = GetNewDialog(kAboutDialogID, nil, (WindowPtr) -1);	SetPortDialogPort(theDialog);	NormalizeThemeDrawingState();	DrawDialog(theDialog);	DrawAboutVersion();#if TARGET_API_MAC_CARBON	if(QDIsPortBuffered(GetDialogPort(theDialog))) {		RgnHandle			theRegion;		Rect				bounds;				theRegion = NewRgn();		GetPortBounds(GetDialogPort(theDialog), &bounds);		RectRgn(theRegion, &bounds);		QDFlushPortBuffer(GetDialogPort(theDialog), theRegion);		DisposeRgn(theRegion);	}#endif	SetPort(savePort);	startTime = TickCount();#endif	//Create error manager	errorManager = new ErrorManager;	if(errorManager == NULL)	PanicError(4);		//Create preferences	prefs = new Preferences(errorManager, &printSettings, &isTHPrint);	if(prefs == NULL)	errorManager->FatalError(15);		//Create command server	commandServer = new CommandServer;	if(commandServer == NULL)	errorManager->FatalError(20);		//Create windowServer with skin#if __DEMO__	prefs->data->skinResID = kSkinStartResID;#endif	windowServer = new WindowServer(prefs->data, &theError);	if((windowServer == NULL) || theError)	errorManager->FatalError(40, (void*) theError);		//Create print server	printServer = new PrintServer(errorManager, printSettings, isTHPrint);	if(printServer == NULL)	errorManager->FatalError(34, (void*) -1);		//Load accounts & filters	accountCount = 0;	filterCount = 0;	{		short			idx;		CInfoPBRec		cipbr;		HFileInfo		*fpb = (HFileInfo*) &cipbr;		FSSpec			file;		Str255			name;				file.vRefNum = prefs->data->accountFolder.vRefNum;		file.parID = prefs->data->accountFolder.parID;				fpb->ioVRefNum = file.vRefNum;		fpb->ioNamePtr = name;		for(idx = 1; true; ++idx) {			fpb->ioDirID = file.parID;			fpb->ioFDirIndex = idx;			if(PBGetCatInfo(&cipbr, false))			break;						if(!(fpb->ioFlAttrib & 16) && (name[1] != kSkipFileChar)) {				BlockMove(name, file.name, sizeof(Str63));				if(fpb->ioFlFndrInfo.fdType == kAccount_FileType)				_NewAccountFromFile(&file);				else if(fpb->ioFlFndrInfo.fdType == kFilter_FileType)				_NewFilterFromFile(&file);			}		}	}	SortAccountsAlphabetically();	SortFiltersAlphabetically();	#if !__DEBUG__	while(!Button() && (TickCount() < startTime + kAboutDelay))	;	DisposeDialog(theDialog);	FlushEvents(mDownMask | mUpMask, 0);#endif	//Install Apple Events handlers#if TARGET_API_MAC_CARBON && !__CARBON_EVENTS__	AEInstallEventHandler(kCoreEventClass, kAEShowPreferences, NewAEEventHandlerUPP(PREF_Handler), NULL, false);#endif#if !TARGET_API_MAC_CARBON || !__CARBON_EVENTS__	AEInstallEventHandler(kCoreEventClass, kAEQuitApplication, NewAEEventHandlerUPP(QUIT_Handler), NULL, false);#endif	#if __DEMO__	errorManager->Note(53, (void*) kApplication_MaxAccounts, (void*) kApplication_MaxFilters, (void*) kAccount_MaxOperations);#endif}Application::~Application(){	long				i;	#if __CARBON_EVENTS__	//Remove timer	RemoveEventLoopTimer(timerRef);#endif		//delete from memory	for(i = 0; i < accountCount; ++i)	delete accountList[i];	for(i = 0; i < filterCount; ++i)	delete filterList[i];	delete prefs;		//Kill print server	delete printServer;		//Kill windowServer	delete windowServer;		//Kill command server	delete commandServer;		//Kill error manager	delete errorManager;}OSErr Application::WriteAccountToDisk(Account* account){	OSErr				theError;		if(!account)	return paramErr;		theError = account->WriteToDisk(&prefs->data->accountFolder);	if(theError)	errorManager->StandardError(18, account->data->name, (void*) theError);		return theError;}OSErr Application::WriteFilterToDisk(Filter* filter){	OSErr				theError;		if(!filter)	return paramErr;		theError = filter->WriteToDisk(&prefs->data->accountFolder);	if(theError)	errorManager->StandardError(38, filter->data->name, (void*) theError);		return theError;}Boolean Application::WriteAllToDisk(){	long				i;	OSErr				theError;	Boolean				saveOK = true;		//Write all accounts to disk	for(i = 0; i < accountCount; ++i)	if(WriteAccountToDisk(accountList[i]) != noErr)	saveOK = false;		//Write all filters to disk	for(i = 0; i < filterCount; ++i)	if(WriteFilterToDisk(filterList[i]) != noErr)	saveOK = false;		//Write prefs to disk	theError = prefs->WriteToDisk(printServer->printSettings);	if(theError) {		errorManager->StandardError(14, (void*) theError);		saveOK = false;	}		return saveOK;}#if __CARBON_EVENTS__OSStatus Application::CarbonApplicationEventHandler(EventRef event){	OSErr			theError;		switch(GetEventClass(event)) {				case kEventClassCommand:		switch(GetEventKind(event)) {						case kEventCommandProcess:			{				HICommand			command;							theError = GetEventParameter(event, kEventParamDirectObject, typeHICommand, NULL, sizeof(HICommand), NULL, &command);				if(theError)				return theError;				if(command.commandID) {					theError = commandServer->Execute(command.commandID);					if(theError == paramErr)					return eventNotHandledErr;					else if(theError)					errorManager->StandardError(13, (void*) theError);										return noErr;				}			}			break;					}		break;				case kEventClassKeyboard:		switch(GetEventKind(event)) {						case kEventRawKeyDown:			case kEventRawKeyRepeat:			{				char			theChar;				unsigned long	modifiers,								theKey;								if(IsWindowActive(windowServer->window)) {					theError = GetEventParameter(event, kEventParamKeyMacCharCodes, typeChar, NULL, sizeof(char), NULL, &theChar);					if(theError)					return theError;					theError = GetEventParameter(event, kEventParamKeyCode, typeUInt32, NULL, sizeof(UInt32), NULL, &theKey);					if(theError)					return theError;					theError = GetEventParameter(event, kEventParamKeyModifiers, typeUInt32, NULL, sizeof(UInt32), NULL, &modifiers);					if(theError)					return theError;										if(!(modifiers & cmdKey) && (commandServer->Execute(kCommand_KeyWindow, (void*) theChar, (void*) theKey, (void*) (short) modifiers) == noErr))					return noErr;				}			}			break;					}		break;				case kEventClassWindow:		switch(GetEventKind(event)) {						case kEventWindowUpdate:			{				WindowRef		window;								theError = GetEventParameter(event, kEventParamDirectObject, typeWindowRef, NULL, sizeof(WindowRef), NULL, &window);				if(theError)				return theError;								if((window == windowServer->window) && (commandServer->Execute(kCommand_UpdateServerWindow) == noErr))				return noErr;			}			break;					}		break;				case kEventClassMouse:		switch(GetEventKind(event)) {						case kEventMouseWheelMoved:			{				long			delta;								if(IsWindowActive(windowServer->window)) {					theError = GetEventParameter(event, kEventParamMouseWheelDelta, typeLongInteger, NULL, sizeof(long), NULL, &delta);					if(theError)					return theError;										if(commandServer->Execute(kCommand_ScrollWindow, (void*) delta) == noErr)					return noErr;				}			}			break;					}		break;			}		return eventNotHandledErr;}OSStatus Application::CarbonWindowEventHandler(EventRef event){	OSErr				theError;		switch(GetEventClass(event)) {				case kEventClassWindow:		switch(GetEventKind(event)) {						case kEventWindowActivated:			windowServer->Resume();			return noErr;			break;						case kEventWindowDeactivated:			windowServer->Suspend();			return noErr;			break;					}		break;				case kEventClassMouse:		switch(GetEventKind(event)) {						case kEventMouseDown:			{				unsigned long	modifiers;								if(IsWindowActive(windowServer->window)) {					theError = GetEventParameter(event, kEventParamKeyModifiers, typeUInt32, NULL, sizeof(UInt32), NULL, &modifiers);					if(theError)					return theError;										if(commandServer->Execute(kCommand_ClickWindow, (void*) (short) modifiers) == noErr)					return noErr;				}			}			break;					}		break;			}		return eventNotHandledErr;}#elsevoid Application::ClassicEventLoop(){	OSErr					theError;	short					whereClick;	WindowPtr				whichWin;		run = true;	while(run) {		if(WaitNextEvent(everyEvent, &_event, kClassicSleepTime, NULL)) {			switch(_event.what) {								case mouseDown:				whereClick = FindWindow(_event.where, &whichWin);				switch(whereClick) {										case inMenuBar:					theError = commandServer->Execute(commandServer->GetFromMenu(MenuSelect(_event.where)));					HiliteMenu(0);					if(theError)					errorManager->StandardError(13, (void*) theError);					break;										case inContent:					if(whichWin != windowServer->window)					break;					commandServer->Execute(kCommand_ClickWindow, (void*) _event.modifiers);					break;									}				break;								case keyDown:				case autoKey:				if(_event.modifiers & cmdKey) {					theError = commandServer->Execute(commandServer->GetFromMenu(MenuEvent(&_event)));					HiliteMenu(0);					if(theError)					errorManager->StandardError(13, (void*) theError);				}				else				commandServer->Execute(kCommand_KeyWindow, (void*) (_event.message & charCodeMask), (void*) ((_event.message & keyCodeMask) >> 8), (void*) _event.modifiers);				break;								case updateEvt:				if((WindowPtr) _event.message == windowServer->window)				commandServer->Execute(kCommand_UpdateServerWindow);				break;								case osEvt:				if(_event.message & kSuspendResumeEvent) {					if(_event.message & kResumeEvent)					theError = commandServer->Execute(kCommand_ApplicationResume);					else					theError = commandServer->Execute(kCommand_ApplicationSuspend);					if(theError)					errorManager->StandardError(13, (void*) theError);				}				break;								case kHighLevelEvent:				if((OSType) _event.message == typeAppleEvent)				AEProcessAppleEvent(&_event);				break;								case activateEvt:				if((WindowPtr) _event.message == windowServer->window) {					if(_event.modifiers & activeFlag)					windowServer->Resume();					else					windowServer->Suspend();				}				break;							}		}		Idle();	}}#endif#if !__DEMO__Boolean Application::DeleteAccount(long num){	//Make sure the account is not locked	if(!accountList[num]->Unlock())	return false;		//Request user confirmation	if(!errorManager->Warning(19, (void*) accountList[num]->data->name))	return false;				//Request user confirmation 2!	if(!errorManager->Warning(45, (void*) accountList[num]->data->name))	return false;				//Delete account from disk & memory	accountList[num]->RemoveFromDisk();	delete accountList[num];		//Update account list	--accountCount;	accountList[num] = accountList[accountCount];	SortAccountsAlphabetically();		return true;}Boolean Application::DeleteFilter(long num){	//Request user confirmation	if(!errorManager->Warning(35, (void*) filterList[num]->data->name))	return false;				//Delete filter from disk & memory	filterList[num]->RemoveFromDisk();	delete filterList[num];		//Update filter list	--filterCount;	filterList[num] = filterList[filterCount];	SortFiltersAlphabetically();		return true;}OSErr Application::NewAccountFromUser(){	AccountPtr		theAccount;	OSErr			theError;		//Make sure we have not reached the maximal number of accounts	if(accountCount >= kApplication_MaxAccounts) {		errorManager->StandardError(23, (void*) kApplication_MaxAccounts);		return paramErr;	}		//Create empty account	theAccount = new Account;	if(theAccount == NULL) {		errorManager->StandardError(24);		return -1;	}		//Clear account	theError = theAccount->CreateNew();	if(theError) {		errorManager->StandardError(24);		delete theAccount;		return -1;	}		//Edit account info	if(!theAccount->EditInfo()) {		delete theAccount;		return -1;	}		//Update account list	accountList[accountCount] = theAccount;	++accountCount;	SortAccountsAlphabetically();		//Save on disk	if(prefs->data->flags & kPreferencesFlag_AutoSave)	WriteAccountToDisk(theAccount);		//Notify Window Server	windowServer->ClearFilterText();	windowServer->Invalidate(theAccount->data->id);		return noErr;}OSErr Application::NewFilterFromUser(){	FilterPtr		theFilter;	OSErr			theError;		//Make sure we have not reached the maximal number of filters	if(filterCount >= kApplication_MaxFilters) {		errorManager->StandardError(36, (void*) kApplication_MaxFilters);		return paramErr;	}		//Create empty filter	theFilter = new Filter;	if(theFilter == NULL) {		errorManager->StandardError(37);		return -1;	}		//Clear filter	theError = theFilter->CreateNew();	if(theError) {		errorManager->StandardError(37);		delete theFilter;		return -1;	}		//Edit filter info	if(!theFilter->EditInfo()) {		delete theFilter;		return -1;	}		//Update filter list	filterList[filterCount] = theFilter;	++filterCount;	SortFiltersAlphabetically();		//Save on disk	if(prefs->data->flags & kPreferencesFlag_AutoSave)	WriteFilterToDisk(theFilter);		//Notify Window Server	windowServer->ClearFilterText();	if(theFilter->IsLocked(accountCount, accountList))	windowServer->Invalidate();	else	windowServer->Invalidate(theFilter->data->id);		return noErr;}#endifvoid Application::SortAccountsAlphabetically(){	AccountPtr			temp;	long				i,						j;		//Accounts quick sort	for(i = 0; i < accountCount - 1; ++i)	for(j = 0; j < accountCount - 1; ++j) {		if(FastCompareString(accountList[j]->data->name, accountList[j + 1]->data->name) == 1) {			temp = accountList[j];			accountList[j] = accountList[j + 1];			accountList[j + 1] = temp;		}	}}void Application::SortFiltersAlphabetically(){	FilterPtr			temp;	long				i,						j;		//Filters quick sort	for(i = 0; i < filterCount - 1; ++i)	for(j = 0; j < filterCount - 1; ++j) {		if(FastCompareString(filterList[j]->data->name, filterList[j + 1]->data->name) == 1) {			temp = filterList[j];			filterList[j] = filterList[j + 1];			filterList[j + 1] = temp;		}	}}ID Application::GenerateUniqueID(){	++_idGenerator;	return _idGenerator;}void Application::SynchronizeMenus(){	long				targetNum = windowServer->GetTargetNum();	Str63				text;		//Sync File menu	if(TargetNumIsFilter(targetNum))	XGetIndString(text, kMenuStringResID, 2);	else	XGetIndString(text, kMenuStringResID, 1);	SetMenuItemText(menus[kFileMenu], kMenuFile_Delete, text);#if __DEMO__	DisableMenuItem(menus[kFileMenu], kMenuFile_NewAccount);	DisableMenuItem(menus[kFileMenu], kMenuFile_NewFilter);	DisableMenuItem(menus[kFileMenu], kMenuFile_Delete);	if(targetNum != kUndefinedNum)	EnableMenuItem(menus[kFileMenu], kMenuFile_Print);	else	DisableMenuItem(menus[kFileMenu], kMenuFile_Print);#else	if(targetNum != kUndefinedNum) {		EnableMenuItem(menus[kFileMenu], kMenuFile_Delete);		EnableMenuItem(menus[kFileMenu], kMenuFile_Print);	}	else {		DisableMenuItem(menus[kFileMenu], kMenuFile_Delete);		DisableMenuItem(menus[kFileMenu], kMenuFile_Print);	}#endif		//Sync Edit menu	switch(windowServer->userFocus) {				case kFocus_OperationList:		if(TargetNumIsFilter(targetNum)) {			DisableMenuItem(menus[kEditMenu], kMenuEdit_Cut);			if(windowServer->GetOperationsSelectionSize())			EnableMenuItem(menus[kEditMenu], kMenuEdit_Copy);			else			DisableMenuItem(menus[kEditMenu], kMenuEdit_Copy);			DisableMenuItem(menus[kEditMenu], kMenuEdit_Paste);			DisableMenuItem(menus[kEditMenu], kMenuEdit_Duplicate);		}		else {			if(windowServer->GetOperationsSelectionSize()) {				EnableMenuItem(menus[kEditMenu], kMenuEdit_Cut);				EnableMenuItem(menus[kEditMenu], kMenuEdit_Copy);				EnableMenuItem(menus[kEditMenu], kMenuEdit_Duplicate);			}			else {				DisableMenuItem(menus[kEditMenu], kMenuEdit_Cut);				DisableMenuItem(menus[kEditMenu], kMenuEdit_Copy);				DisableMenuItem(menus[kEditMenu], kMenuEdit_Duplicate);			}			if(windowServer->ClipBoardContentValid())			EnableMenuItem(menus[kEditMenu], kMenuEdit_Paste);			else			DisableMenuItem(menus[kEditMenu], kMenuEdit_Paste);		}		break;				case kFocus_Filter:		EnableMenuItem(menus[kEditMenu], kMenuEdit_Cut);		EnableMenuItem(menus[kEditMenu], kMenuEdit_Copy);		EnableMenuItem(menus[kEditMenu], kMenuEdit_Paste);		DisableMenuItem(menus[kEditMenu], kMenuEdit_Duplicate);		break;				default:		DisableMenuItem(menus[kEditMenu], kMenuEdit_Cut);		DisableMenuItem(menus[kEditMenu], kMenuEdit_Copy);		DisableMenuItem(menus[kEditMenu], kMenuEdit_Paste);		DisableMenuItem(menus[kEditMenu], kMenuEdit_Duplicate);		break;			}		//Sync Display menu	CheckMenuItem(menus[kDisplayMenu], kMenuDisplay_AccountList, windowServer->IsAccountListVisible());	CheckMenuItem(menus[kDisplayMenu], kMenuDisplay_Category, windowServer->IsColumnVisible(kOperationColumn_Category));	CheckMenuItem(menus[kDisplayMenu], kMenuDisplay_PaymentType, windowServer->IsColumnVisible(kOperationColumn_PaymentType));	CheckMenuItem(menus[kDisplayMenu], kMenuDisplay_CustomInfo, windowServer->IsColumnVisible(kOperationColumn_Custom));	if(TargetNumIsFilter(targetNum)) {		XGetIndString(text, kColumnStringsID, 15);		SetMenuItemText(menus[kDisplayMenu], kMenuDisplay_Special, text);		CheckMenuItem(menus[kDisplayMenu], kMenuDisplay_Special, windowServer->IsColumnVisible(kOperationColumn_Account));	}	else {		XGetIndString(text, kColumnStringsID, 11);		SetMenuItemText(menus[kDisplayMenu], kMenuDisplay_Special, text);		CheckMenuItem(menus[kDisplayMenu], kMenuDisplay_Special, windowServer->IsColumnVisible(kOperationColumn_Balance));	}		//Sync Account menu	if((targetNum != kUndefinedNum) && (windowServer->GetOperationsSelectionSize() > 1)) {		XGetIndString(text, kMenuStringResID, 4);		SetMenuItemText(menus[kAccountMenu], kMenuAccount_EditTransaction, text);		XGetIndString(text, kMenuStringResID, 6);		SetMenuItemText(menus[kAccountMenu], kMenuAccount_DeleteTransaction, text);	}	else {		XGetIndString(text, kMenuStringResID, 3);		SetMenuItemText(menus[kAccountMenu], kMenuAccount_EditTransaction, text);		XGetIndString(text, kMenuStringResID, 5);		SetMenuItemText(menus[kAccountMenu], kMenuAccount_DeleteTransaction, text);	}	if(targetNum != kUndefinedNum) {		EnableMenuItem(menus[kAccountMenu], 0);		if(TargetNumIsFilter(targetNum)) {			DisableMenuItem(menus[kAccountMenu], kMenuAccount_Password);			DisableMenuItem(menus[kAccountMenu], kMenuAccount_Automatic);			DisableMenuItem(menus[kAccountMenu], kMenuAccount_Import);			DisableMenuItem(menus[kAccountMenu], kMenuAccount_NewTransaction);		}		else {			EnableMenuItem(menus[kAccountMenu], kMenuAccount_Password);			EnableMenuItem(menus[kAccountMenu], kMenuAccount_Automatic);			EnableMenuItem(menus[kAccountMenu], kMenuAccount_Import);			EnableMenuItem(menus[kAccountMenu], kMenuAccount_NewTransaction);		}		if(windowServer->GetOperationCacheList() != NULL)		EnableMenuItem(menus[kAccountMenu], kMenuAccount_Export);		else		DisableMenuItem(menus[kAccountMenu], kMenuAccount_Export);		if((windowServer->userFocus == kFocus_OperationList) && windowServer->GetOperationsSelectionSize()) {#if __BASIC__			if(windowServer->GetOperationsSelectionSize() > 1)			DisableMenuItem(menus[kAccountMenu], kMenuAccount_EditTransaction);			else#else			EnableMenuItem(menus[kAccountMenu], kMenuAccount_EditTransaction);#endif			EnableMenuItem(menus[kAccountMenu], kMenuAccount_DeleteTransaction);		}		else {			DisableMenuItem(menus[kAccountMenu], kMenuAccount_EditTransaction);			DisableMenuItem(menus[kAccountMenu], kMenuAccount_DeleteTransaction);		}	}	else	DisableMenuItem(menus[kAccountMenu], 0);#if __BASIC__	DisableMenuItem(menus[kAccountMenu], kMenuAccount_Automatic);	DisableMenuItem(menus[kAccountMenu], kMenuAccount_Export);#endif}void Application::ShowAbout(short resID){	GrafPtr					savePort;	DialogPtr				theDialog;#if TARGET_API_MAC_CARBON	Point					mouse;	MouseTrackingResult		result;#endif		//Display dialog	GetPort(&savePort);	theDialog = GetNewDialog(resID, nil, (WindowPtr) -1);	SetPortDialogPort(theDialog);	DrawDialog(theDialog);	NormalizeThemeDrawingState();	if(resID == kAboutDialogID)	DrawAboutVersion();#if TARGET_API_MAC_CARBON	if(QDIsPortBuffered(GetDialogPort(theDialog))) {		RgnHandle			theRegion;		Rect				bounds;				theRegion = NewRgn();		GetPortBounds(GetDialogPort(theDialog), &bounds);		RectRgn(theRegion, &bounds);		QDFlushPortBuffer(GetDialogPort(theDialog), theRegion);		DisposeRgn(theRegion);	}#endif		//Run#if TARGET_API_MAC_CARBON	do {		TrackMouseLocation(GetDialogPort(theDialog), &mouse, &result);	} while(result != kMouseTrackingMouseUp);#else	while(!Button())	;#endif		DisposeDialog(theDialog);	SetPort(savePort);	#if !TARGET_API_MAC_CARBON	FlushEvents(mDownMask | mUpMask, 0);#endif}static void NavDialogHandler(EventRecord* theEvent, void* refcon){#if !__CARBON_EVENTS__	if((theEvent->what == activateEvt) && ((WindowPtr) theEvent->message == application->windowServer->window)) {		if(theEvent->modifiers & activeFlag)		application->windowServer->Resume();		else		application->windowServer->Suspend();	}#endif		if((theEvent->what == updateEvt) && ((WindowPtr) theEvent->message == application->windowServer->window))	application->commandServer->Execute(kCommand_UpdateServerWindow);}#if !__BASIC__inline OSErr WriteString(short fileID, StringPtr text, unsigned char endChar){	long				size = text[0];	OSErr				theError = noErr;		if(size)	theError = FSWrite(fileID, &size, &text[1]);	if((theError == noErr) && endChar) {		size = 1;		theError = FSWrite(fileID, &size, &endChar);	}		return theError;}inline OSErr WriteChar(short fileID, unsigned char theChar){	long				size = 1;		return FSWrite(fileID, &size, &theChar);}OSErr Application::_ExportTabulatedText(short fileID){	OperationPtr		operation = windowServer->GetOperationCacheList();	long				targetNum = windowServer->GetTargetNum();	PaymentTypePtr		paymentList = prefs->data->payments->list;	CategoryPtr			categoryList = prefs->data->categories->list;	Str255				text;	OSErr				theError;	long				i;		//Write header	if(TargetNumIsFilter(targetNum)) {		XGetIndString(text, kMiscStringResID, 21);		theError = WriteString(fileID, text, 0);		if(theError)		return theError;		theError = WriteString(fileID, filterList[TargetNumToFilterNum(targetNum)]->data->name, 0);		if(theError)		return theError;		XGetIndString(text, kMiscStringResID, 22);		theError = WriteString(fileID, text, 0);		if(theError)		return theError;	}	else {		XGetIndString(text, kMiscStringResID, 19);		theError = WriteString(fileID, text, 0);		if(theError)		return theError;		theError = WriteString(fileID, accountList[TargetNumToAccountNum(targetNum)]->data->name, 0);		if(theError)		return theError;		if(accountList[TargetNumToAccountNum(targetNum)]->data->bank.accountNumber) {			theError = WriteString(fileID, "\p - ", 0);			if(theError)			return theError;			theError = WriteString(fileID, accountList[TargetNumToAccountNum(targetNum)]->data->bank.accountNumber, 0);			if(theError)			return theError;		}		XGetIndString(text, kMiscStringResID, 20);		theError = WriteString(fileID, text, 0);		if(theError)		return theError;	}		//Write column headers	XGetIndString(text, kColumnStringsID, kOperationColumn_Date);	theError = WriteString(fileID, text, kTabChar);	if(theError)	return theError;	XGetIndString(text, kColumnStringsID, kOperationColumn_Description);	theError = WriteString(fileID, text, kTabChar);	if(theError)	return theError;	XGetIndString(text, kColumnStringsID, kOperationColumn_Category);	theError = WriteString(fileID, text, kTabChar);	if(theError)	return theError;	XGetIndString(text, kColumnStringsID, kOperationColumn_PaymentType);	theError = WriteString(fileID, text, kTabChar);	if(theError)	return theError;	XGetIndString(text, kColumnStringsID, kOperationColumn_Custom);	theError = WriteString(fileID, text, kTabChar);	if(theError)	return theError;	XGetIndString(text, kColumnStringsID, kOperationColumn_Amount);	theError = WriteString(fileID, text, kTabChar);	if(theError)	return theError;	if(TargetNumIsAccount(targetNum)) {		XGetIndString(text, kColumnStringsID, kOperationColumn_Balance);		theError = WriteString(fileID, text, kTabChar);		if(theError)		return theError;	}	XGetIndString(text, kMiscStringResID, 27);	theError = WriteString(fileID, text, kTabChar);	if(theError)	return theError;	XGetIndString(text, kMiscStringResID, 23);	theError = WriteString(fileID, text, kReturnChar);	if(theError)	return theError;		//Write operations	while(operation) {		//Write date		if(prefs->data->flags & kPreferencesFlag_LongDates)		IUDateString(operation->date, longDate, text);		else		IUDateString(operation->date, shortDate, text);		theError = WriteString(fileID, text, kTabChar);		if(theError)		return theError;				//Write description		theError = WriteString(fileID, operation->description, kTabChar);		if(theError)		return theError;				//Write category		if(operation->categoryNum == kUndefinedNum)		theError = WriteChar(fileID, kTabChar);		else		theError = WriteString(fileID, categoryList[operation->categoryNum].name, kTabChar);		if(theError)		return theError;				//Write payment		if(operation->paymentTypeNum == kUndefinedNum)		theError = WriteChar(fileID, kTabChar);		else		theError = WriteString(fileID, paymentList[operation->paymentTypeNum].name, kTabChar);		if(theError)		return theError;				//Write custom		if(operation->customData[0])		theError = WriteString(fileID, operation->customData, kTabChar);		else		theError = WriteChar(fileID, kTabChar);		if(theError)		return theError;				//Write amount		AmountToString(operation->absoluteAmount, text, 0, kNoThousandSeparator, true);		theError = WriteString(fileID, text, kTabChar);		if(theError)		return theError;				//Write balance		if(TargetNumIsAccount(targetNum)) {			AmountToString(operation->balance, text, 0, kNoThousandSeparator, true);			theError = WriteString(fileID, text, kTabChar);			if(theError)			return theError;		}				//Write currency		theError = WriteString(fileID, operation->owner->data->currencySymbol, kTabChar);		if(theError)		return theError;				//Write note - Replace "CR" with space		text[0] = 0;		for(i = 1; i <= operation->note[0]; ++i) {			if(operation->note[i] != kReturnChar)			text[++text[0]] = operation->note[i];			else			text[++text[0]] = kNoteReturnChar;		}		if(text[0])		theError = WriteString(fileID, text, kReturnChar);		else		theError = WriteChar(fileID, kReturnChar);		if(theError)		return theError;				//Fetch next operation		operation = operation->next;	}		return noErr;}OSErr Application::_ExportQIF(short fileID){	long				categoryCount = prefs->data->categories->count;	CategoryPtr			categoryList = prefs->data->categories->list;	OperationPtr		operation = windowServer->GetOperationCacheList();	long				i;	OSErr				theError;	Str255				text,						text2;	DateTimeRec			dateRec;		//Export category list	theError = WriteString(fileID, "\p!Type:Cat", kReturnChar);	if(theError)	return theError;	for(i = 0; i < categoryCount; ++i)	if(categoryList[i].name[0]) {		//Write name		text[0] = 1;		text[1] = 'N';		AppendString(text, categoryList[i].name);		theError = WriteString(fileID, text, kReturnChar);				//Write description		if(theError == noErr)		theError = WriteString(fileID, "\pD", kReturnChar);				//Write expense category		if(theError == noErr)		theError = WriteString(fileID, "\pE", kReturnChar);				//Write end of entry		if(theError == noErr)		theError = WriteString(fileID, "\p^", kReturnChar);				//Check error		if(theError)		return theError;	}		//Export operation list	theError = WriteString(fileID, "\p!Type:Bank", kReturnChar);	if(theError)	return theError;	while(operation) {		//Write date		SecondsToDate(operation->date, &dateRec);		text[0] = 1;		text[1] = 'D';		NumToString(dateRec.month, text2);		AppendString(text, text2);		AppendString(text, "\p/");		NumToString(dateRec.day, text2);		AppendString(text, text2);		AppendString(text, "\p/");		NumToString(dateRec.year % 100, text2);		if(text2[0] == 1) {			text2[2] = text2[1];			text2[1] = '0';			text2[0] = 2;		}		AppendString(text, text2);		theError = WriteString(fileID, text, kReturnChar);		if(theError)		return theError;				//Write payee		text[0] = 1;		text[1] = 'P';		AppendString(text, operation->description);		theError = WriteString(fileID, text, kReturnChar);		if(theError)		return theError;				//Write memo - Replace "CR" with space		text[0] = 1;		text[1] = 'M';		if(operation->note[0]) {			text2[0] = 0;			for(i = 1; i <= operation->note[0]; ++i) {				if(operation->note[i] != kReturnChar)				text2[++text2[0]] = operation->note[i];				else				text2[++text2[0]] = kNoteReturnChar;			}			AppendString(text, text2);		}		theError = WriteString(fileID, text, kReturnChar);		if(theError)		return theError;				//Write amount		text[0] = 1;		text[1] = 'T';		AmountToString(operation->absoluteAmount, text2, '.', ',', true);		AppendString(text, text2);		theError = WriteString(fileID, text, kReturnChar);		if(theError)		return theError;				//Write clear status		if(operation->flags & kOperationFlag_Checked) {			theError = WriteString(fileID, "\pCX", kReturnChar);			if(theError)			return theError;		}				//Write category		text[0] = 1;		text[1] = 'L';		if(operation->categoryNum != kUndefinedNum)		AppendString(text, categoryList[operation->categoryNum].name);		theError = WriteString(fileID, text, kReturnChar);		if(theError)		return theError;				//Write end of entry		theError = WriteString(fileID, "\p^", kReturnChar);		if(theError)		return theError;				//Fetch next operation		operation = operation->next;	}		return noErr;}OSErr Application::ExportOperations(){	OSErr				theError;	NavigationParams	params;	Str31				fileName;	short				fileID;	Str255				text;	long				i;	Str255				formatNames[kNumExportFormats];#if !TARGET_API_MAC_CARBON	Boolean				NSWorkAround = false,						exportQIF = false;	KeyMap				keyMap;#endif	#if !TARGET_API_MAC_CARBON	//MacOS 8.6 NavServices bug workaround	if((Gestalt(gestaltSystemVersion, &i) != noErr) || (i <= 0x0860)) {		NSWorkAround = true;		GetKeys(keyMap);		if(IsKeyDown(keyMap, keyOption))		exportQIF = true;	}#endif		if(windowServer->GetOperationCacheList() == NULL)	return paramErr;		//Ask user where to save	BlockMove(kApplication_PName, params.applicationName, sizeof(Str63));	params.applicationCreator = kApplication_Creator;	params.eventCallback = NavDialogHandler;	params.callbackRefcon = NULL;	params.inFileType = kExportFileType;	XGetIndString(text, kMiscStringResID, 17);	XGetIndString(fileName, kMiscStringResID, 18);#if !TARGET_API_MAC_CARBON	if(NSWorkAround)	theError = NavigationPutFile(&params, text, fileName);	else {#endif		for(i = 0; i < kNumExportFormats; ++i)		XGetIndString(formatNames[i], kExportFormatStringResID, i + 1);		theError = NavigationPutFileFormats(&params, text, fileName, kNumExportFormats, formatNames);#if !TARGET_API_MAC_CARBON	}#endif	if(theError)	return theError;		//Delete previous file	if(params.replacing) {		theError = FSpDelete(&params.outFile);		if(theError)		return theError;	}		//Create file	theError = FSpCreate(&params.outFile, kExportFileCreator, kExportFileType, smSystemScript);	if(theError)	return theError;		//Open file	theError = FSpOpenDF(&params.outFile, fsRdWrPerm, &fileID);	if(theError) {		FSpDelete(&params.outFile);		return theError;	}	SetFPos(fileID, fsFromStart, 0);		//Export operations#if !TARGET_API_MAC_CARBON	if(NSWorkAround) {		if(exportQIF)		theError = _ExportQIF(fileID);		else		theError = _ExportTabulatedText(fileID);	}	else#endif	switch(params.formatIndex - 1) {				case kExportFormat_TabText:		theError = _ExportTabulatedText(fileID);		break;				case kExportFormat_QIF:		theError = _ExportQIF(fileID);		break;			}	//Close file	FSClose(fileID);	if(theError)	FSpDelete(&params.outFile);		return theError;}#endifinline long GetLineLength(Ptr in, Ptr end){	long		count = 0;		while((*in != kReturnChar) && (*in != kNewLineChar)) {		++in;		++count;		if(in >= end)		return count;	}		return count;}inline Ptr GetNextLine(Ptr in, Ptr end){	while((*in != kReturnChar) && (*in != kNewLineChar)) {		++in;		if(in >= end)		return NULL;	}	if((*in == kReturnChar) && (*(in + 1) == kNewLineChar))	in += 2;	else	in += 1;	if(in >= end)	return NULL;		return in;}inline Ptr GetLineItem(long index, Ptr in, Ptr end){	long		count = 1;		while(count != index) {		while(*in != kTabChar) {			++in;			if(in >= end)			return NULL;		}		++in;		if(in >= end)		return NULL;				++count;	}		return in;}inline long GetItemLength(Ptr in, Ptr end){	long		count = 0;		while((*in != kTabChar) && (*in != kReturnChar) && (*in != kNewLineChar)) {		++in;		++count;		if(in >= end)		return count;	}		return count;}inline long GetNumFromText(Ptr text, long length){	long				num;	Str31				string;		string[0] = 0;	for(num = 0; num < length; ++num)	string[++string[0]] = text[num];	StringToNum(string, &num);		return num;}inline Amount GetAmountFromText(Ptr text, long length, unsigned char decimalChar){	long				num;	Str31				string;	Amount				amount;		string[0] = 0;	for(num = 0; num < length; ++num)	string[++string[0]] = text[num];	StringToAmount(string, &amount, decimalChar);		return amount;}static Boolean GetImportParams_TabulatedText(PreferencesDataPtr prefs){	GrafPtr					savePort;	DialogPtr				theDialog;	ControlHandle			items[10];	short					itemHit;	long					i;	Str31					temp;		//Display dialog	GetPort(&savePort);	theDialog = GetNewDialog(kImportTabTextDialogID, nil, (WindowPtr) -1);	SetPortDialogPort(theDialog);	NormalizeThemeDrawingState();		//Get items	for(i = 0; i < 10; ++i)	GetDialogItemAsControl(theDialog, 3 + i, &items[i]);		//Set items	temp[0] = 1;	temp[1] = prefs->importTabText_decimalChar;	XSetDialogItemText(items[0], temp);	XSetDialogItemNum(items[1], prefs->importTabText_startLine);	XSetDialogItemNum(items[2], prefs->importTabText_dateIndex);	XSetDialogItemNum(items[3], prefs->importTabText_descriptionIndex);	XSetDialogItemNum(items[4], prefs->importTabText_incomeIndex);	XSetDialogItemNum(items[5], prefs->importTabText_expenseIndex);	XSetDialogItemNum(items[6], prefs->importTabText_customIndex);	XSetDialogItemNum(items[7], prefs->importTabText_categoryIndex);	XSetDialogItemNum(items[8], prefs->importTabText_paymentIndex);	if(prefs->importTabText_monthBefore)	SetControlValue(items[9], 1);		SelectDialogItemText(theDialog, 3, 0, 32000);	SetDialogDefaultItem(theDialog, 1);	SetDialogCancelItem(theDialog, 2);		//Run	do {		//Get dialog events		ModalDialog(ModalDialogRoutine, &itemHit);				if(itemHit == 12)		SetControlValue(items[9], !GetControlValue(items[9]));	} while((itemHit != 1) && (itemHit != 2));		if(itemHit == 1) {		XGetDialogItemText(items[0], temp, kStr31MaxLength);		prefs->importTabText_decimalChar = temp[1];		prefs->importTabText_startLine = XGetDialogItemNum(items[1]);		prefs->importTabText_dateIndex = XGetDialogItemNum(items[2]);		prefs->importTabText_descriptionIndex = XGetDialogItemNum(items[3]);		prefs->importTabText_incomeIndex = XGetDialogItemNum(items[4]);		prefs->importTabText_expenseIndex = XGetDialogItemNum(items[5]);		prefs->importTabText_customIndex = XGetDialogItemNum(items[6]);		prefs->importTabText_categoryIndex = XGetDialogItemNum(items[7]);		prefs->importTabText_paymentIndex = XGetDialogItemNum(items[8]);		if(GetControlValue(items[9]))		prefs->importTabText_monthBefore = true;		else		prefs->importTabText_monthBefore = false;	}		DisposeDialog(theDialog);	SetPort(savePort);		if(itemHit == 2)	return false;		return true;}static void Text2Date(char* text, long length, Boolean monthBefore, Date* date){	char*				end = text + length;	Str31				temp;	DateTimeRec			dateRec;	long				num;		//Clear date	BlockZero(&dateRec, sizeof(DateTimeRec));	*date = 0;		//Extract 1st item	temp[0] = 0;	while((*text >= '0') && (*text <= '9') && (text < end)) {		temp[++temp[0]] = *text;		++text;	}	if(!temp[0])	return;	StringToNum(temp, &num);	if(monthBefore)	dateRec.month = num;	else	dateRec.day = num;		//Extract 2nd item	++text;	temp[0] = 0;	while((*text >= '0') && (*text <= '9') && (text < end)) {		temp[++temp[0]] = *text;		++text;	}	if(!temp[0])	return;	StringToNum(temp, &num);	if(monthBefore)	dateRec.day = num;	else	dateRec.month = num;		//Extract 3rd item	++text;	temp[0] = 0;	while((*text >= '0') && (*text <= '9') && (text < end)) {		temp[++temp[0]] = *text;		++text;	}	if(!temp[0])	return;	StringToNum(temp, &num);	if(num < 100) {		if(num < 04) //FIXME: won't work after 2004!!		num += 2000;		else		num += 1900;	}	dateRec.year = num;						DateToSeconds(&dateRec, date);}#if __CONVERT_IMPORTS_TO_LOWERCASE__static void LowerCase(Str63 description){	Boolean				upperCaseOnly = true;	long				i;		//Check if all uppercase	for(i = 1; i <= description[0]; ++i)	if((description[i] >= 'a') && (description[i] <= 'z'))	upperCaseOnly = false;	if(upperCaseOnly) {		for(i = 2; i <= description[0]; ++i)		if((description[i] >= 'A') && (description[i] <= 'Z'))		description[i] = description[i] - 'A' + 'a';	}}#endifstatic void CleanDescription(Str63 description){	Boolean				upperCaseOnly = true;		//Remove pre space chars	while(description[0] && (description[1] == ' ')) {		--description[0];		BlockMove(&description[2], &description[1], description[0]);	}		//Remove post space chars	while(description[0] && (description[description[0]] == ' '))	--description[0];}long Application::_ImportTabulatedText(Account* account, Ptr data, long size, long* idCount, ID idList[]){	long				categoryCount = appPrefs->categories->count;	CategoryPtr			categoryList = appPrefs->categories->list;	long				paymentCount = appPrefs->payments->count;	PaymentTypePtr		paymentList = appPrefs->payments->list;	Ptr					end = data + size;	long				failure = 0;	long				i;	Ptr					line,						item;	long				lineLength,						itemLength;	Operation			operation;	Str63				text;		//Reset	*idCount = 0;		//Get user params	if(!GetImportParams_TabulatedText(prefs->data))	return -1;		//Find data start	line = data;	i = 1;	while(i < prefs->data->importTabText_startLine) {		line = GetNextLine(line, end);		if(line == NULL)		return 0;		++i;	}		//Scan data	while(1) {		//Scan line		lineLength = GetLineLength(line, end);		if(lineLength) {			//Clear operation			BlockZero(&operation, sizeof(Operation));						//Import date			item = GetLineItem(prefs->data->importTabText_dateIndex, line, line + lineLength);			if(item) {				itemLength = GetItemLength(item, end);				Text2Date(item, itemLength, prefs->data->importTabText_monthBefore, &operation.date);			}						//Import description			item = GetLineItem(prefs->data->importTabText_descriptionIndex, line, line + lineLength);			if(item) {				itemLength = GetItemLength(item, end);				operation.description[0] = 0;				for(i = 0; i < itemLength; ++i)				if(operation.description[0] < 63)				operation.description[++operation.description[0]] = item[i];			}						//Import income			item = GetLineItem(prefs->data->importTabText_incomeIndex, line, line + lineLength);			if(item) {				itemLength = GetItemLength(item, end);				if(itemLength)				operation.amount = GetAmountFromText(item, itemLength, prefs->data->importTabText_decimalChar);			}						//Import expense			if(prefs->data->importTabText_expenseIndex != prefs->data->importTabText_incomeIndex) {				item = GetLineItem(prefs->data->importTabText_expenseIndex, line, line + lineLength);				if(item) {					itemLength = GetItemLength(item, end);					if(itemLength) {						operation.amount = GetAmountFromText(item, itemLength, prefs->data->importTabText_decimalChar);						operation.flags |= kOperationFlag_Expense;					}				}			}						//Import custom			if(prefs->data->importTabText_customIndex) {				item = GetLineItem(prefs->data->importTabText_customIndex, line, line + lineLength);				if(item) {					itemLength = GetItemLength(item, end);					operation.customData[0] = 0;					for(i = 0; i < itemLength; ++i)					if(operation.customData[0] < 63)					operation.customData[++operation.customData[0]] = item[i];				}			}						//Import category			if(prefs->data->importTabText_categoryIndex) {				item = GetLineItem(prefs->data->importTabText_categoryIndex, line, line + lineLength);				if(item) {					itemLength = GetItemLength(item, end);					text[0] = 0;					for(i = 0; i < itemLength; ++i)					if(text[0] < 63)					text[++text[0]] = item[i];										for(i = 0; i < categoryCount; ++i)					if(FastEqualString(text, categoryList[i].name, false))					operation.category = categoryList[i].id;				}			}						//Import payment mode			if(prefs->data->importTabText_paymentIndex) {				item = GetLineItem(prefs->data->importTabText_paymentIndex, line, line + lineLength);				if(item) {					itemLength = GetItemLength(item, end);					text[0] = 0;					for(i = 0; i < itemLength; ++i)					if(text[0] < 63)					text[++text[0]] = item[i];										for(i = 0; i < paymentCount; ++i)					if(FastEqualString(text, paymentList[i].name, false))					operation.paymentType = paymentList[i].id;				}			}						//Check amount validity			if(operation.amount < 0) {				operation.amount = -operation.amount;				if(!(operation.flags & kOperationFlag_Expense))				operation.flags |= kOperationFlag_Expense;			}						//Add operation			CleanDescription(operation.description);#if __CONVERT_IMPORTS_TO_LOWERCASE__			LowerCase(operation.description);			LowerCase(operation.customData);			LowerCase(operation.note);#endif			if(operation.description[0] && operation.date) {				if(account->AddOperation(&operation)) {					if(*idCount < kMaxSelectedLines) {						idList[*idCount] = operation.id;						*idCount += 1;					}				}				else				++failure;			}			else			++failure;		}				//Get next line		line = GetNextLine(line, end);		if(line == NULL)		break;	}		return failure;}inline Boolean CompareStrings(Ptr a, Ptr b, long size){	Str63			sa,					sb;		BlockMove(a, &sa[1], size);	sa[0] = size;	BlockMove(b, &sb[1], size);	sb[0] = size;		return FastEqualString(sa, sb, false);}static Boolean GetImportParams_QIF(PreferencesDataPtr prefs){	GrafPtr					savePort;	DialogPtr				theDialog;	ControlHandle			items[4];	short					itemHit;	long					i;		//Display dialog	GetPort(&savePort);	theDialog = GetNewDialog(kImportQIFDialogID, nil, (WindowPtr) -1);	SetPortDialogPort(theDialog);	NormalizeThemeDrawingState();		//Get items	for(i = 0; i < 4; ++i)	GetDialogItemAsControl(theDialog, 3 + i, &items[i]);		//Set items	switch(prefs->importQIF_mode) {		case kImportMode_PayeeIsDescription: SetControlValue(items[0], 1); break;		case kImportMode_MemoIsDescription: SetControlValue(items[1], 1); break;		case kImportMode_PayeeMemoIsDescription: SetControlValue(items[2], 1); break;	}	if(prefs->importQIF_monthBefore)	SetControlValue(items[3], 1);		SetDialogDefaultItem(theDialog, 1);	SetDialogCancelItem(theDialog, 2);		//Run	do {		//Get dialog events		ModalDialog(ModalDialogRoutine, &itemHit);		switch(itemHit) {						case 3:			case 4:			case 5:			SetControlValue(items[0], 0);			SetControlValue(items[1], 0);			SetControlValue(items[2], 0);			SetControlValue(items[itemHit - 3], 1);			break;						case 6:			SetControlValue(items[3], !GetControlValue(items[3]));			break;					}	} while((itemHit != 1) && (itemHit != 2));		if(itemHit == 1) {		if(GetControlValue(items[0]))		prefs->importQIF_mode = kImportMode_PayeeIsDescription;		else if(GetControlValue(items[1]))		prefs->importQIF_mode = kImportMode_MemoIsDescription;		else		prefs->importQIF_mode = kImportMode_PayeeMemoIsDescription;				if(GetControlValue(items[3]))		prefs->importQIF_monthBefore = true;		else		prefs->importQIF_monthBefore = false;	}		DisposeDialog(theDialog);	SetPort(savePort);		if(itemHit == 2)	return false;		return true;}long Application::_ImportQIF(Account* account, Ptr data, long size, long* idCount, ID idList[]){	long				categoryCount = appPrefs->categories->count;	CategoryPtr			categoryList = appPrefs->categories->list;	long				failure = 0;	Ptr					end = data + size;	Boolean				importing = false;	Ptr					line;	Operation			operation;	long				lineLength,						i;	Str63				categoryName;		//Reset	*idCount = 0;	BlockZero(&operation, sizeof(Operation));		//Get user params	if(!GetImportParams_QIF(prefs->data))	return -1;		//Scan data	line = data;	while(1) {		//Check for known header		if(*line == '!') {#if 1			importing = false;			if(CompareStrings(line, "!Type:Bank", 10))			importing = true;			else if(CompareStrings(line, "!Type:Cash", 10))			importing = true;			else if(CompareStrings(line, "!Type:CCard", 11))			importing = true;			else if(CompareStrings(line, "!Type:Oth A", 11))			importing = true;			else if(CompareStrings(line, "!Type:Oth L", 11))			importing = true;#else			importing = true;			if(CompareStrings(line, "!Type:Invst", 11))			importing = false;			else if(CompareStrings(line, "!Account", 8))			importing = false;			else if(CompareStrings(line, "!Type:Cat", 9))			importing = false;			else if(CompareStrings(line, "!Type:Class", 11))			importing = false;			else if(CompareStrings(line, "!Type:Memorized", 15))			importing = false;#endif						//Get next line			line = GetNextLine(line, end);			if(line == NULL)			break;		}				//Get line length		lineLength = GetLineLength(line, end);				//Analyze data line		if(importing)		switch(*line) {						case 'D': //Date			if(lineLength == 1)			break;			Text2Date(line + 1, lineLength - 1, prefs->data->importQIF_monthBefore, &operation.date);			break;						case 'P': //Payee			if(lineLength == 1)			break;			if(prefs->data->importQIF_mode == kImportMode_PayeeIsDescription) {				for(i = 1; i < lineLength; ++i)				if(operation.description[0] < 63)				operation.description[++operation.description[0]] = line[i];			}			else if(prefs->data->importQIF_mode == kImportMode_MemoIsDescription) {				for(i = 1; i < lineLength; ++i)				if(operation.note[0] < 255)				operation.note[++operation.note[0]] = line[i];			}			else if(prefs->data->importQIF_mode == kImportMode_PayeeMemoIsDescription) {				if(operation.description[0] && (operation.description[operation.description[0]] != ' ')) {					if(operation.description[0] < 63)					operation.description[++operation.description[0]] = ' ';				}				for(i = 1; i < lineLength; ++i)				if(operation.description[0] < 63)				operation.description[++operation.description[0]] = line[i];			}			break;						case 'M': //Memo			if(lineLength == 1)			break;			if(prefs->data->importQIF_mode == kImportMode_PayeeIsDescription) {				for(i = 1; i < lineLength; ++i)				if(operation.note[0] < 255)				operation.note[++operation.note[0]] = line[i];			}			else if(prefs->data->importQIF_mode == kImportMode_MemoIsDescription) {				for(i = 1; i < lineLength; ++i)				if(operation.description[0] < 63)				operation.description[++operation.description[0]] = line[i];			}			else if(prefs->data->importQIF_mode == kImportMode_PayeeMemoIsDescription) {				if(operation.description[0] && (operation.description[operation.description[0]] != ' ')) {					if(operation.description[0] < 63)					operation.description[++operation.description[0]] = ' ';				}				for(i = 1; i < lineLength; ++i)				if(operation.description[0] < 63)				operation.description[++operation.description[0]] = line[i];			}			break;						case 'A': //Address (up to five lines; the sixth line is an optional message) 			if(lineLength == 1)			break;			if(operation.note[0] < 255)			operation.note[++operation.note[0]] = '\r';			for(i = 1; i < lineLength; ++i)			if(operation.note[0] < 255)			operation.note[++operation.note[0]] = line[i];			if(operation.note[0] < 255)			operation.note[++operation.note[0]] = '\r';			break;						case 'C': //Cleared status			operation.flags |= kOperationFlag_Checked;			break;						case 'N': //Num (check or reference number) 			if(lineLength == 1)			break;			for(i = 1; i < lineLength; ++i)			if(operation.customData[0] < 63)			operation.customData[++operation.customData[0]] = line[i];			break;						case 'T': //Amount			if(lineLength == 1)			break;			operation.amount = GetAmountFromText(line + 1, lineLength - 1, '.');			break;						case 'L': //Category			if(lineLength == 1)			break;			categoryName[0] = 0;			for(i = 1; i < lineLength; ++i)			if(categoryName[0] < 63)			categoryName[++categoryName[0]] = line[i];			for(i = 0; i < categoryCount; ++i)			if(FastEqualString(categoryName, categoryList[i].name, false))			operation.category = categoryList[i].id;			break;						case '^': //End of entry			//Check amount validity			if(operation.amount < 0) {				operation.amount = -operation.amount;				if(!(operation.flags & kOperationFlag_Expense))				operation.flags |= kOperationFlag_Expense;			}						//Validate operation			if(!operation.date)			operation.date = 0;			CleanDescription(operation.description);#if __CONVERT_IMPORTS_TO_LOWERCASE__			LowerCase(operation.description);			LowerCase(operation.customData);			LowerCase(operation.note);#endif			if(!operation.description[0])			XGetIndString(operation.description, kMiscStringResID, 12);						//Add operation			if(account->AddOperation(&operation)) {				if(*idCount < kMaxSelectedLines) {					idList[*idCount] = operation.id;					*idCount += 1;				}			}			else			++failure;						//Clear operation			BlockZero(&operation, sizeof(Operation));			break;					}				//Get next line		line = GetNextLine(line, end);		if(line == NULL)		break;	}		return failure;}OSErr Application::ImportOperations(){	Boolean				isQIFFile = false;	long				idCount;	ID					idList[kMaxSelectedLines];	AccountPtr			account;	OSErr				theError;	NavigationParams	params;	Str255				text;	long				size;	short				fileID;	Ptr					data;		//Find target	if(!TargetNumIsAccount(windowServer->GetTargetNum()))	return paramErr;	account = accountList[TargetNumToAccountNum(windowServer->GetTargetNum())];		//Ask user for a file	BlockMove(kApplication_PName, params.applicationName, sizeof(Str63));	params.applicationCreator = kApplication_Creator;	params.eventCallback = NavDialogHandler;	params.callbackRefcon = NULL;	params.displayPreview = false;	params.numTypes = 0;	params.filterCallback = NULL;	XGetIndString(text, kMiscStringResID, 24);	theError = NavigationGetFile(&params, text);	if(theError)	return theError;		//Preload file	theError = FSpOpenDF(&params.outFile, fsRdPerm, &fileID);	if(theError)	return theError;	theError = GetEOF(fileID, &size);	if(theError == noErr) {		SetFPos(fileID, fsFromStart, 0);		data = NewPtr(size);		if(data == NULL)		theError = MemError();		else {			theError = FSRead(fileID, &size, data);			if(theError)			DisposePtr(data);		}	}	FSClose(fileID);	if(theError)	return theError;		//Find text format	if((*data == '!') || StringInString(params.outFile.name, "\p.qif"))	isQIFFile = true;		//Import text data	if(isQIFFile)	size = _ImportQIF(account, data, size, &idCount, idList);	else	size = _ImportTabulatedText(account, data, size, &idCount, idList);		//Clean up	DisposePtr(data);		//Did user cancel?	if(size < 0)	return noErr;		//Update	if(idCount) {		//Notify window server		windowServer->Invalidate(kUndefinedID, idCount, idList);				//Save to disk		if(prefs->data->flags & kPreferencesFlag_AutoSave)		WriteAccountToDisk(account);				//Warn user if any error happened during import		if(size) {			if(isQIFFile)			errorManager->StandardError(52, (void*) size);			else			errorManager->StandardError(51, (void*) size);		}	}	else	errorManager->StandardError(32);		return noErr;}#if !__BASIC__Boolean Application::EditMultipleOperations(OperationSelectionPtr selection){	MacroPtr				macros = appPrefs->macros->list;	unsigned long			editFlags = 0;	GrafPtr					savePort;	DialogPtr				theDialog;	short					itemHit;	ControlHandle			items[20];	long					i;	Str255					text;	OperationPtr			operation;	Date					date;	Amount					amount;	Str63					description;	ID						category,							paymentType;	unsigned long			setFlags,							clearFlags;	Str255					note;	Str63					customData;	CurrencyFactor			factor;	short					value;		//Update menus	CategoriesMenu_Update(true);	PaymentTypesMenu_Update(true);	MacroMenu_Update();		//Display dialog	GetPort(&savePort);	theDialog = GetNewDialog(kMultipleOperationEditDialogID, nil, (WindowPtr) -1);	SetPortDialogPort(theDialog);	NormalizeThemeDrawingState();		//Get items	for(i = 0; i < 20; ++i)	GetDialogItemAsControl(theDialog, 3 + i, &items[i]);		//Set items	HiliteControl(items[1], 255);	GetDateTime(&date);	SetClockDateTime(items[3], date);	HiliteControl(items[3], 255);	HiliteControl(items[5], 255);	if(!prefs->data->payments->count)	HiliteControl(items[6], 255);	HiliteControl(items[7], 255);	HiliteControl(items[9], 255);	if(!prefs->data->categories->count)	HiliteControl(items[10], 255);	HiliteControl(items[11], 255);	SetControlMaximum(items[12], 2);	SetControlValue(items[12], 2);	HiliteControl(items[12], 255);	SetControlMaximum(items[13], 2);	SetControlValue(items[13], 2);	HiliteControl(items[13], 255);	SetControlMaximum(items[14], 2);	SetControlValue(items[14], 2);	HiliteControl(items[14], 255);	HiliteControl(items[16], 255);	HiliteControl(items[19], 255);		SelectDialogItemText(theDialog, 3, 0, 32000);	SetDialogDefaultItem(theDialog, 1);	SetDialogCancelItem(theDialog, 2);		//Run	do {		//Get dialog events		ModalDialog(ModalDialogRoutine, &itemHit);				switch(itemHit) {						case 4:			GetDialogItemText((Handle) items[1], text);			if(dialogCharReceived && text[0]) {				i = AutoCompleteDescription(text);				if(i != kUndefinedNum) {					SetDialogItemText((Handle) items[1], text);					SelectDialogItemText(theDialog, 4, i, 32000);				}			}			break;						case 6:			GetClockDateTime(items[3], &date);			break;						case 3:			case 5:			case 7:			case 9:			case 11:			case 13:			case 21:			if(GetControlValue(items[itemHit - 3])) {				SetControlValue(items[itemHit - 3], 0);				HiliteControl(items[itemHit - 2], 255);			}			else {				SetControlValue(items[itemHit - 3], 1);				HiliteControl(items[itemHit - 2], 0);				if((itemHit == 3) || (itemHit == 7) || (itemHit == 11))				SelectDialogItemText(theDialog, itemHit + 1, 0, 32000);			}			break;						case 15:			case 16:			case 17:			SetControlValue(items[itemHit - 3], (GetControlValue(items[itemHit - 3]) + 1) % 3);			break;						case 18:			if(GetControlValue(items[15])) {				SetControlValue(items[15], 0);				HiliteControl(items[12], 255);				HiliteControl(items[13], 255);				HiliteControl(items[14], 255);			}			else {				SetControlValue(items[15], 1);				HiliteControl(items[12], 0);				HiliteControl(items[13], 0);				HiliteControl(items[14], 0);			}			break;						case 20:			if(GetControlValue(items[17])) {				SetControlValue(items[17], 0);				HiliteControl(items[16], 255);			}			else {				SetControlValue(items[17], 1);				HiliteControl(items[16], 0);				SelectDialogItemText(theDialog, 19, 0, 32000);			}			break;					}	} while((itemHit != 1) && (itemHit != 2));		//Get data	if(itemHit == 1) {		if(GetControlValue(items[0])) {			editFlags |= kEditFlag_Description;			XGetDialogItemText(items[1], description, kStr63MaxLength);		}		if(GetControlValue(items[2])) {			editFlags |= kEditFlag_Date;			//GetClockDateTime(items[3], &date);		}		if(GetControlValue(items[4])) {			editFlags |= kEditFlag_Amount;			XGetDialogItemAmount(items[5], &amount);		}		if(GetControlValue(items[6])) {			editFlags |= kEditFlag_PaymentType;			paymentType = PaymentTypesMenu_GetChoice(GetControlValue(items[7]));		}		if(GetControlValue(items[8])) {			editFlags |= kEditFlag_Custom;			XGetDialogItemText(items[9], customData, kStr63MaxLength);		}		if(GetControlValue(items[10])) {			editFlags |= kEditFlag_Category;			category = CategoriesMenu_GetChoice(GetControlValue(items[11]));		}		if(GetControlValue(items[15])) {			editFlags |= kEditFlag_Flags;			setFlags = 0;			clearFlags = 0;						if(GetControlValue(items[12]) == 1)			setFlags |= kOperationFlag_Expense;			else if(GetControlValue(items[12]) == 0)			clearFlags |= kOperationFlag_Expense;						if(GetControlValue(items[13]) == 1)			setFlags |= kOperationFlag_Checked;			else if(GetControlValue(items[13]) == 0)			clearFlags |= kOperationFlag_Checked;						if(GetControlValue(items[14]) == 1)			setFlags |= kOperationFlag_Warning;			else if(GetControlValue(items[14]) == 0)			clearFlags |= kOperationFlag_Warning;		}		if(GetControlValue(items[17])) {			editFlags |= kEditFlag_Note;			XGetDialogItemText(items[16], note, kStr255MaxLength);		}		if(GetControlValue(items[18]) && appPrefs->macros->count) {			editFlags |= kEditFlag_Conversion;			GetBevelButtonMenuValue(items[19], &value);			factor = appPrefs->macros->list[value - 1].factor;		}	}		DisposeDialog(theDialog);	SetPort(savePort);		if((itemHit == 2) || !editFlags)	return false;		//Modify operations	for(i = 0; i < selection->count; ++i) {		operation = selection->operation[i];				if(editFlags & kEditFlag_Description)		BlockMove(description, operation->description, sizeof(Str63));		if(editFlags & kEditFlag_Date)		operation->date = date;		if(editFlags & kEditFlag_Amount)		operation->amount = amount;		if(editFlags & kEditFlag_Conversion)		operation->amount = AmountByCurrencyFactor(operation->amount, factor);		if(editFlags & kEditFlag_PaymentType)		operation->paymentType = paymentType;		if(editFlags & kEditFlag_Custom)		BlockMove(customData, operation->customData, sizeof(Str63));		if(editFlags & kEditFlag_Category)		operation->category = category;		if(editFlags & kEditFlag_Flags) {			operation->flags |= setFlags;			operation->flags &= ~clearFlags;		}		if(editFlags & kEditFlag_Note)		BlockMove(note, operation->note, sizeof(Str255));				GetDateTime(&operation->lastEditDate);		if(editFlags & kEditFlag_Date)		operation->owner->data->operationListSorted = false;	}		return true;}#endiflong Application::AutoCompleteDescription(Str63 text){	OperationPtr		operation = windowServer->GetOperationCacheList();	Str63				result = "\p";	long				num = kUndefinedNum;	unsigned char		oldLength;#if !__AUTOCOMPLETE_ALPHABETICAL__	ID					lastID;#endif		if(!text[0] || !operation)	return kUndefinedNum;		do {		if(operation->description[0] > text[0]) {			if(FastEqualText(text[0], &text[1], &operation->description[1], false)) {#if __AUTOCOMPLETE_ALPHABETICAL__				if(!result[0] || (FastCompareString(operation->description, result, NULL) == -1))				BlockMove(operation->description, result, sizeof(Str63));#else				if(!result[0] || (operation->id > lastID)) {					BlockMove(operation->description, result, sizeof(Str63));					lastID = operation->id;				}#endif			}		}		operation = operation->next;	} while(operation);	if(!result[0])	return kUndefinedNum;		oldLength = text[0];	BlockMove(&result[text[0] + 1], &text[text[0] + 1], result[0] - text[0]);	text[0] = result[0];		return oldLength;}void Application::Idle(){	Date				newDate;#if !__BASIC__	long				i;#endif		//Check if we have changed day	GetDateTime(&newDate);	if(DateToDay(newDate) != today) {		today = DateToDay(newDate);#if !__BASIC__		for(i = 0; i < accountCount; ++i)		accountList[i]->ExecuteAutomatics();#endif	}		//Give time to Window Server	windowServer->Idle();}#if __CARBON_EVENTS__static pascal OSStatus ApplicationEventHandlerBridge(EventHandlerCallRef myHandler, EventRef event, void* userData){	return application->CarbonApplicationEventHandler(event);}static pascal OSStatus WindowEventHandlerBridge(EventHandlerCallRef myHandler, EventRef event, void* userData){	return application->CarbonWindowEventHandler(event);}static pascal void WindowServerEventLoopTimer(EventLoopTimerRef inTimer, void* inUserData){	application->Idle();}#endifpascal Boolean ModalDialogHandler(DialogPtr theDialog, EventRecord* theEvent, short* itemHit){	unsigned char			theKey;	lastModalDialogEvent = *theEvent;#if !__CARBON_EVENTS__	if((theEvent->what == activateEvt) && ((WindowPtr) theEvent->message == application->windowServer->window)) {		if(theEvent->modifiers & activeFlag)		application->windowServer->Resume();		else		application->windowServer->Suspend();				*itemHit = 0;		return true;	}		if((theEvent->what == updateEvt) && ((WindowPtr) theEvent->message == application->windowServer->window)) {		application->commandServer->Execute(kCommand_UpdateServerWindow);		*itemHit = 0;		return true;	}#endif		if((theEvent->what == keyDown) || (theEvent->what == autoKey)) {		theKey = (theEvent->message & keyCodeMask) >> 8;		if((theKey == keyBackSpace) || (theKey == keyDelete) || (theKey == keyArrowLeft)			 || (theKey == keyArrowRight) || (theKey == keyArrowUp) || (theKey == keyArrowDown)			 || (theEvent->modifiers & cmdKey))		dialogCharReceived = false;		else		dialogCharReceived = true;		if((theKey == keyReturn) && (theEvent->modifiers & shiftKey)) {			*itemHit = 0;			return false;		}	}	else	dialogCharReceived = false;		return StdFilterProc(theDialog, theEvent, itemHit);}void main(){	Operation			theOperation;	long				i;#if __CARBON_EVENTS__	OSErr				theError;	EventTypeSpec		list[] = { {kEventClassCommand, kEventCommandProcess},									{kEventClassApplication, kEventAppActivated},									{kEventClassApplication, kEventAppDeactivated},									{kEventClassKeyboard, kEventRawKeyDown},									{kEventClassKeyboard, kEventRawKeyRepeat},									{kEventClassWindow, kEventWindowUpdate},									{kEventClassMouse, kEventMouseWheelMoved} };	EventTypeSpec		list2[] = { {kEventClassMouse, kEventMouseDown},									{kEventClassWindow, kEventWindowActivated},									{kEventClassWindow, kEventWindowDeactivated} };#endif#if !__BASIC__	KeyMap				keyMap;#endif		//Create application	application = new Application;	//Convert initial balance into an operation if any	for(i = 0; i < application->accountCount; ++i)	if(application->accountList[i]->data->unusedStartBalance) {		BlockZero(&theOperation, sizeof(Operation));		XGetIndString(theOperation.description, kMiscStringResID, 25);		theOperation.amount = application->accountList[i]->data->unusedStartBalance;		if(application->accountList[i]->AddOperation(&theOperation))		application->accountList[i]->data->unusedStartBalance = 0;	}	#if !__BASIC__	//Execute automatic operations	GetKeys(keyMap);	if(!IsKeyDown(keyMap, keyShift)) {		for(i = 0; i < application->accountCount; ++i)		application->accountList[i]->ExecuteAutomatics();	}#endif		//Show window	application->windowServer->ShowServerWindow();		//Reset Window Server	application->windowServer->Invalidate();		//Install handlers#if __CARBON_EVENTS__	theError = InstallApplicationEventHandler(NewEventHandlerUPP(ApplicationEventHandlerBridge), GetEventTypeCount(list), list, NULL, NULL);	if(theError)	application->errorManager->FatalError(33, (void*) theError);	theError = InstallWindowEventHandler(application->windowServer->window, NewEventHandlerUPP(WindowEventHandlerBridge), GetEventTypeCount(list2), list2, NULL, NULL);	if(theError)	application->errorManager->FatalError(33, (void*) theError);	theError = InstallEventLoopTimer(GetCurrentEventLoop(), 0, 1.0 / kCarbonIdleFPS * kEventDurationSecond, NewEventLoopTimerUPP(WindowServerEventLoopTimer), NULL, &application->timerRef);	if(theError)	application->errorManager->FatalError(33, (void*) theError);#endif	ModalDialogRoutine = NewModalFilterUPP(ModalDialogHandler);	//Enter event loop#if __CARBON_EVENTS__	RunApplicationEventLoop();#else	application->ClassicEventLoop();#endif		//Clean up	delete application;	ExitToShell();}