/***************************************************************************** * Copyright (c) 1999-2002, Pierre-Olivier Latour * http://www.pol-online.net * info@pol-online.net * * This program is free software; you can redistribute it and/or modify * it under the terms of the GNU General Public License as published by * the Free Software Foundation; either version 2 of the License, or * (at your option) any later version. *  * This program is distributed in the hope that it will be useful, * but WITHOUT ANY WARRANTY; without even the implied warranty of * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the * GNU General Public License for more details. * * You should have received a copy of the GNU General Public License * along with this program; if not, write to the Free Software * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111, USA. *****************************************************************************/#include			"Window Server.h"#include			"Filter.h"#include			"Utils.h"#include			"Command Server.h"#include			"Keys.h"#if !__DEMO__ && !__DEBUG__#include			"Serial Number.h"#endif//PREPROCESSOR CONSTANTES:#define	__CONDENSED_TEXT__	1#define	__DELAY_FILTER_VALIDATION__	1//CONSTANTES:#define				kSkinDefinitionResType		'skdf'#define				kSkinImageResType			'skim'#define				kSkinListResType			'skls'#define				kSkinFontResType			'skft'#define				kSkinScrollBarResType		'sksb'#define				kPICTResType				'PICT'#define				kCLUTResType				'clut'#define				kGrayCLUTResID				128#define				kDefinition_Version			0x0100#define				kWindow_Version				0x0100#define				kColorBitDepth				32#define				kGrayBitDepth				8#define				kMouseSeparatorTolerance	5#define				kMinColumnSizeTolerance		4#define				kDragDelay					60#define				kNoteTagDelay				60#define				kLineMoveDelay				2#define				kScrollDelay				2#define				kScrollDelay2				10#define				kDoubleClickTolerance		3#define				kSortingWatchThreshold		1024#define				kKeySelectionMaxDelay		30enum {	kWindowClick_NoWhere = 0,	kWindowClick_InDrag,	kWindowClick_InCloseBox,	kWindowClick_InZoomBox,	kWindowClick_InGrowBox,	kWindowClick_InMagicButton,	kWindowClick_InFilter,	kWindowClick_InAccountList,	kWindowClick_InOperationList,	kWindowClick_InOperationScrollBar,	kWindowClick_InAccountScrollBar,	kWindowClick_InDisplay};enum {	kScrollBarClick_NoWhere = 0,	kScrollBarClick_InUpArrow,	kScrollBarClick_InDownArrow,	kScrollBarClick_InThumb,	kScrollBarClick_InUp,	kScrollBarClick_InDown};enum {	kListClick_NoWhere = 0,	kListClick_OnCell,	kListClick_OnHeader,	kListClick_OnHeaderSeparator,	kListClick_OnSortingIcon};enum {	kMagicButtonMode_NewAccount = 0,	kMagicButtonMode_NewOperation,	kMagicButtonMode_Print};enum {	kScrollBarMode_Inactive = 0,	kScrollBarMode_Off,	kScrollBarMode_Disabled,	kScrollBarMode_ArrowUp,	kScrollBarMode_ArrowDown,	kScrollBarMode_Thumb};//MACROS:#if TARGET_API_MAC_CARBON#define	BMPtrFromGWorld(w) GetPortBitMapForCopyBits(w)#define	BMPtrFromWindow(w) GetPortBitMapForCopyBits(GetWindowPort(w))#else#define	BMPtrFromGWorld(w) &(((GrafPtr)(w))->portBits)#define	BMPtrFromWindow(w) &(((GrafPtr)(w))->portBits)#endif#define FontIndexToPtr(n) (&(**_fonts).fonts[(n) - 1])//NOTES:/**** Must be called in Window port_CreateFilterTE_DrawFilterTE_SetFocus_TrackButtonClick_TrackListIconClick_TrackListHeaderClick_ResizeColumn_TrackListScrollBarClickWaitMouseForDrag*** Must be called in _windowBuffer port_FillPattern_DrawSkinImage_DrawText_SetDisplayText_DrawColumn_DrawList_DrawListLines_DrawNoteTag_DrawListScrollBar_DrawScrollBarBody_DrawDisplay*///ROUTINES:inline void XSetFont(FontDefinitionPtr font){	TextFont(font->cacheFontNum);	TextSize(font->size);	TextFace(font->style);}inline long GetAccountNumFromID(ID id){	long			i;		for(i = 0; i < application->accountCount; ++i)	if(application->accountList[i]->data->id == id)	return i;		return kUndefinedNum;}inline long GetFilterNumFromID(ID id){	long			i;		for(i = 0; i < application->filterCount; ++i)	if(application->filterList[i]->data->id == id)	return i;		return kUndefinedNum;}inline void RGBForeColor_Hidden(RGBColor* c, RGBColor* h){	RGBColor	n;	float		r = (float) h->red / 65535.0,				g = (float) h->green / 65535.0,				b = (float) h->blue / 65535.0;		n.red = 65535.0 * (r + (float) c->red / 65535.0 * (1.0 - r));	n.green = 65535.0 * (g + (float) c->green / 65535.0 * (1.0 - g));	n.blue = 65535.0 * (b + (float) c->blue / 65535.0 * (1.0 - b));	RGBForeColor(&n);}static OSErr NewGWorldFromPicture(short resID, short bitDepth, GWorldPtr* world, Rect* worldRect){	GWorldPtr			oldGWorld;	GDHandle			oldGDHandle;	PicHandle			thePic;	Rect				bounds;	OSErr				theError;	GWorldPtr			theGWorld = NULL;	CTabHandle			theCLUT = NULL;		thePic = (PicHandle) Get1Resource(kPICTResType, resID);	if(thePic == nil)	return ResError();		if(bitDepth == kGrayBitDepth) {		theCLUT = (CTabHandle) Get1Resource(kCLUTResType, kGrayCLUTResID);		if(theCLUT == nil) {			ReleaseResource((Handle) thePic);			return ResError();		}	}		GetGWorld(&oldGWorld, &oldGDHandle);	bounds = (**thePic).picFrame;	OffsetRect(&bounds, -bounds.left, -bounds.top);	theError = NewGWorld(&theGWorld, bitDepth, &bounds, theCLUT, nil, 0L);	if(theError == noErr) {		NoPurgePixels(GetGWorldPixMap(theGWorld));		LockPixels(GetGWorldPixMap(theGWorld));		SetGWorld(theGWorld, nil);		BackColor(whiteColor);		ForeColor(blackColor);		DrawPicture(thePic, &bounds);				SetGWorld(oldGWorld, oldGDHandle);		ReleaseResource((Handle) thePic);		if(theCLUT)		ReleaseResource((Handle) theCLUT);		*world = theGWorld;		if(worldRect)		*worldRect = bounds;	}		return theError;}static short GetColumnRelativePosition(ListInfoPtr list, ID column){	long				i;	short				position = 0;		for(i = 0; i < list->columnCount; ++i) {		if(list->columnList[i].id == column)		return position;		if(list->columnList[i].flags & kColumnFlag_Displayed)		position += list->columnList[i].width;	}		return kUndefinedNum;}static void GetColumnBounds(ListInfoPtr list, ID column, Rect* bounds){	long				i;		bounds->top = list->bounds.top;	bounds->bottom = list->bounds.bottom;	bounds->left = list->bounds.left;	for(i = 0; i < list->columnCount; ++i) {		bounds->right = bounds->left + list->columnList[i].width;		if(list->columnList[i].id == column)		return;		if(list->columnList[i].flags & kColumnFlag_Displayed)		bounds->left = bounds->right;	}}static ColumnInfoPtr GetColumnInfoFromID(ListInfoPtr list, ID column){	long				i;		for(i = 0; i < list->columnCount; ++i) {		if(list->columnList[i].id == column)		return &list->columnList[i];	}		return NULL;}static Boolean LineIsSelected(long num, ListInfoPtr list){	long				i;		for(i = 0; i < list->numSelectedLines; ++i)	if(list->selectedNumList[i] == num)	return true;		return false;}static long GetSelectionMin(ListInfoPtr list){	long					min = 0x0FFFFFFF,							i;		for(i = 0; i < list->numSelectedLines; ++i) {		if(list->selectedNumList[i] < min)		min = list->selectedNumList[i];	}		return min;}static long GetSelectionMax(ListInfoPtr list){	long					max = 0,							i;		for(i = 0; i < list->numSelectedLines; ++i) {		if(list->selectedNumList[i] > max)		max = list->selectedNumList[i];	}		return max;}inline Boolean PointInPointRect(Point p, Point c, short s){	if(p.h < c.h - s)	return false;	if(p.h > c.h + s)	return false;	if(p.v < c.v - s)	return false;	if(p.v > c.v + s)	return false;		return true;}Boolean WindowServer::_CreateFilterTE(){	Rect				temp;	FontDefinitionPtr	font = FontIndexToPtr((**_skinDef).filterFontIndex);		//Set font	TextFont(font->cacheFontNum);	TextSize(font->size);	TextFace(font->style);		//Create TE	_GetSkinImageRect(kSkinImage_Filter, &temp);	_filterTERect = (**_skinDef).filterArea;	OffsetRect(&_filterTERect, temp.left, temp.top);	_filterTE = TENew(&_filterTERect, &_filterTERect);	if(_filterTE == NULL)	return false;		//Set TE	switch((**_skinDef).filterTextAlignement) {		case kTextAlign_Left: TESetAlignment(teFlushLeft, _filterTE); break;		case kTextAlign_Middle: TESetAlignment(teCenter, _filterTE); break;		case kTextAlign_Right: TESetAlignment(teFlushRight, _filterTE); break;	}	if(userFocus == kFocus_Filter)	TEActivate(_filterTE);		return true;}WindowServer::WindowServer(PreferencesDataPtr prefs, OSErr* theError){	long				i;	GWorldPtr			oldGWorld;	GDHandle			oldGDHandle;	GrafPtr				savePort;	Rect				bounds;		//Save port	GetPort(&savePort);		//Set prefs	_appPrefs = prefs;		//Get skin definition	_skinDef = (SkinDefinitionHandle) Get1Resource(kSkinDefinitionResType, _appPrefs->skinResID);	if(_skinDef == NULL) {		*theError = ResError();		return;	}	DetachResource((Handle) _skinDef);	HLock((Handle) _skinDef);		//Check window size	if(_appPrefs->windowContent.right < (**_skinDef).windowMinWidth)	_appPrefs->windowContent.right = (**_skinDef).windowMinWidth;	if(_appPrefs->windowContent.bottom < (**_skinDef).windowMinHeight)	_appPrefs->windowContent.bottom = (**_skinDef).windowMinHeight;		//Compute window bounds	bounds = _appPrefs->windowContent;	OffsetRect(&bounds, _appPrefs->windowPosition.h, _appPrefs->windowPosition.v);		//Make sure window is on screen	if(!RectInRgn(&bounds, GetGrayRgn())) {		GetWindowDefaultBounds(&_appPrefs->windowPosition, &_appPrefs->windowContent);		bounds = _appPrefs->windowContent;		OffsetRect(&bounds, _appPrefs->windowPosition.h, _appPrefs->windowPosition.v);	}		//Create window#if TARGET_API_MAC_CARBON	*theError = CreateNewWindow(kPlainWindowClass, kWindowNoAttributes, &bounds, &window);	if(*theError)	return;#else	window = NewCWindow(nil, &bounds, "\p", false, kWindowPlainDialogProc, (WindowPtr) -1, false, NULL);	if(window == NULL) {		*theError = -1;		return;	}#endif	SetPortWindowPort(window);	BackColor(whiteColor);	ForeColor(blackColor);		//Set data	_windowZoomed = false;		//Create buffer	GetGWorld(&oldGWorld, &oldGDHandle);	_windowBuffer = NULL;	*theError = NewGWorld(&_windowBuffer, kColorBitDepth, &_appPrefs->windowContent, NULL, NULL, useTempMem);	if(*theError)	return;	NoPurgePixels(GetGWorldPixMap(_windowBuffer));	LockPixels(GetGWorldPixMap(_windowBuffer));	SetGWorld(_windowBuffer, nil);	BackColor(whiteColor);	ForeColor(blackColor);	EraseRect(&_appPrefs->windowContent);	SetGWorld(oldGWorld, oldGDHandle);		//Process skin definition	*theError = NewGWorldFromPicture((**_skinDef).skinPatternResID, kColorBitDepth, &_windowPattern, &_patternRect);	if(*theError)	return;	*theError = NewGWorldFromPicture((**_skinDef).skinImageResID, kColorBitDepth, &_windowImage, NULL);	if(*theError)	return;	*theError = NewGWorldFromPicture((**_skinDef).skinAlphaResID, kGrayBitDepth, &_windowAlpha, NULL);	if(*theError)	return;		//Get skin images definition	_images = (SkinImagesHandle) Get1Resource(kSkinImageResType, (**_skinDef).infoImageResID);	if(_images == NULL) {		*theError = ResError();		return;	}	DetachResource((Handle) _images);	HLock((Handle) _images);		//Get skin fonts definition	_fonts = (SkinFontsHandle) Get1Resource(kSkinFontResType, (**_skinDef).infoFontResID);	if(_fonts == NULL) {		*theError = ResError();		return;	}	DetachResource((Handle) _fonts);	HLock((Handle) _fonts);		//Cache font nums	for(i = 0; i < (**_fonts).numFonts; ++i)	GetFNum((**_fonts).fonts[i].name, &(**_fonts).fonts[i].cacheFontNum);		//Get skin lists definition	_lists = (SkinListsHandle) Get1Resource(kSkinListResType, (**_skinDef).infoListResID);	if(_lists == NULL) {		*theError = ResError();		return;	}	DetachResource((Handle) _lists);	HLock((Handle) _lists);		//Get skin scrollbar definition	_scrollBar = (SkinScrollBarHandle) Get1Resource(kSkinScrollBarResType, (**_skinDef).infoScrollBarResID);	if(_scrollBar == NULL) {		*theError = ResError();		return;	}	DetachResource((Handle) _scrollBar);	HLock((Handle) _scrollBar);		//Set data	_saveClip = NewRgn();	_saveClipPattern = NewRgn();	userFocus = kFocus_None;	_suspended = false;	_operationListCache = NULL;	_operationListCacheSize = 0;	_lastClickTime = 0;	_lastClickWhere.h = 0;	_lastClickWhere.v = 0;#if TARGET_API_MAC_CARBON	_mouseDown = false;#endif	_noteTagOperation = NULL;	_noteTagEnterTime = 0;	_lastLineMoveTime = 0;	_lastKeyTime = 0;	_keyString[0] = 0;		_listInfo[kList_Accounts].num = kList_Accounts;	_listInfo[kList_Accounts].definition = &(**_lists).lists[kList_Accounts];	_listInfo[kList_Accounts].columnCount = kAccountNumColumns;	_listInfo[kList_Accounts].columnList = _appPrefs->accountsColumns;	_listInfo[kList_Accounts].selectedColumn = NULL;	_GetListBounds(kList_Accounts, &_listInfo[kList_Accounts].bounds);	_listInfo[kList_Accounts].numLines = 0;	_listInfo[kList_Accounts].numVisibleLines = 0;	_listInfo[kList_Accounts].firstLine = 0;	_listInfo[kList_Accounts].numSelectedLines = 0;	_listInfo[kList_Accounts].maxSelectedLines = 1;	_listInfo[kList_Accounts].hasScrollbar = false;	_listInfo[kList_Accounts].active = false;		_listInfo[kList_Operations].num = kList_Operations;	_listInfo[kList_Operations].definition = &(**_lists).lists[kList_Operations];	_listInfo[kList_Operations].columnCount = kOperationNumColumns;	_listInfo[kList_Operations].columnList = _appPrefs->operationsColumns;	_listInfo[kList_Operations].selectedColumn = &_appPrefs->windowSortingColumn;	_GetListBounds(kList_Operations, &_listInfo[kList_Operations].bounds);	_listInfo[kList_Operations].numLines = 0;	_listInfo[kList_Operations].numVisibleLines = 0;	_listInfo[kList_Operations].firstLine = 0;	_listInfo[kList_Operations].numSelectedLines = 0;	_listInfo[kList_Operations].maxSelectedLines = kMaxSelectedLines;	_listInfo[kList_Operations].hasScrollbar = false;	_listInfo[kList_Operations].active = false;		//Set cursor	_currentCursor = kThemeArrowCursor;	SetThemeCursor(_currentCursor);		//Create filter TE	SetPortWindowPort(window);	if(!_CreateFilterTE()) {		*theError = -1;		return;	}		//Set focus	_SetFocus(kFocus_AccountList, false);		//Restore port	SetPort(savePort);		//Clear error code	*theError = noErr;}WindowServer::~WindowServer(){	//Release memory	if(_skinDef)	DisposeHandle((Handle) _skinDef);	if(_images)	DisposeHandle((Handle) _images);	if(_fonts)	DisposeHandle((Handle) _fonts);	if(_lists)	DisposeHandle((Handle) _lists);	if(_scrollBar)	DisposeHandle((Handle) _scrollBar);	if(_windowPattern) {		UnlockPixels(GetGWorldPixMap(_windowPattern));		DisposeGWorld(_windowPattern);	}	if(_windowImage) {		UnlockPixels(GetGWorldPixMap(_windowImage));		DisposeGWorld(_windowImage);	}	if(_windowAlpha) {		UnlockPixels(GetGWorldPixMap(_windowAlpha));		DisposeGWorld(_windowAlpha);	}	if(_saveClip)	DisposeRgn(_saveClip);	if(_saveClipPattern)	DisposeRgn(_saveClipPattern);	if(_filterTE)	TEDispose(_filterTE);	if(window)#if TARGET_API_MAC_CARBON	ReleaseWindow(window);#else	DisposeWindow(window);#endif	if(_windowBuffer) {		UnlockPixels(GetGWorldPixMap(_windowBuffer));		DisposeGWorld(_windowBuffer);	}	SetThemeCursor(kThemeArrowCursor);}void WindowServer::ShowServerWindow(){	ShowWindow(window);}void WindowServer::HideServerWindow(){	HideWindow(window);}void WindowServer::_FillPattern(Rect* destRect, Boolean noClipping){	Rect				copyRect;		if(!noClipping) {		GetClip(_saveClipPattern);		ClipRect(destRect);	}		copyRect.top = 0;	copyRect.bottom = _patternRect.bottom;	while(copyRect.bottom < destRect->bottom + _patternRect.bottom) {		copyRect.left = 0;		copyRect.right = _patternRect.right;		while(copyRect.right < destRect->right + _patternRect.right) {			CopyBits(BMPtrFromGWorld(_windowPattern), BMPtrFromGWorld(_windowBuffer), &_patternRect, &copyRect, srcCopy, NULL);			copyRect.left += _patternRect.right;			copyRect.right += _patternRect.right;		}		copyRect.top += _patternRect.bottom;		copyRect.bottom += _patternRect.bottom;	}		if(!noClipping)	SetClip(_saveClipPattern);}void WindowServer::_GetSkinImageRect(long num, Rect* theRect){	ImageDefinitionPtr	data = &(**_images).images[num];		if(data->flags & kPositionFlag_TopLeftRelative) {		theRect->left = data->dest.h;		theRect->top = data->dest.v;	}	else if(data->flags & kPositionFlag_TopRightRelative) {		theRect->left = _appPrefs->windowContent.right + data->dest.h;		theRect->top = data->dest.v;	}	else if(data->flags & kPositionFlag_BottomLeftRelative) {		theRect->left = data->dest.h;		theRect->top = _appPrefs->windowContent.bottom + data->dest.v;	}	else if(data->flags & kPositionFlag_BottomRightRelative) {		theRect->left = _appPrefs->windowContent.right + data->dest.h;		theRect->top = _appPrefs->windowContent.bottom + data->dest.v;	}	else if(data->flags & kPositionFlag_TopMiddleRelative) {		theRect->left = _appPrefs->windowContent.right / 2 + data->dest.h;		theRect->top = data->dest.v;	}	theRect->right = theRect->left + data->size.h;	theRect->bottom = theRect->top + data->size.v;}void WindowServer::_DrawSkinImage(long num, Boolean eraseBackground, short destH, short destV){	ImageDefinitionPtr	data = &(**_images).images[num];	Rect				sourceRect,						copyRect;		sourceRect.left = data->source.h;	sourceRect.top = data->source.v;	sourceRect.right = sourceRect.left + data->size.h;	sourceRect.bottom = sourceRect.top + data->size.v;	if((destH != kUndefinedNum) && (destV != kUndefinedNum)) {		copyRect.left = destH + data->dest.h;		copyRect.top = destV + data->dest.v;		copyRect.right = copyRect.left + data->size.h;		copyRect.bottom = copyRect.top + data->size.v;	}	else	_GetSkinImageRect(num, &copyRect);		if(eraseBackground && (data->flags & kImageFlag_UseAlpha))	_FillPattern(&copyRect);		if(data->flags & kImageFlag_UseAlpha)	CopyDeepMask(BMPtrFromGWorld(_windowImage), BMPtrFromGWorld(_windowAlpha), BMPtrFromGWorld(_windowBuffer), &sourceRect, &sourceRect, &copyRect, srcCopy, NULL);	else	CopyBits(BMPtrFromGWorld(_windowImage), BMPtrFromGWorld(_windowBuffer), &sourceRect, &copyRect, srcCopy, NULL);}void WindowServer::_DrawImageRepeatH(Point source, Point size, Point dest, short width, Boolean hasAlpha, Boolean eraseBackground){	Rect				sourceRect,						copyRect;		sourceRect.left = source.h;	sourceRect.top = source.v;	sourceRect.right = sourceRect.left + size.h;	sourceRect.bottom = sourceRect.top + size.v;		copyRect.left = dest.h;	copyRect.top = dest.v;	copyRect.right = copyRect.left + width;	copyRect.bottom = copyRect.top + size.v;		if(eraseBackground && hasAlpha)	_FillPattern(&copyRect);		while(copyRect.left + size.h <= dest.h + width) {		copyRect.right = copyRect.left + size.h;		if(hasAlpha)		CopyDeepMask(BMPtrFromGWorld(_windowImage), BMPtrFromGWorld(_windowAlpha), BMPtrFromGWorld(_windowBuffer), &sourceRect, &sourceRect, &copyRect, srcCopy, NULL);		else		CopyBits(BMPtrFromGWorld(_windowImage), BMPtrFromGWorld(_windowBuffer), &sourceRect, &copyRect, srcCopy, NULL);		copyRect.left = copyRect.right;	}		copyRect.right = dest.h + width;	sourceRect.right = sourceRect.left + copyRect.right - copyRect.left;	if(hasAlpha)	CopyDeepMask(BMPtrFromGWorld(_windowImage), BMPtrFromGWorld(_windowAlpha), BMPtrFromGWorld(_windowBuffer), &sourceRect, &sourceRect, &copyRect, srcCopy, NULL);	else	CopyBits(BMPtrFromGWorld(_windowImage), BMPtrFromGWorld(_windowBuffer), &sourceRect, &copyRect, srcCopy, NULL);}void WindowServer::_DrawImageRepeatV(Point source, Point size, Point dest, short height, Boolean hasAlpha, Boolean eraseBackground){	Rect				sourceRect,						copyRect;		sourceRect.left = source.h;	sourceRect.top = source.v;	sourceRect.right = sourceRect.left + size.h;	sourceRect.bottom = sourceRect.top + size.v;		copyRect.left = dest.h;	copyRect.top = dest.v;	copyRect.right = copyRect.left + size.h;	copyRect.bottom = copyRect.top + height;		if(eraseBackground && hasAlpha)	_FillPattern(&copyRect);		while(copyRect.top + size.v <= dest.v + height) {		copyRect.bottom = copyRect.top + size.v;		if(hasAlpha)		CopyDeepMask(BMPtrFromGWorld(_windowImage), BMPtrFromGWorld(_windowAlpha), BMPtrFromGWorld(_windowBuffer), &sourceRect, &sourceRect, &copyRect, srcCopy, NULL);		else		CopyBits(BMPtrFromGWorld(_windowImage), BMPtrFromGWorld(_windowBuffer), &sourceRect, &copyRect, srcCopy, NULL);		copyRect.top = copyRect.bottom;	}		copyRect.bottom = dest.v + height;	sourceRect.bottom = sourceRect.top + copyRect.bottom - copyRect.top;	if(hasAlpha)	CopyDeepMask(BMPtrFromGWorld(_windowImage), BMPtrFromGWorld(_windowAlpha), BMPtrFromGWorld(_windowBuffer), &sourceRect, &sourceRect, &copyRect, srcCopy, NULL);	else	CopyBits(BMPtrFromGWorld(_windowImage), BMPtrFromGWorld(_windowBuffer), &sourceRect, &copyRect, srcCopy, NULL);}void WindowServer::_DrawText(FontDefinitionPtr font, StringPtr text, short h, short v, short alignement){	RGBColor			saveColor;	Point				savePen;		if(alignement == kTextAlign_Middle)	h -= TextWidth(text, 1, text[0]) / 2;	else if(alignement == kTextAlign_Right)	h -= TextWidth(text, 1, text[0]);		GetForeColor(&saveColor);	if(font->flags & kFontFlag_HasShadow) {		RGBForeColor(&font->backColor);		if((h != kUndefinedNum) && (v != kUndefinedNum))		MoveTo(h + 1, v + 1);		else {			GetPen(&savePen);			Move(1, 1);		}		DrawString(text);		if((h == kUndefinedNum) || (v == kUndefinedNum))		MoveTo(savePen.h, savePen.v);	}	RGBForeColor(&font->foreColor);	if((h != kUndefinedNum) && (v != kUndefinedNum))	MoveTo(h, v);	DrawString(text);	RGBForeColor(&saveColor);}short WindowServer::_GetTitleBarMiddleWidth(){	short				titleBarWidth;	Rect				copyRect;		_GetSkinImageRect(kSkinTitleBar_Left, &copyRect);	titleBarWidth = copyRect.right;	_GetSkinImageRect(kSkinTitleBar_Right, &copyRect);	titleBarWidth = copyRect.left - titleBarWidth;		return titleBarWidth;}void WindowServer::_DrawFilterTE(){	RGBColor			saveColor;	FontDefinitionPtr	font = FontIndexToPtr((**_skinDef).filterFontIndex);		GetForeColor(&saveColor);	if(_suspended && ((**_skinDef).flags & kSkinFlag_ColorOnHide))	RGBForeColor_Hidden(&font->foreColor, &(**_skinDef).windowHideColor);	else	RGBForeColor(&font->foreColor);	TEUpdate(&_filterTERect, _filterTE);	RGBForeColor(&saveColor);}void WindowServer::_GetFilterText(StringPtr text){	if((**_filterTE).teLength)	GetDialogItemText((**_filterTE).hText, text);	else	text[0] = 0;}void WindowServer::_SetFilterText(StringPtr text){	TESetText(&text[1], text[0], _filterTE);}void WindowServer::ClearFilterText(){	TESetText(NULL, 0, _filterTE);}void WindowServer::_GetListBounds(long num, Rect* bounds){	CornerPositionPtr	data;			if(!(_appPrefs->windowFlags & kWindowFlag_AccountList) && (num == kList_Operations))	data = &(**_lists).lists[kList_Accounts].positions[kListCorner_TopLeft];	else	data = &(**_lists).lists[num].positions[kListCorner_TopLeft];		if(data->flags & kPositionFlag_TopLeftRelative) {		bounds->left = data->position.h;		bounds->top = data->position.v;	}	else if(data->flags & kPositionFlag_TopRightRelative) {		bounds->left = _appPrefs->windowContent.right + data->position.h;		bounds->top = data->position.v;	}	else if(data->flags & kPositionFlag_BottomLeftRelative) {		bounds->left = data->position.h;		bounds->top = _appPrefs->windowContent.bottom + data->position.v;	}	else if(data->flags & kPositionFlag_BottomRightRelative) {		bounds->left = _appPrefs->windowContent.right + data->position.h;		bounds->top = _appPrefs->windowContent.bottom + data->position.v;	}	else if(data->flags & kPositionFlag_TopMiddleRelative) {		bounds->left = _appPrefs->windowContent.right / 2 + data->position.h;		bounds->top = data->position.v;	}		data = &(**_lists).lists[num].positions[kListCorner_BottomRight];		if(data->flags & kPositionFlag_TopLeftRelative) {		bounds->right = data->position.h;		bounds->bottom = data->position.v;	}	else if(data->flags & kPositionFlag_TopRightRelative) {		bounds->right = _appPrefs->windowContent.right + data->position.h;		bounds->bottom = data->position.v;	}	else if(data->flags & kPositionFlag_BottomLeftRelative) {		bounds->right = data->position.h;		bounds->bottom = _appPrefs->windowContent.bottom + data->position.v;	}	else if(data->flags & kPositionFlag_BottomRightRelative) {		bounds->right = _appPrefs->windowContent.right + data->position.h;		bounds->bottom = _appPrefs->windowContent.bottom + data->position.v;	}	else if(data->flags & kPositionFlag_TopMiddleRelative) {		bounds->right = _appPrefs->windowContent.right / 2 + data->position.h;		bounds->bottom = data->position.v;	}}void WindowServer::_DrawColumnHeader(ListInfoPtr list, ID column, Point* imageBackground){	ColumnInfoPtr		info = GetColumnInfoFromID(list, column);	short				position = GetColumnRelativePosition(list, column);	short				hPos = list->bounds.left + position;	Str255				text;	RGBColor			saveColor;	Point				temp;	short				alignement,						h,						v;	FontDefinitionPtr	font;		//Save fore color	GetForeColor(&saveColor);		//Draw header background if needed	if(imageBackground) {		temp.h = hPos;		temp.v = list->bounds.top;		if(position)		++temp.h;		_DrawImageRepeatH(*imageBackground, list->definition->headerImageSize, temp, info->width, list->definition->flags & kListFlag_HeaderUseAlpha, false);	}		//Hack account column width so that it extends to entire list width	if(column == kAccountColumn_Name) {		info->width = (**_lists).lists[kList_Accounts].positions[kListCorner_BottomRight].position.h			- (**_lists).lists[kList_Accounts].positions[kListCorner_TopLeft].position.h - GetColumnInfoFromID(list, kAccountColumn_Icon)->width;	}		//Draw header title	XGetIndString(text, kColumnStringsID, info->id);	if(text[0]) {		if(list->selectedColumn && (*(list->selectedColumn) == column))		font = FontIndexToPtr(list->definition->headerSelectedFontIndex);		else		font = FontIndexToPtr(list->definition->headerFontIndex);			TextFont(font->cacheFontNum);		TextSize(font->size);		TextFace(font->style);				if(list->definition->headerTextAlignement == kUndefinedNum)		alignement = info->textAlignement;		else		alignement = list->definition->headerTextAlignement;				if(alignement == kTextAlign_Left)		h = hPos + list->definition->headerTextOffset.h;		else  if(alignement == kTextAlign_Middle)		h = hPos + list->definition->headerTextOffset.h + info->width / 2 - TextWidth(text, 1, text[0]) / 2;		else if(alignement == kTextAlign_Right)		h = hPos - list->definition->headerTextOffset.h + info->width - TextWidth(text, 1, text[0]);		v = list->bounds.top + list->definition->headerTextOffset.v;				if(font->flags & kFontFlag_HasShadow) {			RGBForeColor(&font->backColor);			MoveTo(h + 1, v + 1);			DrawString(text);		}		RGBForeColor(&font->foreColor);		MoveTo(h, v);		DrawString(text);		RGBForeColor(&saveColor);	}		//Draw header separator	if(info->flags & kColumnFlag_HasSeparator) {		RGBForeColor(&list->definition->headerSeparatorColor);		MoveTo(hPos + info->width, list->bounds.top);		LineTo(hPos + info->width, list->bounds.top + list->definition->headerImageSize.v - 1);		RGBForeColor(&saveColor);	}}void WindowServer::_DrawColumn(ListInfoPtr list, ID column){	ColumnInfoPtr		info = GetColumnInfoFromID(list, column);	short				hPos = list->bounds.left + GetColumnRelativePosition(list, column);	PaymentTypePtr		paymentList = appPrefs->payments->list;	CategoryPtr			categoryList = appPrefs->categories->list;#if __CONDENSED_TEXT__	Boolean				condensed = false;#endif	Str255				text;	RGBColor			saveColor,						saveColor2;	FontDefinitionPtr	font;	short				h, v;	long				i;	OperationPtr		operation;	short				offset;	Point*				image;	short				linePosition;		//Make sure column is visible	if(!(info->flags & kColumnFlag_Displayed))	return;					//Save fore & back colors	GetForeColor(&saveColor);	GetBackColor(&saveColor2);		//Draw header	if(list->selectedColumn && (column == *(list->selectedColumn))) {		font = FontIndexToPtr(list->definition->headerSelectedFontIndex);		if(list->active)		image = &list->definition->headerImageSelectedInactive;		else		image = &list->definition->headerImageSelectedOff;	}	else {		font = FontIndexToPtr(list->definition->headerFontIndex);		image = NULL;	}	_DrawColumnHeader(list, column, image);		//Make sure we have data	if(!list->numLines)	return;		//Set operation pointer	if(list->num == kList_Operations) {		operation = _operationListCache;		for(i = 0; i < list->firstLine; ++i)		operation = operation->next;	}	else	operation = NULL;		//Patch width	if(info->id == kAccountColumn_Name)	info->width = (**_lists).lists[kList_Accounts].positions[kListCorner_BottomRight].position.h;		//Draw column items	for(i = list->firstLine; i < list->numLines; ++i) {		//Set font		if(LineIsSelected(i, list))		font = FontIndexToPtr(list->definition->lineSelectedFontIndex);		else {			if((list->num == kList_Operations) && (DateToDay(operation->date) > application->today))			font = FontIndexToPtr(list->definition->lineOffFontIndex);			else			font = FontIndexToPtr(list->definition->lineFontIndex);		}		TextFont(font->cacheFontNum);		TextSize(font->size);		if(operation && (appPrefs->flags & kPreferencesFlag_IncomesInBold) && !(operation->flags & kOperationFlag_Expense))		TextFace(1);		else		TextFace(font->style);				linePosition = list->bounds.top + list->definition->headerImageSize.v + (i - list->firstLine) * list->definition->lineSize.v;		switch(info->id) {						case kAccountColumn_Icon:			if(TargetNumIsAccount(i)) {				if(application->accountList[TargetNumToAccountNum(i)]->IsLocked())				_DrawSkinImage(kSkinIcon_Lock, false, hPos, linePosition);				else				_DrawSkinImage(kSkinIcon_Account, false, hPos, linePosition);			}			else			_DrawSkinImage(kSkinIcon_Filter, false, hPos, linePosition);			break;						case kOperationColumn_Checked:			if(operation->flags & kOperationFlag_Checked)			_DrawSkinImage(kSkinIcon_CheckedOn, false, hPos, linePosition);			else if((**_skinDef).flags & kSkinFlag_DisplayCheckOffIcon)			_DrawSkinImage(kSkinIcon_CheckedOff, false, hPos, linePosition);			break;						case kOperationColumn_Warning:			if(operation->flags & kOperationFlag_Warning)			_DrawSkinImage(kSkinIcon_WarningOn, false, hPos, linePosition);			else if((**_skinDef).flags & kSkinFlag_DisplayWarningOffIcon)			_DrawSkinImage(kSkinIcon_WarningOff, false, hPos, linePosition);			break;						default:			offset = 0;			switch(info->id) {								case kAccountColumn_Name:				if(TargetNumIsAccount(i))				BlockMove(application->accountList[TargetNumToAccountNum(i)]->data->name, text, sizeof(Str255));				else				BlockMove(application->filterList[TargetNumToFilterNum(i)]->data->name, text, sizeof(Str255));				break;								case kOperationColumn_Description:				BlockMove(operation->description, text, sizeof(Str255));				if(appPrefs->flags & kPreferencesFlag_DisplayNoteTags) {					offset = (**_images).images[kSkinIcon_Note].dest.h + (**_images).images[kSkinIcon_Note].size.h;					if(operation->note[0])					_DrawSkinImage(kSkinIcon_Note, false, hPos, linePosition);					else if((**_skinDef).flags & kSkinFlag_DisplayNoteOffIcon)					_DrawSkinImage(kSkinIcon_NoteOff, false, hPos, linePosition);				}				break;								case kOperationColumn_Category:				if(operation->categoryNum == kUndefinedNum)				text[0] = 0;				else {					BlockMove(categoryList[operation->categoryNum].name, text, sizeof(Str63));					if(appPrefs->flags & kPreferencesFlag_DisplayCategoryColor) {						offset = (**_images).images[kSkinIcon_CategoryLabel].dest.h + (**_images).images[kSkinIcon_CategoryLabel].size.h;						RGBBackColor(&categoryList[operation->categoryNum].color);						_DrawSkinImage(kSkinIcon_CategoryLabel, false, hPos, linePosition);						RGBBackColor(&saveColor2);					}				}				break;								case kOperationColumn_PaymentType:				if(operation->paymentTypeNum == kUndefinedNum)				text[0] = 0;				else				BlockMove(paymentList[operation->paymentTypeNum].name, text, sizeof(Str63));				break;								case kOperationColumn_Amount:				if(appPrefs->flags & kPreferencesFlag_DisplayCurrencySymbol)				AmountToCurrencyString(operation->absoluteAmount, text, operation->owner->data->currencySymbol, !(operation->owner->data->flags & kAccountFlag_NoCents), operation->owner->data->flags & kAccountFlag_SymbolLeads);				else				AmountToString(operation->absoluteAmount, text, 0, 0, !(operation->owner->data->flags & kAccountFlag_NoCents));				break;								case kOperationColumn_Date:				if(appPrefs->flags & kPreferencesFlag_LongDates)				IUDateString(operation->date, longDate, text);				else				IUDateString(operation->date, shortDate, text);				break;								case kOperationColumn_Custom:				if(operation->customData[0])				BlockMove(operation->customData, text, sizeof(Str63));				else				text[0] = 0;				break;								case kOperationColumn_Balance:				if(appPrefs->flags & kPreferencesFlag_DisplayCurrencySymbol)				AmountToCurrencyString(operation->balance, text, operation->owner->data->currencySymbol, !(operation->owner->data->flags & kAccountFlag_NoCents), operation->owner->data->flags & kAccountFlag_SymbolLeads);				else				AmountToString(operation->balance, text, 0, 0, !(operation->owner->data->flags & kAccountFlag_NoCents));				break;								case kOperationColumn_Income:				if(!(operation->flags & kOperationFlag_Expense)) {					if(appPrefs->flags & kPreferencesFlag_DisplayCurrencySymbol)					AmountToCurrencyString(operation->amount, text, operation->owner->data->currencySymbol, !(operation->owner->data->flags & kAccountFlag_NoCents), operation->owner->data->flags & kAccountFlag_SymbolLeads);					else					AmountToString(operation->amount, text, 0, 0, !(operation->owner->data->flags & kAccountFlag_NoCents));				}				else				text[0] = 0;				break;								case kOperationColumn_Expense:				if(operation->flags & kOperationFlag_Expense) {					if(appPrefs->flags & kPreferencesFlag_DisplayCurrencySymbol)					AmountToCurrencyString(operation->amount, text, operation->owner->data->currencySymbol, !(operation->owner->data->flags & kAccountFlag_NoCents), operation->owner->data->flags & kAccountFlag_SymbolLeads);					else					AmountToString(operation->amount, text, 0, 0, !(operation->owner->data->flags & kAccountFlag_NoCents));				}				else				text[0] = 0;				break;								case kOperationColumn_Account:				BlockMove(operation->owner->data->name, text, sizeof(Str255));				break;									default: //case kOperationColumn_Note:				text[0] = 0;				break;							}			if(text[0]) {#if __CONDENSED_TEXT__				if(TextWidth(text, 1, text[0]) > info->width - 2 * list->definition->lineTextOffset.h - offset) {					CharExtra(-1 << 16);					SpaceExtra(-1 << 16);					condensed = true;					if(TextWidth(text, 1, text[0]) > info->width - 2 * list->definition->lineTextOffset.h - offset)					TroncateText(text, info->width - 2 * list->definition->lineTextOffset.h - offset);				}#else				TroncateText(text, info->width - 2 * list->definition->lineTextOffset.h - offset);#endif								if(info->textAlignement == kTextAlign_Left)				h = hPos + offset + list->definition->lineTextOffset.h;				else if(info->textAlignement == kTextAlign_Middle)				h = hPos + offset + list->definition->lineTextOffset.h + (info->width - offset) / 2 - TextWidth(text, 1, text[0]) / 2;				else if(info->textAlignement == kTextAlign_Right)				h = hPos - list->definition->lineTextOffset.h + info->width - TextWidth(text, 1, text[0]);				v = linePosition + list->definition->lineTextOffset.v;								if(font->flags & kFontFlag_HasShadow) {					RGBForeColor(&font->backColor);					MoveTo(h + 1, v + 1);					DrawString(text);				}				RGBForeColor(&font->foreColor);				MoveTo(h, v);				DrawString(text);				RGBForeColor(&saveColor);				#if __CONDENSED_TEXT__				if(condensed) {					CharExtra(0);					SpaceExtra(0);					condensed = false;				}#endif			}			break;					}				//Get next operation		if(operation)		operation = operation->next;				//Check if we have reached the bottom of the window		if(linePosition + list->definition->lineSize.v > list->bounds.bottom)		break;	}		//Draw column separator	if(info->flags & kColumnFlag_HasSeparator) {		RGBForeColor(&list->definition->listSeparatorColor);		MoveTo(hPos + info->width, list->bounds.top + list->definition->headerImageSize.v);		LineTo(hPos + info->width, list->bounds.bottom - 1);		RGBForeColor(&saveColor);	}}void WindowServer::_GetListWithFrameBounds(long num, Boolean active, Rect* bounds){	long				offset;	ImageDefinitionPtr	data;		//Compute list bounds	*bounds = _listInfo[num].bounds; //_GetListBounds(num, bounds);	if(active)	offset = kSkinSelectedListFrame_TopLeft - kSkinListFrame_TopLeft;	else	offset = 0;		//Add frame	data = &(**_images).images[kSkinListFrame_TopLeft + offset];	bounds->left -= data->size.h;	bounds->top -= data->size.v;	data = &(**_images).images[kSkinListFrame_TopLeft + offset];	bounds->right += data->size.h;	bounds->bottom += data->size.v;}void WindowServer::_DrawListFrame(ListInfoPtr list, Boolean eraseBackground){	Rect				bounds = list->bounds;	Point				temp;	ImageDefinitionPtr	data;	long				offset;		//Find frame to use	if(list->active)	offset = kSkinSelectedListFrame_TopLeft - kSkinListFrame_TopLeft;	else	offset = 0;		//Draw corners	_DrawSkinImage(kSkinListFrame_TopLeft + offset, eraseBackground, bounds.left, bounds.top);	_DrawSkinImage(kSkinListFrame_TopRight + offset, eraseBackground, bounds.right, bounds.top);	_DrawSkinImage(kSkinListFrame_BottomLeft + offset, eraseBackground, bounds.left, bounds.bottom);	_DrawSkinImage(kSkinListFrame_BottomRight + offset, eraseBackground, bounds.right, bounds.bottom);		//Draw sides	data = &(**_images).images[kSkinListFrame_Top + offset];	temp.h = bounds.left + data->dest.h;	temp.v = bounds.top + data->dest.v;	_DrawImageRepeatH(data->source, data->size, temp, bounds.right - bounds.left, data->flags & kImageFlag_UseAlpha, eraseBackground);	data = &(**_images).images[kSkinListFrame_Bottom + offset];	temp.h = bounds.left + data->dest.h;	temp.v = bounds.bottom + data->dest.v;	_DrawImageRepeatH(data->source, data->size, temp, bounds.right - bounds.left, data->flags & kImageFlag_UseAlpha, eraseBackground);	data = &(**_images).images[kSkinListFrame_Left + offset];	temp.h = bounds.left + data->dest.h;	temp.v = bounds.top + data->dest.v;	_DrawImageRepeatV(data->source, data->size, temp, bounds.bottom - bounds.top, data->flags & kImageFlag_UseAlpha, eraseBackground);	data = &(**_images).images[kSkinListFrame_Right + offset];	temp.h = bounds.right + data->dest.h;	temp.v = bounds.top + data->dest.v;	_DrawImageRepeatV(data->source, data->size, temp, bounds.bottom - bounds.top, data->flags & kImageFlag_UseAlpha, eraseBackground);}long WindowServer::_GetListNumVisibleLines(ListInfoPtr list){	long				count = 0;	short				position = list->bounds.top + list->definition->headerImageSize.v;		do {		++count;		position += list->definition->lineSize.v;	} while(position <= list->bounds.bottom);		return count - 1;}void WindowServer::_DrawListLines(ListInfoPtr list, Boolean eraseBackground){	short				width = list->bounds.right - list->bounds.left;	long				line = list->firstLine;	Boolean				useAlpha = list->definition->flags & kListFlag_LinesUseAlpha;	Point				temp;	Rect				theRect;		if(eraseBackground && (list->definition->flags & kListFlag_LinesUseAlpha)) {		theRect = list->bounds;		theRect.top += list->definition->headerImageSize.v;		_FillPattern(&theRect);	}		//Draw lines	temp.h = list->bounds.left;	temp.v = list->bounds.top + list->definition->headerImageSize.v;	do {		if(LineIsSelected(line, list)) {			if(list->active)			_DrawImageRepeatH(list->definition->lineImageSelected, list->definition->lineSize, temp, width, useAlpha, false);			else			_DrawImageRepeatH(list->definition->lineImageSelectedOff, list->definition->lineSize, temp, width, useAlpha, false);		}		else {			if((list->definition->flags & kListFlag_DifferentOddLines) && ((line + 1) % 2))			_DrawImageRepeatH(list->definition->lineImageOdd, list->definition->lineSize, temp, width, useAlpha, false);			else			_DrawImageRepeatH(list->definition->lineImage, list->definition->lineSize, temp, width, useAlpha, false);		}		temp.v += list->definition->lineSize.v;		++line;	} while(temp.v < list->bounds.bottom);}void WindowServer::_DrawListHeader(ListInfoPtr list, Point* imageBackground, Boolean eraseBackground){	Point				temp;	Rect				theRect;		if(eraseBackground && (list->definition->flags & kListFlag_HeaderUseAlpha)) {		theRect = list->bounds;		theRect.bottom = list->bounds.top + list->definition->headerImageSize.v;		_FillPattern(&theRect);	}		//Draw header background	temp.h = list->bounds.left;	temp.v = list->bounds.top;	_DrawImageRepeatH(*imageBackground, list->definition->headerImageSize, temp, list->bounds.right - list->bounds.left, list->definition->flags & kListFlag_HeaderUseAlpha, false);		//Draw sorting icon	if(list->definition->flags & kListFlag_HasSortingDirectionIcon) {		if(_appPrefs->windowFlags & kWindowFlag_SortIncreasing)		_DrawSkinImage(kSkinIcon_ListSortedUp, false, list->bounds.right, list->bounds.top);		else		_DrawSkinImage(kSkinIcon_ListSortedDown, false, list->bounds.right, list->bounds.top);	}}void WindowServer::_DrawList(ListInfoPtr list, Boolean drawScrollBar, Boolean erasebackground){	Rect				bounds = list->bounds;	short				position = 0;	long				i;		//Erase background	if(erasebackground)	_FillPattern(&bounds);		//Draw header	_DrawListHeader(list, &list->definition->headerImageInactive, false);		//Clip drawing to list - scrollBar	GetClip(_saveClip);	if(list->hasScrollbar)	bounds.right -= (**_scrollBar).width;	ClipRect(&bounds);		//Draw lines	_DrawListLines(list, false);		//Draw columns	for(i = 0; i < list->columnCount; ++i)	_DrawColumn(list, list->columnList[i].id);		//Restore clip	SetClip(_saveClip);		//Draw scroll bar	if(drawScrollBar && list->hasScrollbar) {		if(list->numLines > list->numVisibleLines) {			if(list->active)			_DrawListScrollBar(kScrollBarMode_Inactive, list, false);			else			_DrawListScrollBar(kScrollBarMode_Off, list, false);		}		else		_DrawListScrollBar(kScrollBarMode_Disabled, list, false);	}		//Draw note tag	if((list->num == kList_Operations) && _noteTagOperation)	_DrawNoteTag(_noteTagOperation->note, _noteTagPosition.h, _noteTagPosition.v);}void WindowServer::_DrawListContentClipped(ListInfoPtr list, Boolean erasebackground){	Rect				bounds = list->bounds;	short				position = 0;	long				i;		//Erase background	if(erasebackground)	_FillPattern(&bounds);		//Draw lines	_DrawListLines(list, false);		//Draw columns	for(i = 0; i < list->columnCount; ++i)	_DrawColumn(list, list->columnList[i].id);}Boolean WindowServer::_GetOperationListCacheSumString(StringPtr text){	OperationPtr		operation;	Str31				text2;	Amount				positive = 0,						negative = 0;		//Make sure we have some operations	if(_operationListCache == NULL)	return false;		//Get start string	XGetIndString(text, kWindowStringsID, 4);		//Make sure all operations are in the same currency	operation = _operationListCache->next;	while(operation) {		if((_operationListCache->owner != operation->owner) && !FastEqualString(_operationListCache->owner->data->currencySymbol, operation->owner->data->currencySymbol, false)) {			XGetIndString(text2, kWindowStringsID, 5);			AppendString(text, text2);			return true;		}		operation = operation->next;	}		//Sum operations	operation = _operationListCache;	do {		if(operation->flags & kOperationFlag_Expense)		negative += operation->amount;		else		positive += operation->amount;				operation = operation->next;	} while(operation);		//Create string	if(appPrefs->flags & kPreferencesFlag_DetailedSum) {		XGetIndString(text2, kWindowStringsID, 12);		AppendString(text, text2);		AmountToCurrencyString(positive, text2, _operationListCache->owner->data->currencySymbol, !(_operationListCache->owner->data->flags & kAccountFlag_NoCents), _operationListCache->owner->data->flags & kAccountFlag_SymbolLeads);		AppendString(text, text2);		XGetIndString(text2, kWindowStringsID, 13);		AppendString(text, text2);		AmountToCurrencyString(negative, text2, _operationListCache->owner->data->currencySymbol, !(_operationListCache->owner->data->flags & kAccountFlag_NoCents), _operationListCache->owner->data->flags & kAccountFlag_SymbolLeads);		AppendString(text, text2);		XGetIndString(text2, kWindowStringsID, 14);		AppendString(text, text2);	}	AmountToCurrencyString(positive - negative, text2, _operationListCache->owner->data->currencySymbol, !(_operationListCache->owner->data->flags & kAccountFlag_NoCents), _operationListCache->owner->data->flags & kAccountFlag_SymbolLeads);	AppendString(text, text2);		return true;}void WindowServer::_DrawNoteTag(StringPtr text, short h, short v, Boolean eraseBackground){	Rect				bounds = _listInfo[kList_Operations].bounds; //_GetListBounds(kList_Operations, &bounds);	FontDefinitionPtr	font = FontIndexToPtr((**_skinDef).noteTagFontIndex);	RGBColor			saveColor,						saveColor2;		//Make sure tag fits in list area	if(h < bounds.left)	h = bounds.left;	else if(v < bounds.top)	v = bounds.top;	if(h + (**_images).images[kSkinImage_NoteTag].size.h > bounds.right - (**_scrollBar).width)	h = bounds.right - (**_scrollBar).width - (**_images).images[kSkinImage_NoteTag].size.h;	else if(v + (**_images).images[kSkinImage_NoteTag].size.v > bounds.bottom)	v = bounds.bottom - (**_images).images[kSkinImage_NoteTag].size.v;		//Draw background image	_DrawSkinImage(kSkinImage_NoteTag, eraseBackground, h, v);		//Draw text box	GetForeColor(&saveColor);	GetBackColor(&saveColor2);	TextFont(font->cacheFontNum);	TextSize(font->size);	TextFace(font->style);	RGBForeColor(&font->foreColor);	RGBBackColor(&font->backColor);	bounds = (**_skinDef).noteTagTextBounds;	OffsetRect(&bounds, h, v);	TETextBox(&text[1], text[0], &bounds, teForceLeft);	RGBForeColor(&saveColor);	RGBBackColor(&saveColor2);}void WindowServer::_DrawDisplay(Boolean eraseBackground){	long				targetAccountNum = GetTargetNum();	Rect				copyRect;	Str255				text,						text2;	Amount				balance;		_GetSkinImageRect(kSkinImage_Display, &copyRect);	if(eraseBackground)	_FillPattern(&copyRect);	_DrawSkinImage(kSkinImage_Display, false);		XSetFont(FontIndexToPtr((**_skinDef).displayFontIndex));	if(TargetNumIsFilter(targetAccountNum)) {		targetAccountNum = TargetNumToFilterNum(targetAccountNum);				//Draw filter name		XGetIndString(text, kWindowStringsID, 9);		AppendString(text, application->filterList[targetAccountNum]->data->name);		XGetIndString(text2, kWindowStringsID, 10);		AppendString(text, text2);		TroncateText(text, (**_skinDef).displayArea.right - (**_skinDef).displayArea.left);		_DrawText(FontIndexToPtr((**_skinDef).displayFontIndex), text, copyRect.left + (**_skinDef).displayTextPosition_1.h, copyRect.top + (**_skinDef).displayTextPosition_1.v, (**_skinDef).displayTextAlignement);				//Draw filter description		BlockMove(application->filterList[targetAccountNum]->data->note, text, sizeof(Str255));		TroncateText(text, (**_skinDef).displayArea.right - (**_skinDef).displayArea.left);		_DrawText(FontIndexToPtr((**_skinDef).displayFontIndex), text, copyRect.left + (**_skinDef).displayTextPosition_2.h, copyRect.top + (**_skinDef).displayTextPosition_2.v, (**_skinDef).displayTextAlignement);	}	else if(TargetNumIsAccount(targetAccountNum)) {		targetAccountNum = TargetNumToAccountNum(targetAccountNum);				//Draw account name & info		if(application->accountList[targetAccountNum]->data->bank.name[0]			&& application->accountList[targetAccountNum]->data->bank.accountNumber[0]) {			text[0] = 0;			AppendString(text, application->accountList[targetAccountNum]->data->bank.name);			XGetIndString(text2, kWindowStringsID, 6);			AppendString(text, text2);			AppendString(text, application->accountList[targetAccountNum]->data->bank.accountNumber);		}		else {			XGetIndString(text, kWindowStringsID, 7);			AppendString(text, application->accountList[targetAccountNum]->data->name);			XGetIndString(text2, kWindowStringsID, 8);			AppendString(text, text2);		}		TroncateText(text, (**_skinDef).displayArea.right - (**_skinDef).displayArea.left);		_DrawText(FontIndexToPtr((**_skinDef).displayFontIndex), text, copyRect.left + (**_skinDef).displayTextPosition_1.h, copyRect.top + (**_skinDef).displayTextPosition_1.v, (**_skinDef).displayTextAlignement);				//Draw account balance		switch(_appPrefs->windowBalanceType) {						case kBalanceType_Current:			XGetIndString(text, kWindowStringsID, 2);			balance = application->accountList[targetAccountNum]->GetBalance(kBalanceType_Current);			break;						case kBalanceType_Future:			XGetIndString(text, kWindowStringsID, 11);			balance = application->accountList[targetAccountNum]->GetBalance(kBalanceType_Future);			break;						case kBalanceType_Reconciled:			XGetIndString(text, kWindowStringsID, 15);			balance = application->accountList[targetAccountNum]->GetBalance(kBalanceType_Reconciled);			break;					}		AmountToCurrencyString(balance, text2, application->accountList[targetAccountNum]->data->currencySymbol, !(application->accountList[targetAccountNum]->data->flags & kAccountFlag_NoCents), application->accountList[targetAccountNum]->data->flags & kAccountFlag_SymbolLeads);		AppendString(text, text2);		TroncateText(text, (**_skinDef).displayArea.right - (**_skinDef).displayArea.left);		_DrawText(FontIndexToPtr((**_skinDef).displayFontIndex), text, copyRect.left + (**_skinDef).displayTextPosition_2.h, copyRect.top + (**_skinDef).displayTextPosition_2.v, (**_skinDef).displayTextAlignement);	}}void WindowServer::UpdateServerWindow(Boolean isUpdate){	GWorldPtr			oldGWorld;	GDHandle			oldGDHandle;	Rect				copyRect;	RGBColor			saveColor;	GrafPtr				savePort;	long				pos;	Str255				text,						text2;		//Save GWorld	GetGWorld(&oldGWorld, &oldGDHandle);	SetGWorld(_windowBuffer, nil);		//Fill window with pattern	_FillPattern(&_appPrefs->windowContent);		//Draw title bar	if((**_skinDef).flags & kSkinFlag_HasTitleBar) {		_DrawSkinImage(kSkinTitleBar_Left, false);		_DrawSkinImage(kSkinTitleBar_Right, false);		_DrawImageRepeatH((**_images).images[kSkinTitleBar_Middle].source, (**_images).images[kSkinTitleBar_Middle].size, (**_images).images[kSkinTitleBar_Middle].dest, _GetTitleBarMiddleWidth(), (**_images).images[kSkinTitleBar_Middle].flags & kImageFlag_UseAlpha, false);	}		//Draw window buttons	_DrawSkinImage(kSkinButton_Close, false);	_DrawSkinImage(kSkinButton_Zoom, false);	_DrawSkinImage(kSkinButton_Resize, false);		//Draw magic button	switch(_GetMagicButtonMode()) {		case kMagicButtonMode_NewAccount: _DrawSkinImage(kSkinButton_Magic_NewAccount, false); break;		case kMagicButtonMode_NewOperation: _DrawSkinImage(kSkinButton_Magic_NewOperation, false); break;		case kMagicButtonMode_Print: _DrawSkinImage(kSkinButton_Magic_Print, false); break;	}		//Draw images	_DrawSkinImage(kSkinImage_Logo, false);	_DrawSkinImage(kSkinImage_Display, false);	_DrawSkinImage(kSkinImage_Filter, false);		//Draw filter caption	XGetIndString(text, kWindowStringsID, 1);	_GetSkinImageRect(kSkinImage_Filter, &copyRect);	XSetFont(FontIndexToPtr((**_skinDef).infoFontIndex));	_DrawText(FontIndexToPtr((**_skinDef).infoFontIndex), text, copyRect.left + (**_skinDef).filterCaptionPosition.h, copyRect.top + (**_skinDef).filterCaptionPosition.v, (**_skinDef).filterCaptionAlignement);		//Draw display	_DrawDisplay(false);		//Draw filter	if(userFocus == kFocus_Filter)	_DrawSkinImage(kSkinImage_FilterSelected, false);	else	_DrawSkinImage(kSkinImage_Filter, false);		//Draw account list	if(_appPrefs->windowFlags & kWindowFlag_AccountList) {		_DrawListFrame(&_listInfo[kList_Accounts], false);		_DrawList(&_listInfo[kList_Accounts], true, false);	}		//Draw operation list	_DrawListFrame(&_listInfo[kList_Operations], false);	_DrawList(&_listInfo[kList_Operations], true, false);		//Draw operation list info	if(_listInfo[kList_Operations].numLines) {		NumToString(_listInfo[kList_Operations].numLines, text);		XGetIndString(text2, kWindowStringsID, 3);		AppendString(text, text2);		if(_GetOperationListCacheSumString(text2))		AppendString(text, text2);				if((**_skinDef).infoTextAlignement == kTextAlign_Left)		pos = _listInfo[kList_Operations].bounds.left + (**_skinDef).infoTextPosition.h;		else  if((**_skinDef).infoTextAlignement == kTextAlign_Middle)		pos = _listInfo[kList_Operations].bounds.left + (**_skinDef).infoTextPosition.h + (_listInfo[kList_Operations].bounds.right - _listInfo[kList_Operations].bounds.left) / 2;		else if((**_skinDef).infoTextAlignement == kTextAlign_Right)		pos = _listInfo[kList_Operations].bounds.right + (**_skinDef).infoTextPosition.h;		XSetFont(FontIndexToPtr((**_skinDef).infoFontIndex));		_DrawText(FontIndexToPtr((**_skinDef).infoFontIndex), text, pos, _listInfo[kList_Operations].bounds.bottom + (**_skinDef).infoTextPosition.v, (**_skinDef).infoTextAlignement);	}		//Blend if suspended	if(_suspended && ((**_skinDef).flags & kSkinFlag_ColorOnHide)) {		GetForeColor(&saveColor);		RGBForeColor(&(**_skinDef).windowHideColor);		CopyBits(BMPtrFromGWorld(_windowBuffer), BMPtrFromGWorld(_windowBuffer), &_appPrefs->windowContent, &_appPrefs->windowContent, srcCopy, NULL);		RGBForeColor(&saveColor);	}		//Restore GWorld	SetGWorld(oldGWorld, oldGDHandle);		//Copy to window	GetPort(&savePort);	SetPortWindowPort(window);	if(isUpdate)	BeginUpdate(window);	CopyBits(BMPtrFromGWorld(_windowBuffer), BMPtrFromWindow(window), &_appPrefs->windowContent, &_appPrefs->windowContent, srcCopy, NULL);	_DrawFilterTE();	if(isUpdate)	EndUpdate(window);	SetPort(savePort);}short WindowServer::_WhereClickList(ListInfoPtr list, Point mouse, ID* column, long* line){	ImageDefinitionPtr	data = &(**_images).images[kSkinIcon_ListSortedUp];	short				result = kListClick_OnCell;	long				i;	short				min,						max;	Rect				theRect;		//Reset	*line = kUndefinedNum;	*column = kUndefinedID;		//Check sorting icon	if(list->definition->flags & kListFlag_HasSortingDirectionIcon) {		theRect.left = list->bounds.right + data->dest.h;		theRect.top = list->bounds.top + data->dest.v;		theRect.right = theRect.left + data->size.h;		theRect.bottom = theRect.top + data->size.v;		if(PtInRect(mouse, &theRect))		return kListClick_OnSortingIcon;	}		//Check lines	min = list->bounds.top + list->definition->headerImageSize.v;	max = min + list->definition->lineSize.v;	i = 0;	do {		if((mouse.v >= min) && (mouse.v <= max)) {			*line = i;			break;		}		min += list->definition->lineSize.v;		max += list->definition->lineSize.v;		++i;	} while(min < list->bounds.bottom);	if(*line != kUndefinedNum) {		*line += list->firstLine;		if(*line >= list->numLines)		*line = kUndefinedNum;	}		//Check columns	min = list->bounds.left;	for(i = 0; i < list->columnCount; ++i)	if(list->columnList[i].flags & kColumnFlag_Displayed) {		max = min + list->columnList[i].width;		if((mouse.h >= min) && (mouse.h <= max)) {			*column = list->columnList[i].id;			if((mouse.v >= list->bounds.top) && (mouse.v <= list->bounds.top + list->definition->headerImageSize.v)) {				if((list->columnList[i].flags & kColumnFlag_Resizable) && (list->columnList[i].flags & kColumnFlag_HasSeparator) && (*line == kUndefinedNum) && (mouse.h >= max - kMouseSeparatorTolerance))				result = kListClick_OnHeaderSeparator;				else				result = kListClick_OnHeader;			}			break;		}		min = max;	}		//Make sure we have a cell click	if((result == kListClick_OnCell) && ((*line == kUndefinedNum) || (*column == kUndefinedID)))	result = kListClick_NoWhere;		return result;}short WindowServer::_WhereClick(Point localMouse){	Rect				theRect,						temp;		//Check close button	_GetSkinImageRect(kSkinButton_Close, &theRect);	if(PtInRect(localMouse, &theRect))	return kWindowClick_InCloseBox;		//Check zoom button	_GetSkinImageRect(kSkinButton_Zoom, &theRect);	if(PtInRect(localMouse, &theRect))	return kWindowClick_InZoomBox;		//Check resize button	_GetSkinImageRect(kSkinButton_Resize, &theRect);	if(PtInRect(localMouse, &theRect))	return kWindowClick_InGrowBox;		//Check magic button	switch(_GetMagicButtonMode()) {		case kMagicButtonMode_NewAccount: _GetSkinImageRect(kSkinButton_Magic_NewAccount, &theRect); break;		case kMagicButtonMode_NewOperation: _GetSkinImageRect(kSkinButton_Magic_NewOperation, &theRect); break;		case kMagicButtonMode_Print: _GetSkinImageRect(kSkinButton_Magic_Print, &theRect); break;	}	if(PtInRect(localMouse, &theRect))	return kWindowClick_InMagicButton;		//Check title bar	if((**_skinDef).flags & kSkinFlag_HasTitleBar) {		_GetSkinImageRect(kSkinTitleBar_Left, &theRect);		if(PtInRect(localMouse, &theRect))		return kWindowClick_InDrag;		_GetSkinImageRect(kSkinTitleBar_Middle, &theRect);		theRect.right = theRect.left + _GetTitleBarMiddleWidth();		if(PtInRect(localMouse, &theRect))		return kWindowClick_InDrag;		_GetSkinImageRect(kSkinTitleBar_Right, &theRect);		if(PtInRect(localMouse, &theRect))		return kWindowClick_InDrag;	}		//Check filter	_GetSkinImageRect(kSkinImage_Filter, &temp);	theRect = (**_skinDef).filterArea;	OffsetRect(&theRect, temp.left, temp.top);	if(PtInRect(localMouse, &theRect))	return kWindowClick_InFilter;		//Check display	_GetSkinImageRect(kSkinImage_Display, &theRect);	if(PtInRect(localMouse, &theRect))	return kWindowClick_InDisplay;		//Check account list scrollbar	if(_listInfo[kList_Accounts].hasScrollbar && (_appPrefs->windowFlags & kWindowFlag_AccountList) && (_listInfo[kList_Accounts].numLines > _listInfo[kList_Accounts].numVisibleLines)) {		_GetListScrollBarBounds(&_listInfo[kList_Accounts], &theRect);		if(PtInRect(localMouse, &theRect))		return kWindowClick_InAccountScrollBar;	}		//Check account list	if(_appPrefs->windowFlags & kWindowFlag_AccountList) {		if(PtInRect(localMouse, &_listInfo[kList_Accounts].bounds))		return kWindowClick_InAccountList;	}		//Check operation list scrollbar	if(_listInfo[kList_Operations].hasScrollbar && (_listInfo[kList_Operations].numLines > _listInfo[kList_Operations].numVisibleLines)) {		_GetListScrollBarBounds(&_listInfo[kList_Operations], &theRect);		if(PtInRect(localMouse, &theRect))		return kWindowClick_InOperationScrollBar;	}		//Check operation list	if(PtInRect(localMouse, &_listInfo[kList_Operations].bounds))	return kWindowClick_InOperationList;		//Default: drag window!	if(!((**_skinDef).flags & kSkinFlag_HasTitleBar))	return kWindowClick_InDrag;		return kWindowClick_NoWhere;}Boolean WindowServer::_TrackButtonClick(long numUp, long numDown){	Rect				buttonRect;	GWorldPtr			oldGWorld;	GDHandle			oldGDHandle;	Boolean				inside = false;	Point				mouse;#if TARGET_API_MAC_CARBON	MouseTrackingResult	result;#endif		//Build button rect	_GetSkinImageRect(numUp, &buttonRect);		//Track user mouse#if TARGET_API_MAC_CARBON	_mouseDown = true;	do#else	while(Button())#endif	{		GetMouse(&mouse);		if(PtInRect(mouse, &buttonRect)) {			if(!inside) {				GetGWorld(&oldGWorld, &oldGDHandle);				SetGWorld(_windowBuffer, nil);				_DrawSkinImage(numDown);				SetGWorld(oldGWorld, oldGDHandle);				CopyBits(BMPtrFromGWorld(_windowBuffer), BMPtrFromWindow(window), &buttonRect, &buttonRect, srcCopy, NULL);				inside = true;			}		}		else {			if(inside) {				GetGWorld(&oldGWorld, &oldGDHandle);				SetGWorld(_windowBuffer, nil);				_DrawSkinImage(numUp);				SetGWorld(oldGWorld, oldGDHandle);				CopyBits(BMPtrFromGWorld(_windowBuffer), BMPtrFromWindow(window), &buttonRect, &buttonRect, srcCopy, NULL);				inside = false;			}		}#if TARGET_API_MAC_CARBON		TrackMouseLocation(GetWindowPort(window), &mouse, &result);#endif	}#if TARGET_API_MAC_CARBON	while(result != kMouseTrackingMouseUp);	_mouseDown = false;#endif	if(inside) {		GetGWorld(&oldGWorld, &oldGDHandle);		SetGWorld(_windowBuffer, nil);		_DrawSkinImage(numUp);		SetGWorld(oldGWorld, oldGDHandle);		CopyBits(BMPtrFromGWorld(_windowBuffer), BMPtrFromWindow(window), &buttonRect, &buttonRect, srcCopy, NULL);	}		return inside;}Boolean WindowServer::_TrackListIconClick(ListInfoPtr list, ID column, long line, long numUp, long numDown){	ImageDefinitionPtr	data = &(**_images).images[numUp];	Rect				iconRect;	Boolean				inside = false;	GWorldPtr			oldGWorld;	GDHandle			oldGDHandle;	Point				mouse,						cellTopLeftCorner;#if TARGET_API_MAC_CARBON	MouseTrackingResult	result;#endif	//Get cell top left corner	cellTopLeftCorner.h = list->bounds.left + GetColumnRelativePosition(list, column);	cellTopLeftCorner.v = list->bounds.top + list->definition->headerImageSize.v + (line - list->firstLine) * list->definition->lineSize.v;		//Build icon rect	iconRect.left = cellTopLeftCorner.h + data->dest.h;	iconRect.top = cellTopLeftCorner.v + data->dest.v;	iconRect.right = iconRect.left + data->size.h;	iconRect.bottom = iconRect.top + data->size.v;		//Clip drawing to icon	GetClip(_saveClip);	if(iconRect.bottom > list->bounds.bottom) //_GetListBounds(list->num, &bounds);	iconRect.bottom = list->bounds.bottom;	ClipRect(&iconRect);	iconRect.bottom = iconRect.top + data->size.v;		//Track user mouse#if TARGET_API_MAC_CARBON	_mouseDown = true;	do#else	while(Button())#endif	{		GetMouse(&mouse);		if(PtInRect(mouse, &iconRect)) {			if(!inside) {				GetGWorld(&oldGWorld, &oldGDHandle);				SetGWorld(_windowBuffer, nil);				_DrawListLines(list);				_DrawSkinImage(numDown, false, cellTopLeftCorner.h, cellTopLeftCorner.v);				SetGWorld(oldGWorld, oldGDHandle);				CopyBits(BMPtrFromGWorld(_windowBuffer), BMPtrFromWindow(window), &iconRect, &iconRect, srcCopy, NULL);				inside = true;			}		}		else {			if(inside) {				GetGWorld(&oldGWorld, &oldGDHandle);				SetGWorld(_windowBuffer, nil);				_DrawListLines(list);				_DrawSkinImage(numUp, false, cellTopLeftCorner.h, cellTopLeftCorner.v);				SetGWorld(oldGWorld, oldGDHandle);				CopyBits(BMPtrFromGWorld(_windowBuffer), BMPtrFromWindow(window), &iconRect, &iconRect, srcCopy, NULL);				inside = false;			}		}#if TARGET_API_MAC_CARBON		TrackMouseLocation(GetWindowPort(window), &mouse, &result);#endif	}#if TARGET_API_MAC_CARBON	while(result != kMouseTrackingMouseUp);	_mouseDown = false;#endif		//Restore clip	SetClip(_saveClip);	return inside;}void WindowServer::_InvalidWindow(){#if !TARGET_API_MAC_CARBON	GrafPtr			savePort;#endif#if TARGET_API_MAC_CARBON	InvalWindowRect(window, &_appPrefs->windowContent);#else	GetPort(&savePort);	SetPort(window);	InvalRect(&_appPrefs->windowContent);	SetPort(savePort);#endif}void WindowServer::_ValidWindow(){#if !TARGET_API_MAC_CARBON	GrafPtr			savePort;#endif#if TARGET_API_MAC_CARBON	ValidWindowRect(window, &_appPrefs->windowContent);#else	GetPort(&savePort);	SetPort(window);	ValidRect(&_appPrefs->windowContent);	SetPort(savePort);#endif}void WindowServer::_ResizeWindow(short posH, short posV, short width, short height){	OSErr				theError;	GWorldPtr			oldGWorld;	GDHandle			oldGDHandle;	Str255				text = "\p";	GrafPtr				savePort;	Rect				bufferRect = {0,0,height,width};		//Save port	GetPort(&savePort);	SetPortWindowPort(window);		//Kill buffer	if(_windowBuffer) {		UnlockPixels(GetGWorldPixMap(_windowBuffer));		DisposeGWorld(_windowBuffer);	}		//Create buffer	GetGWorld(&oldGWorld, &oldGDHandle);	_windowBuffer = NULL;	theError = NewGWorld(&_windowBuffer, kColorBitDepth, &bufferRect, NULL, NULL, useTempMem);	if(theError)	application->errorManager->FatalError(41, (void*) theError);	NoPurgePixels(GetGWorldPixMap(_windowBuffer));	LockPixels(GetGWorldPixMap(_windowBuffer));	SetGWorld(_windowBuffer, nil);	BackColor(whiteColor);	ForeColor(blackColor);	EraseRect(&bufferRect);	SetGWorld(oldGWorld, oldGDHandle);		//Resize window	MoveWindow(window, posH, posV, false);	SizeWindow(window, width, height, false);		//Save new window size	_appPrefs->windowPosition.h = posH;	_appPrefs->windowPosition.v = posV;	_appPrefs->windowContent = bufferRect;		//Create filter TE	if(_filterTE) {		_GetFilterText(text);		TEDispose(_filterTE);	}	if(!_CreateFilterTE())	application->errorManager->FatalError(41, (void*) -1);	_SetFilterText(text);		//Restore port	SetPort(savePort);		//Force data update	Invalidate();}OperationPtr WindowServer::_GetOperationFromAbsoluteNum(long num){	OperationPtr		operation = _operationListCache;	long				index = 0;		if((num == kUndefinedNum) || !operation)	return NULL;		do {		if(index == num)		return operation;				operation = operation->next;		++index;	} while(operation != NULL);		return NULL;}short WindowServer::_GetColumnMinimalWidth(ListInfoPtr list, ID columnID){	GWorldPtr				oldGWorld;	GDHandle				oldGDHandle;	Str63					text;	short					width;	FontDefinitionPtr		font;		//Save GWorld	GetGWorld(&oldGWorld, &oldGDHandle);	SetGWorld(_windowBuffer, nil);			//Get column title length	if(list->selectedColumn && (*(list->selectedColumn) == columnID))	font = FontIndexToPtr(list->definition->headerSelectedFontIndex);	else	font = FontIndexToPtr(list->definition->headerFontIndex);	TextFont(font->cacheFontNum);	TextSize(font->size);	TextFace(font->style);	XGetIndString(text, kColumnStringsID, columnID);	width = TextWidth(text, 1, text[0]) + kMinColumnSizeTolerance;		//Restore GWorld	SetGWorld(oldGWorld, oldGDHandle);		return width;}void WindowServer::_ResizeColumn(ListInfoPtr list, ID columnID, Point startMouse){	Point					mouse;	ColumnInfoPtr			info;	short					startWidth,							newWidth,							minWidth;	GWorldPtr				oldGWorld;	GDHandle				oldGDHandle;#if TARGET_API_MAC_CARBON	MouseTrackingResult		result;#endif		//Save GWorld	GetGWorld(&oldGWorld, &oldGDHandle);			//Get column info	info = _GetColumnFromID(columnID);	if(info == NULL)	return;	startWidth = info->width;	minWidth = _GetColumnMinimalWidth(list, columnID);		//Resize column#if TARGET_API_MAC_CARBON	_mouseDown = true;	do#else	while(Button())#endif	{		GetMouse(&mouse);		newWidth = startWidth + mouse.h - startMouse.h;		if(newWidth < minWidth)		newWidth = minWidth;				//Redraw window		if(newWidth != info->width) {			info->width = newWidth;					SetGWorld(_windowBuffer, nil);			_DrawList(list);			SetGWorld(oldGWorld, oldGDHandle);			CopyBits(BMPtrFromGWorld(_windowBuffer), BMPtrFromWindow(window), &list->bounds, &list->bounds, srcCopy, NULL);		}#if TARGET_API_MAC_CARBON		TrackMouseLocation(GetWindowPort(window), &mouse, &result);#endif	}#if TARGET_API_MAC_CARBON	while(result != kMouseTrackingMouseUp);	_mouseDown = false;#endif}inline void SwitchColumns(long count, ColumnInfo list[], ID a, ID b){	long			i;	long			numA,					numB;	ColumnInfo		temp;		//Find columns indexes	for(i = 0; i < count; ++i) {		if(list[i].id == a)		numA = i;		else if(list[i].id == b)		numB = i;	}		//Switch columns	temp = list[numA];	list[numA] = list[numB];	list[numB] = temp;}void WindowServer::_MoveColumn(ListInfoPtr list, ID columnID, Point startMouse){	Point					mouse;	short					where;	ID						column;	long					line;	GWorldPtr				oldGWorld;	GDHandle				oldGDHandle;	Rect					columnRect;	short					offset;	Pattern					thePattern;#if TARGET_API_MAC_CARBON	MouseTrackingResult		result;#endif		//Save GWorld	GetGWorld(&oldGWorld, &oldGDHandle);		//Compute column bounds	GetColumnBounds(list, columnID, &columnRect);	offset = startMouse.h - columnRect.left;		//Get fill pattern	GetIndPattern(&thePattern, 0, 4);		//Set mouse	_currentCursor = kThemeClosedHandCursor;	SetThemeCursor(_currentCursor);		//Track mouse#if TARGET_API_MAC_CARBON	_mouseDown = true;	do#else	while(Button())#endif		{		GetMouse(&mouse);		if(mouse.h == startMouse.h)		continue;		startMouse = mouse;				//Find column under mouse		where = _WhereClick(mouse);		if(((where == kWindowClick_InAccountList) && (list->num == kList_Accounts))			|| ((where == kWindowClick_InOperationList) && (list->num == kList_Operations)))		_WhereClickList(list, mouse, &column, &line);		else		column = kUndefinedID;				//Provide visual feedback		SetGWorld(_windowBuffer, nil);		_DrawList(list);				OffsetRect(&columnRect, mouse.h - offset - columnRect.left, 0);		PenSize(2, 2);		PenMode(patOr);		PenPat(&thePattern);		FrameRect(&columnRect);		PenNormal();		OffsetRect(&columnRect, -(mouse.h - offset - columnRect.left), 0);				SetGWorld(oldGWorld, oldGDHandle);		CopyBits(BMPtrFromGWorld(_windowBuffer), BMPtrFromWindow(window), &list->bounds, &list->bounds, srcCopy, NULL);#if TARGET_API_MAC_CARBON		TrackMouseLocation(GetWindowPort(window), &mouse, &result);#endif	}#if TARGET_API_MAC_CARBON	while(result != kMouseTrackingMouseUp);	_mouseDown = false;#endif		//Switch columns	if((column != kUndefinedID) && (_GetColumnFromID(column)->flags & kColumnFlag_Movable) && (column != columnID)) {		//Switch columns		SwitchColumns(list->columnCount, list->columnList, columnID, column);				//Redraw		SetGWorld(_windowBuffer, nil);		_DrawList(list);		SetGWorld(oldGWorld, oldGDHandle);		CopyBits(BMPtrFromGWorld(_windowBuffer), BMPtrFromWindow(window), &list->bounds, &list->bounds, srcCopy, NULL);	}		//Set mouse	_currentCursor = kThemeArrowCursor;	SetThemeCursor(_currentCursor);}void WindowServer::_HandleAccountListClick(Point mouse, Boolean doubleClick, short modifiers){	ListInfoPtr				list = &_listInfo[kList_Accounts];	ID						column;	long					line;		//Find where user clicked	_WhereClickList(list, mouse, &column, &line);		//Select new line if any	if(line != kUndefinedNum) {		if(line != GetTargetNum()) {			if((TargetNumIsAccount(line) && application->accountList[TargetNumToAccountNum(line)]->Unlock())				|| (TargetNumIsFilter(line) && application->filterList[TargetNumToFilterNum(line)]->Unlock(application->accountCount, application->accountList))) {				ClearFilterText();				if(TargetNumIsAccount(line))				Invalidate(application->accountList[TargetNumToAccountNum(line)]->data->id);				else				Invalidate(application->filterList[TargetNumToFilterNum(line)]->data->id);			}		}		else if(doubleClick)		application->commandServer->Execute(kCommand_EditAccountInfo);	}		//Set focus	if(userFocus != kFocus_AccountList)	_SetFocus(kFocus_AccountList);}short WindowServer::_TrackListHeaderClick(ListInfoPtr list, ID column){	ColumnInfoPtr		info = _GetColumnFromID(column);	unsigned long		startTime = TickCount();	short				result = 0;	Rect				headerRect;	Point				mouse,						start;	GWorldPtr			oldGWorld;	GDHandle			oldGDHandle;	FontDefinitionPtr	font;	Boolean				canDrag;#if TARGET_API_MAC_CARBON	MouseTrackingResult	trackingResult = 0;#endif		//Can we drag this column	if(info->flags & kColumnFlag_Movable)	canDrag = true;	else	canDrag = false;		//Build header rect	headerRect.left = list->bounds.left + GetColumnRelativePosition(list, column);	headerRect.top = list->bounds.top;	headerRect.bottom = list->bounds.top + list->definition->headerImageSize.v;	headerRect.right = headerRect.left + info->width;		//Clip header rect	mouse.h = list->bounds.right;	if(list->hasScrollbar)	mouse.h -= (**_scrollBar).width;	if(headerRect.right > mouse.h)	headerRect.right = mouse.h;		//Find header font	if(list->selectedColumn && (*(list->selectedColumn) == column))	font = FontIndexToPtr(list->definition->headerSelectedFontIndex);	else	font = FontIndexToPtr(list->definition->headerFontIndex);		//Track user mouse	GetMouse(&start);#if TARGET_API_MAC_CARBON	_mouseDown = true;	do#else	while(Button())#endif	{		GetMouse(&mouse);		#if TARGET_API_MAC_CARBON		if(canDrag && (trackingResult == kMouseTrackingMouseMoved)) {			if((TickCount() - startTime) > kDragDelay) {				result = -1;				break;			}			else			canDrag = false;		}#else		if(canDrag && ((TickCount() - startTime) > kDragDelay)) {			if(EqualPt(start, mouse)) {				result = -1;				break;			}			else			canDrag = false;		}#endif				if(PtInRect(mouse, &headerRect)) {			if(!result) {				GetGWorld(&oldGWorld, &oldGDHandle);				SetGWorld(_windowBuffer, nil);				if(list->selectedColumn && (*(list->selectedColumn) == column))				_DrawColumnHeader(list, column, &list->definition->headerImageSelectedActive);				else				_DrawColumnHeader(list, column, &list->definition->headerImageActive);				SetGWorld(oldGWorld, oldGDHandle);				CopyBits(BMPtrFromGWorld(_windowBuffer), BMPtrFromWindow(window), &headerRect, &headerRect, srcCopy, NULL);				result = 1;			}		}		else {			if(result) {				GetGWorld(&oldGWorld, &oldGDHandle);				SetGWorld(_windowBuffer, nil);				if(list->selectedColumn && (*(list->selectedColumn) == column))				_DrawColumnHeader(list, column, &list->definition->headerImageSelectedInactive);				else {					if(list->active)					_DrawColumnHeader(list, column, &list->definition->headerImageInactive);					else					_DrawColumnHeader(list, column, &list->definition->headerImageSelectedOff);				}				SetGWorld(oldGWorld, oldGDHandle);				CopyBits(BMPtrFromGWorld(_windowBuffer), BMPtrFromWindow(window), &headerRect, &headerRect, srcCopy, NULL);				result = 0;			}		}#if TARGET_API_MAC_CARBON		TrackMouseLocation(GetWindowPort(window), &mouse, &trackingResult);#endif	}#if TARGET_API_MAC_CARBON	while(trackingResult != kMouseTrackingMouseUp);	_mouseDown = false;#endif	if((result == 1) && list->selectedColumn && (column == *list->selectedColumn)) {		GetGWorld(&oldGWorld, &oldGDHandle);		SetGWorld(_windowBuffer, nil);		if(list->selectedColumn && (*(list->selectedColumn) == column))		_DrawColumnHeader(list, column, &list->definition->headerImageSelectedInactive);		else {			if(list->active)			_DrawColumnHeader(list, column, &list->definition->headerImageInactive);			else			_DrawColumnHeader(list, column, &list->definition->headerImageSelectedOff);		}		SetGWorld(oldGWorld, oldGDHandle);		CopyBits(BMPtrFromGWorld(_windowBuffer), BMPtrFromWindow(window), &headerRect, &headerRect, srcCopy, NULL);	}		return result;}Boolean WindowServer::_TrackListSortingIconClick(ListInfoPtr list){	ImageDefinitionPtr	data = &(**_images).images[kSkinIcon_ListSortedUp];	Rect				iconRect,						copyRect;	Point				mouse;	GWorldPtr			oldGWorld;	GDHandle			oldGDHandle;	Boolean				inIcon = false;	#if TARGET_API_MAC_CARBON	MouseTrackingResult	result;#endif		//Build icon rect	iconRect.left = list->bounds.right + data->dest.h;	iconRect.top = list->bounds.top + data->dest.v;	iconRect.right = iconRect.left + data->size.h;	iconRect.bottom = iconRect.top + data->size.v;		//Build copy rect	copyRect = list->bounds;	copyRect.left = list->bounds.right - (**_scrollBar).width;	copyRect.bottom = list->bounds.top + list->definition->headerImageSize.v;		//Track user mouse#if TARGET_API_MAC_CARBON	_mouseDown = true;	do#else	while(Button())#endif	{		GetMouse(&mouse);				if(PtInRect(mouse, &iconRect)) {			if(!inIcon) {				GetGWorld(&oldGWorld, &oldGDHandle);				SetGWorld(_windowBuffer, nil);				_DrawListHeader(list, &list->definition->headerImageActive, true);				SetGWorld(oldGWorld, oldGDHandle);				CopyBits(BMPtrFromGWorld(_windowBuffer), BMPtrFromWindow(window), &copyRect, &copyRect, srcCopy, NULL);				inIcon = true;			}		}		else {			if(inIcon) {				GetGWorld(&oldGWorld, &oldGDHandle);				SetGWorld(_windowBuffer, nil);				if(list->active)				_DrawListHeader(list, &list->definition->headerImageInactive, true);				else				_DrawListHeader(list, &list->definition->headerImageSelectedOff, true);				SetGWorld(oldGWorld, oldGDHandle);				CopyBits(BMPtrFromGWorld(_windowBuffer), BMPtrFromWindow(window), &copyRect, &copyRect, srcCopy, NULL);				inIcon = false;			}		}#if TARGET_API_MAC_CARBON		TrackMouseLocation(GetWindowPort(window), &mouse, &result);#endif	}#if TARGET_API_MAC_CARBON	while(result != kMouseTrackingMouseUp);	_mouseDown = false;#endif		return inIcon;}void WindowServer::_SetOperationListSelection(long line){	ListInfoPtr				list = &_listInfo[kList_Operations];		list->selectedNumList[0] = line;	list->selectedIDList[0] = _GetOperationFromAbsoluteNum(line)->id;	list->numSelectedLines = 1;}void WindowServer::_AppendOperationListSelection(long line, Boolean switchState){	ListInfoPtr				list = &_listInfo[kList_Operations];	Boolean					found = false;	long					i;		for(i = 0; i < list->numSelectedLines; ++i)	if(list->selectedNumList[i] == line) {		if(switchState) {			--list->numSelectedLines;			list->selectedNumList[i] = list->selectedNumList[list->numSelectedLines];			list->selectedIDList[i] = list->selectedIDList[list->numSelectedLines];			return;		}				found = true;		break;	}	if(found)	return;	if(list->numSelectedLines >= list->maxSelectedLines)	return;		list->selectedNumList[list->numSelectedLines] = line;	list->selectedIDList[list->numSelectedLines] = _GetOperationFromAbsoluteNum(line)->id;	++list->numSelectedLines;}void WindowServer::_ExtendOperationListSelection(long line){	ListInfoPtr				list = &_listInfo[kList_Operations];	long					min,							max,							i;		min = GetSelectionMin(list);	max = GetSelectionMax(list);	if(line < min)	min = line;	if(line > max)	max = line;		for(i = min; i <= max; ++i)	_AppendOperationListSelection(i, false);}void WindowServer::_HandleOperationListClick(Point mouse, Boolean doubleClick, short modifiers){	ListInfoPtr				list = &_listInfo[kList_Operations];	ID						column;	long					line;	Boolean					redraw;	OperationPtr			operation;	Rect					theRect;	GWorldPtr				oldGWorld;	GDHandle				oldGDHandle;	short					where;	Rect					copyRect;		//Find where user clicked	where = _WhereClickList(list, mouse, &column, &line);		//Change sorting direction	if(where == kListClick_OnSortingIcon) {		if(userFocus != kFocus_OperationList)		_SetFocus(kFocus_OperationList);		if(_TrackListSortingIconClick(list)) {			if(_appPrefs->windowFlags & kWindowFlag_SortIncreasing)			_appPrefs->windowFlags &= ~kWindowFlag_SortIncreasing;			else			_appPrefs->windowFlags |= kWindowFlag_SortIncreasing;				_ReverseOperationListCache();			_RefreshOperationListSelection();			UpdateServerWindow();			_ValidWindow();		}	}		//Resize column	else if(where == kListClick_OnHeaderSeparator) {		if(userFocus != kFocus_OperationList)		_SetFocus(kFocus_OperationList);		_ResizeColumn(list, column, mouse);	}		//Move column or select header	else if(where == kListClick_OnHeader) {		if((column != kUndefinedID) && (_GetColumnFromID(column)->flags & kColumnFlag_Sortable)) {			line = _TrackListHeaderClick(list, column);			if(line > 0) {				if(column != _appPrefs->windowSortingColumn) {					_appPrefs->windowSortingColumn = column;					Invalidate();				}				else if(modifiers & optionKey) {					if(_appPrefs->windowFlags & kWindowFlag_SortIncreasing)					_appPrefs->windowFlags &= ~kWindowFlag_SortIncreasing;					else					_appPrefs->windowFlags |= kWindowFlag_SortIncreasing;										_ReverseOperationListCache();					_RefreshOperationListSelection();					UpdateServerWindow();					_ValidWindow();				}			}			else if(line < 0) {				if(userFocus != kFocus_OperationList)				_SetFocus(kFocus_OperationList);				_MoveColumn(list, column, mouse);				_InvalidWindow();			}		}	}		//Handle click on line	else if(where == kListClick_OnCell) {		operation = _GetOperationFromAbsoluteNum(line);		theRect = _listInfo[kList_Operations].bounds; //_GetListBounds(kList_Operations, &theRect);		if(operation) {			redraw = false;			if(column == kOperationColumn_Checked) {				if(((appPrefs->flags & kPreferencesFlag_SecureOperationCheck) && doubleClick)					|| (!(appPrefs->flags & kPreferencesFlag_SecureOperationCheck) && (((operation->flags & kOperationFlag_Checked) && _TrackListIconClick(list, column, line, kSkinIcon_CheckedOn, kSkinIcon_CheckedOnClicked))						|| (!(operation->flags & kOperationFlag_Checked) && (!((**_skinDef).flags & kSkinFlag_DisplayCheckOffIcon) || _TrackListIconClick(list, column, line, kSkinIcon_CheckedOff, kSkinIcon_CheckedOffClicked)))))) {					if(operation->flags & kOperationFlag_Checked)					operation->flags &= ~kOperationFlag_Checked;					else					operation->flags |= kOperationFlag_Checked;					GetDateTime(&operation->lastEditDate);										if(TargetNumIsAccount(GetTargetNum()) && (_appPrefs->windowBalanceType == kBalanceType_Reconciled)) {						GetGWorld(&oldGWorld, &oldGDHandle);						SetGWorld(_windowBuffer, nil);						_DrawDisplay();						SetGWorld(oldGWorld, oldGDHandle);						_GetSkinImageRect(kSkinImage_Display, &copyRect);						CopyBits(BMPtrFromGWorld(_windowBuffer), BMPtrFromWindow(window), &copyRect, &copyRect, srcCopy, NULL);					}					#if !__DELAY_FILTER_VALIDATION__					if(TargetNumIsFilter(GetTargetNum()) || (_appPrefs->windowSortingColumn == kOperationColumn_Checked))					Invalidate();					else#endif					if(userFocus == kFocus_OperationList)					redraw = true;				}			}			else if(column == kOperationColumn_Warning) {				if(((operation->flags & kOperationFlag_Warning) && _TrackListIconClick(list, column, line, kSkinIcon_WarningOn, kSkinIcon_WarningOnClicked))					|| (!(operation->flags & kOperationFlag_Warning) && (!((**_skinDef).flags & kSkinFlag_DisplayWarningOffIcon) || _TrackListIconClick(list, column, line, kSkinIcon_WarningOff, kSkinIcon_WarningOffClicked)))) {					if(operation->flags & kOperationFlag_Warning)					operation->flags &= ~kOperationFlag_Warning;					else					operation->flags |= kOperationFlag_Warning;					GetDateTime(&operation->lastEditDate);					#if !__DELAY_FILTER_VALIDATION__					if(TargetNumIsFilter(GetTargetNum()) || (_appPrefs->windowSortingColumn == kOperationColumn_Warning))					Invalidate();					else#endif					if(userFocus == kFocus_OperationList)					redraw = true;				}			}			else if((column != kOperationColumn_Checked) && (column != kOperationColumn_Warning)) {				if(doubleClick && list->numSelectedLines && LineIsSelected(line, list))				application->commandServer->Execute(kCommand_EditOperation);				else {					if(modifiers & shiftKey)					_ExtendOperationListSelection(line);					else if(modifiers & cmdKey)					_AppendOperationListSelection(line, true);					else if(!LineIsSelected(line, list))					_SetOperationListSelection(line);					if(userFocus == kFocus_OperationList)					redraw = true;				}			}						if(redraw) {				GetGWorld(&oldGWorld, &oldGDHandle);				SetGWorld(_windowBuffer, nil);				_DrawList(list);				SetGWorld(oldGWorld, oldGDHandle);				CopyBits(BMPtrFromGWorld(_windowBuffer), BMPtrFromWindow(window), &list->bounds, &list->bounds, srcCopy, NULL);			}		}	}	else if(list->numSelectedLines) {		list->numSelectedLines = 0;		GetGWorld(&oldGWorld, &oldGDHandle);		SetGWorld(_windowBuffer, nil);		_DrawList(list);		SetGWorld(oldGWorld, oldGDHandle);		CopyBits(BMPtrFromGWorld(_windowBuffer), BMPtrFromWindow(window), &list->bounds, &list->bounds, srcCopy, NULL);	}		if(userFocus != kFocus_OperationList)	_SetFocus(kFocus_OperationList);}short WindowServer::_WhereClickScrollBar(ListInfoPtr list, Point mouse){	Rect					barRect,							thumbRect,							tempRect;		//Get bounds	_GetListScrollBarBounds(list, &barRect);	_GetListScrollBarThumbBounds(list, &thumbRect);	tempRect.left = barRect.left;	tempRect.right = barRect.right;		//Check scrollbar	if(!PtInRect(mouse, &barRect))	return kScrollBarClick_NoWhere;		//Check thumb	if(PtInRect(mouse, &thumbRect))	return kScrollBarClick_InThumb;		//Check up arrow	tempRect.top = barRect.top;	tempRect.bottom = barRect.top + (**_scrollBar).images[kScrollBarPart_ArrowUp].height;	if(PtInRect(mouse, &tempRect))	return kScrollBarClick_InUpArrow;		//Check down arrow	tempRect.top = barRect.bottom - (**_scrollBar).images[kScrollBarPart_ArrowDown].height;	tempRect.bottom = barRect.bottom;	if(PtInRect(mouse, &tempRect))	return kScrollBarClick_InDownArrow;		//Check up	tempRect.top = barRect.top + (**_scrollBar).images[kScrollBarPart_ArrowUp].height;	tempRect.bottom = thumbRect.top;	if(PtInRect(mouse, &tempRect))	return kScrollBarClick_InUp;		//Check down	tempRect.top = thumbRect.bottom;	tempRect.bottom = barRect.bottom - (**_scrollBar).images[kScrollBarPart_ArrowDown].height;	if(PtInRect(mouse, &tempRect))	return kScrollBarClick_InDown;		return kScrollBarClick_NoWhere;}long WindowServer::_GetScrollBarValueFromThumb(ListInfoPtr list, short position){	short				minHeight = (**_scrollBar).images[kScrollBarPart_ThumbTop].height + (**_scrollBar).images[kScrollBarPart_ThumbBottom].height;	long				max = list->numLines - list->numVisibleLines,						value;	Rect				thumbAreaRect;		if((**_scrollBar).flags & kScrollBarFlag_HasThumbMark)	minHeight += (**_scrollBar).images[kScrollBarPart_ThumbMark].height;		_GetListScrollBarBounds(list, &thumbAreaRect);	thumbAreaRect.top += (**_scrollBar).images[kScrollBarPart_ArrowUp].height;	thumbAreaRect.bottom -= (**_scrollBar).images[kScrollBarPart_ArrowDown].height;		if(thumbAreaRect.bottom - thumbAreaRect.top - max * (**_scrollBar).step < minHeight)	value = (float) max * (float) (position - thumbAreaRect.top) / (float) (thumbAreaRect.bottom - thumbAreaRect.top - minHeight);	else	value = (position - thumbAreaRect.top) / (**_scrollBar).step;		if(value < 0)	value = 0;	else if(value > max)	value = max;		return value;}#if 1 //!TARGET_API_MAC_CARBONinline void XScrollRectVertical(WindowPtr window, Rect* moveRect, short distVert){	Rect					sourceRect,							destRect;		sourceRect.left = moveRect->left;	sourceRect.right = moveRect->right;	destRect.left = moveRect->left;	destRect.right = moveRect->right;		if(distVert < 0) {		sourceRect.top = moveRect->top - distVert;		sourceRect.bottom = moveRect->bottom;		destRect.top = moveRect->top;		destRect.bottom = moveRect->bottom + distVert;	}	else {		sourceRect.top = moveRect->top;		sourceRect.bottom = moveRect->bottom - distVert;		destRect.top = moveRect->top + distVert;		destRect.bottom = moveRect->bottom;	}	if((sourceRect.bottom - sourceRect.top) > 0)	CopyBits(BMPtrFromWindow(window), BMPtrFromWindow(window), &sourceRect, &destRect, srcCopy, NULL);}#endifvoid WindowServer::_TrackListScrollBarClick(ListInfoPtr list, Point mouse, short modifiers){	short					where,							startWhere;	Rect					listBounds,							barBounds,							thumbBounds,							theRect;	GWorldPtr				oldGWorld;	GDHandle				oldGDHandle;	Boolean					redrawBar;	long					mode = -1,							newMode;	unsigned long			lastTime = 0;	long					oldFirstLine;	short					offset;#if !__CUSTOM_SCROLLRECT__	RgnHandle				updateRgn;#endif#if TARGET_API_MAC_CARBON	MouseTrackingResult		result;	UInt32					outModifiers;#endif		//Compute bounds	listBounds = list->bounds, //_GetListBounds(list->num, &listBounds);	listBounds.top += list->definition->headerImageSize.v;	if(list->hasScrollbar)	listBounds.right -= (**_scrollBar).width;	_GetListScrollBarThumbBounds(list, &thumbBounds);	_GetListScrollBarBounds(list, &barBounds);	theRect.left = listBounds.left;	theRect.right = listBounds.right;		//Find thumb mouse offset	offset = mouse.v - thumbBounds.top;		//Track user mouse#if !__CUSTOM_SCROLLRECT__	updateRgn = NewRgn();#endif	startWhere = _WhereClickScrollBar(list, mouse);#if TARGET_API_MAC_CARBON	_mouseDown = true;	do#else	while(Button())#endif	{		redrawBar = false;		oldFirstLine = list->firstLine;				GetMouse(&mouse);		if(startWhere != kScrollBarClick_InThumb)		where = _WhereClickScrollBar(list, mouse);		else		where = startWhere;		switch(where) {						case kScrollBarClick_NoWhere:			case kScrollBarClick_InUp:			case kScrollBarClick_InDown:			newMode = kScrollBarMode_Inactive;			break;						case kScrollBarClick_InUpArrow:			if(startWhere == kScrollBarClick_InUpArrow)			newMode = kScrollBarMode_ArrowUp;			else			newMode = kScrollBarMode_Inactive;			break;						case kScrollBarClick_InDownArrow:			if(startWhere == kScrollBarClick_InDownArrow)			newMode = kScrollBarMode_ArrowDown;			else			newMode = kScrollBarMode_Inactive;			break;						case kScrollBarClick_InThumb:			if(startWhere == kScrollBarClick_InThumb)			newMode = kScrollBarMode_Thumb;			else			newMode = kScrollBarMode_Inactive;			break;					}		if(newMode != mode) {			mode = newMode;			redrawBar = true;		}				if(where == startWhere)		switch(where) {					case kScrollBarClick_InDown:#if TARGET_API_MAC_CARBON			if(!(modifiers & optionKey))#else			if(modifiers & optionKey)#endif			{				if(TickCount() > lastTime + kScrollDelay2) {					list->firstLine += list->numVisibleLines;					if(list->firstLine + list->numVisibleLines > list->numLines)					list->firstLine = list->numLines - list->numVisibleLines;					lastTime = TickCount();				}			}			else			list->firstLine = _GetScrollBarValueFromThumb(list, mouse.v - (thumbBounds.bottom - thumbBounds.top) / 2);			break;						case kScrollBarClick_InUp:#if TARGET_API_MAC_CARBON			if(!(modifiers & optionKey))#else			if(modifiers & optionKey)#endif			{				if(TickCount() > lastTime + kScrollDelay2) {					list->firstLine -= list->numVisibleLines;					if(list->firstLine < 0)					list->firstLine = 0;					lastTime = TickCount();				}			}			else			list->firstLine = _GetScrollBarValueFromThumb(list, mouse.v - (thumbBounds.bottom - thumbBounds.top) / 2);			break;						case kScrollBarClick_InUpArrow:			if((list->firstLine > 0) && (TickCount() > lastTime + kScrollDelay)) {				--list->firstLine;				lastTime = TickCount();			}			break;						case kScrollBarClick_InDownArrow:			if((list->firstLine < list->numLines - list->numVisibleLines) && (TickCount() > lastTime + kScrollDelay)) {				++list->firstLine;				lastTime = TickCount();			}			break;						case kScrollBarClick_InThumb:			list->firstLine = _GetScrollBarValueFromThumb(list, mouse.v - offset);			break;					}				if(redrawBar || (list->firstLine != oldFirstLine)) {			GetGWorld(&oldGWorld, &oldGDHandle);			SetGWorld(_windowBuffer, nil);			if(list->firstLine > oldFirstLine) {				theRect.top = listBounds.bottom - (list->firstLine - oldFirstLine) * list->definition->lineSize.v;				if(theRect.top < listBounds.top)				theRect.top = listBounds.top;				theRect.bottom = listBounds.bottom;				GetClip(_saveClip);				ClipRect(&theRect);				_DrawListContentClipped(list);				SetClip(_saveClip);			}			else if(list->firstLine < oldFirstLine) {				theRect.top = listBounds.top;				theRect.bottom = listBounds.top + (oldFirstLine - list->firstLine) * list->definition->lineSize.v;				if(theRect.bottom > listBounds.bottom)				theRect.bottom = listBounds.bottom;				GetClip(_saveClip);				ClipRect(&theRect);				_DrawListContentClipped(list);				SetClip(_saveClip);			}			if(redrawBar || (list->firstLine != oldFirstLine))			_DrawListScrollBar(mode, list);			SetGWorld(oldGWorld, oldGDHandle);						if(list->firstLine > oldFirstLine) {#if 0 //TARGET_API_MAC_CARBON				ScrollWindowRect(window, &listBounds, 0, (oldFirstLine - list->firstLine) * list->definition->lineSize.v, kScrollWindowNoOptions, NULL);#else				XScrollRectVertical(window, &listBounds, (oldFirstLine - list->firstLine) * list->definition->lineSize.v);#endif				CopyBits(BMPtrFromGWorld(_windowBuffer), BMPtrFromWindow(window), &theRect, &theRect, srcCopy, NULL);			}			else if(list->firstLine < oldFirstLine) {#if 0 //TARGET_API_MAC_CARBON				ScrollWindowRect(window, &listBounds, 0, (oldFirstLine - list->firstLine) * list->definition->lineSize.v, kScrollWindowNoOptions, NULL);#else				XScrollRectVertical(window, &listBounds, (oldFirstLine - list->firstLine) * list->definition->lineSize.v);#endif				CopyBits(BMPtrFromGWorld(_windowBuffer), BMPtrFromWindow(window), &theRect, &theRect, srcCopy, NULL);			}			if(redrawBar || (list->firstLine != oldFirstLine))			CopyBits(BMPtrFromGWorld(_windowBuffer), BMPtrFromWindow(window), &barBounds, &barBounds, srcCopy, NULL);		}		#if TARGET_API_MAC_CARBON		TrackMouseLocationWithOptions(GetWindowPort(window), 0, (EventTime) kScrollDelay / (EventTime) 60, &mouse, &outModifiers, &result);#endif	}#if TARGET_API_MAC_CARBON	while(result != kMouseTrackingMouseUp);	_mouseDown = false;#endif#if !__CUSTOM_SCROLLRECT__	DisposeRgn(updateRgn);#endif		//Force final update	GetGWorld(&oldGWorld, &oldGDHandle);	SetGWorld(_windowBuffer, nil);	_DrawList(list);	SetGWorld(oldGWorld, oldGDHandle);	listBounds = list->bounds;	CopyBits(BMPtrFromGWorld(_windowBuffer), BMPtrFromWindow(window), &listBounds, &listBounds, srcCopy, NULL);}Boolean WindowServer::HandleMouseClick(short modifiers){	Point					mouse;	Rect					theRect;	long					newSize;	Boolean					hit = true;	GrafPtr					savePort;	Boolean					doubleClick;	Point					thePoint;	OSErr					theError = noErr;	GWorldPtr				oldGWorld;	GDHandle				oldGDHandle;	//Save port	GetPort(&savePort);	SetPortWindowPort(window);		//Get mouse position	GetMouse(&mouse);		//Check for double click	if((TickCount() <= _lastClickTime + GetDblTime()) && PointInPointRect(mouse, _lastClickWhere, kDoubleClickTolerance))	doubleClick = true;	else	doubleClick = false;	_lastClickTime = TickCount();	_lastClickWhere = mouse;		switch(_WhereClick(mouse)) {				case kWindowClick_InDrag:#if TARGET_API_MAC_CARBON		GetRegionBounds(GetGrayRgn(), &theRect);#else		theRect = (**GetGrayRgn()).rgnBBox;#endif		LocalToGlobal(&mouse);		DragWindow(window, mouse, &theRect);		_appPrefs->windowPosition = GetWindowPosition(window);		break;				case kWindowClick_InCloseBox:		if(_TrackButtonClick(kSkinButton_Close, kSkinButton_CloseClicked)) {			if(application->errorManager->Warning(39))			application->commandServer->Execute(kCommand_Quit);		}		break;				case kWindowClick_InZoomBox:		if(_TrackButtonClick(kSkinButton_Zoom, kSkinButton_ZoomClicked)) {			if(_windowZoomed) {				thePoint = _zoomPosition;				theRect = _zoomWindowContent;			}			else {				_zoomPosition = _appPrefs->windowPosition;				_zoomWindowContent = _appPrefs->windowContent;				GetWindowMaxSize(&theRect, &thePoint);				if(theRect.right < (**_skinDef).windowMinWidth)				theRect.right = (**_skinDef).windowMinWidth;				if(theRect.bottom < (**_skinDef).windowMinHeight)				theRect.bottom = (**_skinDef).windowMinHeight;			}			_windowZoomed = !_windowZoomed;			_ResizeWindow(thePoint.h, thePoint.v, theRect.right, theRect.bottom);		}		break;				case kWindowClick_InGrowBox:		SetRect(&theRect, (**_skinDef).windowMinWidth, (**_skinDef).windowMinHeight, 32000, 32000);		LocalToGlobal(&mouse);		newSize = GrowWindow(window, mouse, &theRect);		if(newSize) {			thePoint.h = LoWord(newSize);			thePoint.v = HiWord(newSize);			if(thePoint.h < (**_skinDef).windowMinWidth)			thePoint.h = (**_skinDef).windowMinWidth;			if(thePoint.v < (**_skinDef).windowMinHeight)			thePoint.v = (**_skinDef).windowMinHeight;			_ResizeWindow(_appPrefs->windowPosition.h, _appPrefs->windowPosition.v, thePoint.h, thePoint.v);		}		break;				case kWindowClick_InMagicButton:		switch(_GetMagicButtonMode()) {					case kMagicButtonMode_NewAccount:			if(_TrackButtonClick(kSkinButton_Magic_NewAccount, kSkinButton_Magic_NewAccountClicked))			theError = application->commandServer->Execute(kCommand_NewAccount);			break;						case kMagicButtonMode_NewOperation:			if(_TrackButtonClick(kSkinButton_Magic_NewOperation, kSkinButton_Magic_NewOperationClicked))			theError = application->commandServer->Execute(kCommand_NewOperation);			break;						case kMagicButtonMode_Print:			if(_TrackButtonClick(kSkinButton_Magic_Print, kSkinButton_Magic_PrintClicked))			theError = application->commandServer->Execute(kCommand_Print);			break;					}		if(theError)		application->errorManager->StandardError(13, (void*) theError);		break;				case kWindowClick_InFilter:		if(userFocus == kFocus_Filter)		TEClick(mouse, false, _filterTE);		else		_SetFocus(kFocus_Filter);		break;				case kWindowClick_InAccountList:		_HandleAccountListClick(mouse, doubleClick, modifiers);		break;				case kWindowClick_InOperationList:		_HandleOperationListClick(mouse, doubleClick, modifiers);		break;				case kWindowClick_InAccountScrollBar:		if(userFocus != kFocus_AccountList)		_SetFocus(kFocus_AccountList);		_TrackListScrollBarClick(&_listInfo[kList_Accounts], mouse, modifiers);		break;				case kWindowClick_InOperationScrollBar:		if(userFocus != kFocus_OperationList)		_SetFocus(kFocus_OperationList);		_TrackListScrollBarClick(&_listInfo[kList_Operations], mouse, modifiers);		break;				case kWindowClick_InDisplay:		++_appPrefs->windowBalanceType;		if(_appPrefs->windowBalanceType > kBalanceType_Reconciled)		_appPrefs->windowBalanceType = kBalanceType_Current;		_GetSkinImageRect(kSkinImage_Display, &theRect);		GetGWorld(&oldGWorld, &oldGDHandle);		SetGWorld(_windowBuffer, nil);		_DrawDisplay();		SetGWorld(oldGWorld, oldGDHandle);		CopyBits(BMPtrFromGWorld(_windowBuffer), BMPtrFromWindow(window), &theRect, &theRect, srcCopy, NULL);		break;				default:		hit = false;		break;			}		//Restore port	SetPort(savePort);		return hit;}#if __CARBON_EVENTS__Boolean WindowServer::HandleMouseWheel(long delta){	Boolean				hit = true;	GWorldPtr			oldGWorld;	GDHandle			oldGDHandle;	GrafPtr				savePort;		//Save port	GetPort(&savePort);	SetPortWindowPort(window);		//Save GWorld	GetGWorld(&oldGWorld, &oldGDHandle);		//User focus dependent	switch(userFocus) {				case kFocus_Filter:		hit = false;		break;				case kFocus_AccountList:		if(_listInfo[kList_Accounts].numLines > _listInfo[kList_Accounts].numVisibleLines) {			_listInfo[kList_Accounts].firstLine -= delta;						if(_listInfo[kList_Accounts].firstLine + _listInfo[kList_Accounts].numVisibleLines > _listInfo[kList_Accounts].numLines)			_listInfo[kList_Accounts].firstLine = _listInfo[kList_Accounts].numLines - _listInfo[kList_Accounts].numVisibleLines;			if(_listInfo[kList_Accounts].firstLine < 0)			_listInfo[kList_Accounts].firstLine = 0;						SetGWorld(_windowBuffer, nil);			_DrawList(&_listInfo[kList_Accounts]);			SetGWorld(oldGWorld, oldGDHandle);			CopyBits(BMPtrFromGWorld(_windowBuffer), BMPtrFromWindow(window), &_listInfo[kList_Accounts].bounds, &_listInfo[kList_Accounts].bounds, srcCopy, NULL);		}		else		hit = false;		break;				case kFocus_OperationList:		if(_listInfo[kList_Operations].numLines > _listInfo[kList_Operations].numVisibleLines) {			_listInfo[kList_Operations].firstLine -= delta;						if(_listInfo[kList_Operations].firstLine + _listInfo[kList_Operations].numVisibleLines > _listInfo[kList_Operations].numLines)			_listInfo[kList_Operations].firstLine = _listInfo[kList_Operations].numLines - _listInfo[kList_Operations].numVisibleLines;			if(_listInfo[kList_Operations].firstLine < 0)			_listInfo[kList_Operations].firstLine = 0;						SetGWorld(_windowBuffer, nil);			_DrawList(&_listInfo[kList_Operations]);			SetGWorld(oldGWorld, oldGDHandle);			CopyBits(BMPtrFromGWorld(_windowBuffer), BMPtrFromWindow(window), &_listInfo[kList_Operations].bounds, &_listInfo[kList_Operations].bounds, srcCopy, NULL);		}		else		hit = false;		break;			}		//Restore port	SetPort(savePort);		return hit;}#endifvoid WindowServer::Idle(){	OperationPtr		noteOperation = NULL,						operation;	long				newCursor;	Point				mouse;	GrafPtr				savePort;	ID					column;	long				line;	Rect				temp;	short				where;		if(_suspended)	return;		//Animate text edit area	if(userFocus == kFocus_Filter)	TEIdle(_filterTE);		//Set cursor#if TARGET_API_MAC_CARBON	if(!_mouseDown)#endif	{		GetPort(&savePort);		SetPortWindowPort(window);		GetMouse(&mouse);		newCursor = kThemeArrowCursor;		if(PtInRect(mouse, &_appPrefs->windowContent)) {			if(PtInRect(mouse, &_listInfo[kList_Operations].bounds)) {				where = _WhereClickList(&_listInfo[kList_Operations], mouse, &column, &line);								//Check if we are on a separator				if(where == kListClick_OnHeaderSeparator)				newCursor = kThemeResizeLeftRightCursor;								//Check if we are on a description cell with a note				if((where == kListClick_OnCell) && (userFocus == kFocus_OperationList) && (column == kOperationColumn_Description)) {					operation = _GetOperationFromAbsoluteNum(line);					if(operation && operation->note[0]) {						//Check if we are on the note icon						GetColumnBounds(&_listInfo[kList_Operations], kOperationColumn_Description, &temp);						temp.left += (**_images).images[kSkinIcon_Note].dest.h;						temp.top += (**_lists).lists[kList_Operations].headerImageSize.v + (line - _listInfo[kList_Operations].firstLine) * (**_lists).lists[kList_Operations].lineSize.v + (**_images).images[kSkinIcon_Note].dest.v;						temp.bottom = temp.top + (**_images).images[kSkinIcon_Note].size.v;						temp.right = temp.left + (**_images).images[kSkinIcon_Note].size.h;						if(PtInRect(mouse, &temp)) {							if(_noteTagOperation)							noteOperation = operation;							else if(_noteTagEnterTime) {								if(TickCount() > _noteTagEnterTime + kNoteTagDelay)								noteOperation = operation;							}							else							_noteTagEnterTime = TickCount();						}					}				}			}		}				//Set cursor		if(newCursor != _currentCursor) {			_currentCursor = newCursor;			SetThemeCursor(_currentCursor);		}				//Display note tag		if(noteOperation != _noteTagOperation) {			_noteTagOperation = noteOperation;			_noteTagEnterTime = 0;			_noteTagPosition.h = temp.right;			_noteTagPosition.v = temp.bottom;			_InvalidWindow();		}				SetPort(savePort);	}		//Save operation first line	if(_listInfo[kList_Accounts].numSelectedLines) {		if(TargetNumIsFilter(_listInfo[kList_Accounts].selectedNumList[0]))		application->filterList[TargetNumToFilterNum(_listInfo[kList_Accounts].selectedNumList[0])]->data->firstLine = _listInfo[kList_Operations].firstLine;		else		application->accountList[TargetNumToAccountNum(_listInfo[kList_Accounts].selectedNumList[0])]->data->firstLine = _listInfo[kList_Operations].firstLine;	}}Boolean WindowServer::HandleKeyDown(char theChar, unsigned char theKey, short modifiers){	Boolean				hit = true;	long				newTarget;	GWorldPtr			oldGWorld;	GDHandle			oldGDHandle;	GrafPtr				savePort;	OperationPtr		operation;	long				i;		//Save port	GetPort(&savePort);	SetPortWindowPort(window);		//Save GWorld	GetGWorld(&oldGWorld, &oldGDHandle);		//User focus independent	if(theKey == keyTab) {		newTarget = userFocus % (kNumFocus - 1) + 1;		if((newTarget == kFocus_AccountList) && !(_appPrefs->windowFlags & kWindowFlag_AccountList))		newTarget = kFocus_OperationList;		_SetFocus(newTarget);		return true;	}		//User focus dependent	switch(userFocus) {			case kFocus_Filter:		if((theKey != keyReturn) && (theKey != keyEnter) && (theKey != keyEnterPB)) {			TEKey(theChar, _filterTE);			Invalidate();		}		else		hit = false;		break;				case kFocus_AccountList:		if((theKey == keyDelete) || (theKey == keyBackSpace))		application->commandServer->Execute(kCommand_DeleteTarget);		else if((theKey == keyReturn) || (theKey == keyEnter) || (theKey == keyEnterPB))		application->commandServer->Execute(kCommand_EditAccountInfo);		else if(((theKey == keyArrowUp) || (theKey == keyArrowDown)) && (TickCount() > _lastLineMoveTime + kLineMoveDelay)) {			if(_listInfo[kList_Accounts].numLines) {				newTarget = GetTargetNum();							if(theKey == keyArrowUp) {					if(newTarget == kUndefinedNum)					newTarget = 0;					else if(newTarget > 0)					--newTarget;				}				else if(theKey == keyArrowDown) {					if(newTarget == kUndefinedNum)					newTarget = _listInfo[kList_Accounts].numLines - 1;					else if(newTarget < _listInfo[kList_Accounts].numLines - 1)					++newTarget;				}								if(newTarget != GetTargetNum()) {					if((TargetNumIsAccount(newTarget) && application->accountList[TargetNumToAccountNum(newTarget)]->Unlock())						|| (TargetNumIsFilter(newTarget) && application->filterList[TargetNumToFilterNum(newTarget)]->Unlock(application->accountCount, application->accountList))) {						ClearFilterText();						if(TargetNumIsAccount(newTarget))						Invalidate(application->accountList[TargetNumToAccountNum(newTarget)]->data->id);						else						Invalidate(application->filterList[TargetNumToFilterNum(newTarget)]->data->id);					}				}								_lastLineMoveTime = TickCount();			}		}		else {			if(TickCount() > _lastKeyTime + kKeySelectionMaxDelay)			_keyString[0] = 0;			_keyString[++_keyString[0]] = theChar;						if(_listInfo[kList_Accounts].numLines) {				newTarget = kUndefinedNum;				for(i = 0; i < _listInfo[kList_Accounts].numLines; ++i) {					if(TargetNumIsAccount(i) && (application->accountList[TargetNumToAccountNum(i)]->data->name[0] >= _keyString[0])						&& FastEqualText(_keyString[0], &_keyString[1], &application->accountList[TargetNumToAccountNum(i)]->data->name[1], false)) {						newTarget = i;						break;					}					else if(TargetNumIsFilter(i) && (application->filterList[TargetNumToFilterNum(i)]->data->name[0] >= _keyString[0])						&& FastEqualText(_keyString[0], &_keyString[1], &application->filterList[TargetNumToFilterNum(i)]->data->name[1], false)) {						newTarget = i;						break;					}				}								if(newTarget != GetTargetNum()) {					if((TargetNumIsAccount(newTarget) && application->accountList[TargetNumToAccountNum(newTarget)]->Unlock())						|| (TargetNumIsFilter(newTarget) && application->filterList[TargetNumToFilterNum(newTarget)]->Unlock(application->accountCount, application->accountList))) {						ClearFilterText();						if(TargetNumIsAccount(newTarget))						Invalidate(application->accountList[TargetNumToAccountNum(newTarget)]->data->id);						else						Invalidate(application->filterList[TargetNumToFilterNum(newTarget)]->data->id);					}				}				else				hit = false;			}			else			hit = false;						_lastKeyTime = TickCount();		}		break;				case kFocus_OperationList:		if((theKey == keyDelete) || (theKey == keyBackSpace))		application->commandServer->Execute(kCommand_DeleteOperation);		else if((theKey == keyReturn) || (theKey == keyEnter) || (theKey == keyEnterPB))		application->commandServer->Execute(kCommand_EditOperation);		else if(((theKey == keyArrowUp) || (theKey == keyArrowDown)) && (TickCount() > _lastLineMoveTime + kLineMoveDelay)) {			if(_listInfo[kList_Operations].numLines) {				newTarget = kUndefinedNum;				if(_listInfo[kList_Operations].numSelectedLines) {					if(modifiers & shiftKey) {						if(theKey == keyArrowUp) {							newTarget = GetSelectionMin(&_listInfo[kList_Operations]);							if(newTarget > 0) {								--newTarget;								_ExtendOperationListSelection(newTarget);							}							else							newTarget = kUndefinedNum;						}						else if(theKey == keyArrowDown) {							newTarget = GetSelectionMax(&_listInfo[kList_Operations]);							if(newTarget < _listInfo[kList_Operations].numLines - 1) {								++newTarget;								_ExtendOperationListSelection(newTarget);							}							else							newTarget = kUndefinedNum;						}					}					else if(!(modifiers & cmdKey)) {						if(theKey == keyArrowUp) {							newTarget = GetSelectionMin(&_listInfo[kList_Operations]);							if(newTarget > 0) {								--newTarget;								_SetOperationListSelection(newTarget);							}							else							newTarget = kUndefinedNum;						}						else if(theKey == keyArrowDown) {							newTarget = GetSelectionMax(&_listInfo[kList_Operations]);							if(newTarget < _listInfo[kList_Operations].numLines - 1) {								++newTarget;								_SetOperationListSelection(newTarget);							}							else							newTarget = kUndefinedNum;						}					}				}				else {					if(theKey == keyArrowUp)					_SetOperationListSelection(0);					else if(theKey == keyArrowDown)					_SetOperationListSelection(_listInfo[kList_Operations].numLines - 1);					newTarget = _listInfo[kList_Operations].selectedNumList[0];				}								if(newTarget != kUndefinedNum) {					_ScrollListFirstLine(&_listInfo[kList_Operations], newTarget);					SetGWorld(_windowBuffer, nil);					_DrawList(&_listInfo[kList_Operations]);					SetGWorld(oldGWorld, oldGDHandle);					CopyBits(BMPtrFromGWorld(_windowBuffer), BMPtrFromWindow(window), &_listInfo[kList_Operations].bounds, &_listInfo[kList_Operations].bounds, srcCopy, NULL);				}								_lastLineMoveTime = TickCount();			}		}		else if((theKey == keyHome) || (theKey == keyEnd) || (theKey == keyPageUp) || (theKey == keyPageDown)) {			if(_listInfo[kList_Operations].numLines) {				if(theKey == keyHome)				_listInfo[kList_Operations].firstLine = 0;				else if(theKey == keyEnd)				_listInfo[kList_Operations].firstLine = 0xFFFF;				else if(theKey == keyPageUp)				_listInfo[kList_Operations].firstLine -= _listInfo[kList_Operations].numVisibleLines;				else if(theKey == keyPageDown)				_listInfo[kList_Operations].firstLine += _listInfo[kList_Operations].numVisibleLines;								if(_listInfo[kList_Operations].firstLine + _listInfo[kList_Operations].numVisibleLines > _listInfo[kList_Operations].numLines)				_listInfo[kList_Operations].firstLine = _listInfo[kList_Operations].numLines - _listInfo[kList_Operations].numVisibleLines;				if(_listInfo[kList_Operations].firstLine < 0)				_listInfo[kList_Operations].firstLine = 0;								SetGWorld(_windowBuffer, nil);				_DrawList(&_listInfo[kList_Operations]);				SetGWorld(oldGWorld, oldGDHandle);				CopyBits(BMPtrFromGWorld(_windowBuffer), BMPtrFromWindow(window), &_listInfo[kList_Operations].bounds, &_listInfo[kList_Operations].bounds, srcCopy, NULL);			}		}		else {			if(TickCount() > _lastKeyTime + kKeySelectionMaxDelay)			_keyString[0] = 0;			_keyString[++_keyString[0]] = theChar;						if(_listInfo[kList_Operations].numLines) {				newTarget = 0;				operation = _operationListCache;				while(operation) {					if((operation->description[0] >= _keyString[0]) && FastEqualText(_keyString[0], &_keyString[1], &operation->description[1], false)) {						_SetOperationListSelection(newTarget);						break;					}					operation = operation->next;					++newTarget;				}								if(newTarget < _operationListCacheSize) {					newTarget = _listInfo[kList_Operations].selectedNumList[0];					_ScrollListFirstLine(&_listInfo[kList_Operations], newTarget);					SetGWorld(_windowBuffer, nil);					_DrawList(&_listInfo[kList_Operations]);					SetGWorld(oldGWorld, oldGDHandle);					CopyBits(BMPtrFromGWorld(_windowBuffer), BMPtrFromWindow(window), &_listInfo[kList_Operations].bounds, &_listInfo[kList_Operations].bounds, srcCopy, NULL);				}				else				hit = false;			}			else			hit = false;						_lastKeyTime = TickCount();		}		break;				case kFocus_None:		hit = false;		break;			}		//Restore port	SetPort(savePort);		return hit;}void WindowServer::Suspend(){	//Enter suspended state	if(_suspended)	return;		//Reset cursor	_currentCursor = kThemeArrowCursor;	SetThemeCursor(kThemeArrowCursor);		//Clear focus	_saveFocus = userFocus;	_SetFocus(kFocus_None, false);	_suspended = true;	UpdateServerWindow();	_ValidWindow();}void WindowServer::Resume(){	//Exit suspended state	if(!_suspended)	return;		//Set focus	_suspended = false;	_SetFocus(_saveFocus, false);	UpdateServerWindow();	_ValidWindow();		//Set cursor	_currentCursor = kThemeArrowCursor;	SetThemeCursor(_currentCursor);}ColumnInfoPtr WindowServer::_GetColumnFromID(ID id){	long			i;		//Scan account columns	for(i = 0; i < kAccountNumColumns; ++i)	if(_appPrefs->accountsColumns[i].id == id)	return &_appPrefs->accountsColumns[i];		//Scan operation columns	for(i = 0; i < kOperationNumColumns; ++i)	if(_appPrefs->operationsColumns[i].id == id)	return &_appPrefs->operationsColumns[i];		return NULL;}void WindowServer::SetColumnVisibility(ID id, Boolean visible){	ColumnInfoPtr	info;		info = _GetColumnFromID(id);	if(info) {		if(visible && !(info->flags & kColumnFlag_Visible)) {			info->flags |= (kColumnFlag_Visible | kColumnFlag_Displayed);			_InvalidWindow();		}		else if(!visible && (info->flags & kColumnFlag_Visible)) {			info->flags &= ~(kColumnFlag_Visible | kColumnFlag_Displayed);			_InvalidWindow();		}	}}Boolean WindowServer::IsColumnVisible(ID id){	ColumnInfoPtr	info;		info = _GetColumnFromID(id);	if(info && (info->flags & kColumnFlag_Visible))	return true;		return false;}void WindowServer::SetAccountListVisibility(Boolean visible){	if(visible && !(_appPrefs->windowFlags & kWindowFlag_AccountList)) {		_appPrefs->windowFlags |= kWindowFlag_AccountList;		Invalidate();	}	else if(!visible && (_appPrefs->windowFlags & kWindowFlag_AccountList)) {		_appPrefs->windowFlags &= ~kWindowFlag_AccountList;		if(userFocus == kFocus_AccountList)		_SetFocus(kFocus_None, false);		Invalidate();	}}Boolean WindowServer::IsAccountListVisible(){	if(_appPrefs->windowFlags & kWindowFlag_AccountList)	return true;	else	return false;}void WindowServer::Invalidate(ID targetID, long operationCount, ID operationIDList[]){	ListInfoPtr				accountListInfo = &_listInfo[kList_Accounts],							operationListInfo = &_listInfo[kList_Operations];	OperationPtr			operation;	long					i,							index;	Str255					filter;		//Select new target - if any	if(targetID != kUndefinedID) {		index = GetAccountNumFromID(targetID);		if(index != kUndefinedNum) {			accountListInfo->selectedNumList[0] = AccountNumToTargetNum(index);			accountListInfo->numSelectedLines = 1;		}		else {			index = GetFilterNumFromID(targetID);			if(index != kUndefinedNum) {				accountListInfo->selectedNumList[0] = FilterNumToTargetNum(index);				accountListInfo->numSelectedLines = 1;			}			else			return;		}				//Update focus		_SetFocus(kFocus_AccountList, false);	}		//Make sure target is still valid	if(accountListInfo->numSelectedLines && ((accountListInfo->selectedNumList[0] < 0) || (accountListInfo->selectedNumList[0] >= GetTargetNumMax())))	accountListInfo->numSelectedLines = 0;		//Select default target - first unlocked account or filter	if(!accountListInfo->numSelectedLines) {		for(i = 0; i < application->accountCount; ++i)		if(!application->accountList[i]->IsLocked()) {			accountListInfo->selectedNumList[0] = AccountNumToTargetNum(i);			accountListInfo->numSelectedLines = 1;			break;		}		if(!accountListInfo->numSelectedLines) {			for(i = 0; i < application->filterCount; ++i)			if(!application->filterList[i]->IsLocked(application->accountCount, application->accountList)) {				accountListInfo->selectedNumList[0] = FilterNumToTargetNum(i);				accountListInfo->numSelectedLines = 1;				break;			}		}	}		//Rebuild operation cache	_operationListCacheSize = 0;	_operationListCache = NULL;	if(accountListInfo->numSelectedLines) {		//Get operation list & apply filter		_GetFilterText(filter);		if(filter[0]) {			if(TargetNumIsFilter(accountListInfo->selectedNumList[0]))			_operationListCache = application->filterList[TargetNumToFilterNum(accountListInfo->selectedNumList[0])]->BuildOperationLinkedList(application->accountCount, application->accountList, filter);			else			_operationListCache = application->accountList[TargetNumToAccountNum(accountListInfo->selectedNumList[0])]->BuildOperationLinkedList(filter);		}		else {			if(TargetNumIsFilter(accountListInfo->selectedNumList[0]))			_operationListCache = application->filterList[TargetNumToFilterNum(accountListInfo->selectedNumList[0])]->BuildOperationLinkedList(application->accountCount, application->accountList);			else			_operationListCache = application->accountList[TargetNumToAccountNum(accountListInfo->selectedNumList[0])]->BuildOperationLinkedList();		}				//Count operations		operation = _operationListCache;		while(operation != NULL) {			++_operationListCacheSize;			operation = operation->next;		}				//Sort operations		_SortOperationListCache();	}		if(_operationListCache) {		//Select new line if any		if(operationCount && operationIDList) {			if(operationCount > kMaxSelectedLines)			operationCount = kMaxSelectedLines;			for(i = 0; i < operationCount; ++i)			operationListInfo->selectedIDList[i] = operationIDList[i];			operationListInfo->numSelectedLines = operationCount;						//Update focus			_SetFocus(kFocus_OperationList, false);		}				//Make sure target operation IDs are still valid		for(i = 0; i < operationListInfo->numSelectedLines; ++i) {			operation = _operationListCache;			operationListInfo->selectedNumList[i] = kUndefinedNum;			index = 0;			do {				if(operation->id == operationListInfo->selectedIDList[i]) {					operationListInfo->selectedNumList[i] = index;					break;				}				++index;				operation = operation->next;			} while(operation != NULL);			if(operationListInfo->selectedNumList[i] == kUndefinedNum) {				--operationListInfo->numSelectedLines;				operationListInfo->selectedIDList[i] = operationListInfo->selectedIDList[operationListInfo->numSelectedLines];				--i;			}		}	}	else	operationListInfo->numSelectedLines = 0;		//Update account list info	_GetListBounds(kList_Accounts, &accountListInfo->bounds);	accountListInfo->numLines = GetTargetNumMax();	accountListInfo->numVisibleLines = _GetListNumVisibleLines(accountListInfo);	if(accountListInfo->definition->flags & kListFlag_AutoHideScrollBar) {		if(accountListInfo->numLines > accountListInfo->numVisibleLines)		accountListInfo->hasScrollbar = true;		else		accountListInfo->hasScrollbar = false;	}	else	accountListInfo->hasScrollbar = true;	if(accountListInfo->numSelectedLines)	_ScrollListFirstLine(accountListInfo, accountListInfo->selectedNumList[0]);	else	_ScrollListFirstLine(accountListInfo, kUndefinedNum);		//Update operation list info	_GetListBounds(kList_Operations, &operationListInfo->bounds);	operationListInfo->numLines = _operationListCacheSize;	operationListInfo->numVisibleLines = _GetListNumVisibleLines(operationListInfo);	if(operationListInfo->definition->flags & kListFlag_AutoHideScrollBar) {		if(operationListInfo->numLines > operationListInfo->numVisibleLines)		operationListInfo->hasScrollbar = true;		else		operationListInfo->hasScrollbar = false;	}	else	operationListInfo->hasScrollbar = true;	if(accountListInfo->numSelectedLines) {		if(operationCount && operationListInfo->numSelectedLines) {			if(operationListInfo->numSelectedLines >= operationListInfo->numVisibleLines)			operationListInfo->firstLine = GetSelectionMin(operationListInfo);			else {				index = GetSelectionMin(operationListInfo);				i = GetSelectionMax(operationListInfo);				if(index < operationListInfo->firstLine)				operationListInfo->firstLine = index;				else if(i >= operationListInfo->firstLine + operationListInfo->numVisibleLines)				operationListInfo->firstLine = i - operationListInfo->numVisibleLines + 1;			}		}		else {			if(TargetNumIsFilter(accountListInfo->selectedNumList[0]))			operationListInfo->firstLine = application->filterList[TargetNumToFilterNum(accountListInfo->selectedNumList[0])]->data->firstLine;			else			operationListInfo->firstLine = application->accountList[TargetNumToAccountNum(accountListInfo->selectedNumList[0])]->data->firstLine;		}					if(operationListInfo->numLines <= operationListInfo->numVisibleLines)		operationListInfo->firstLine = 0;		else if(operationListInfo->firstLine + operationListInfo->numVisibleLines > operationListInfo->numLines)		operationListInfo->firstLine = operationListInfo->numLines - operationListInfo->numVisibleLines;	}	else	operationListInfo->firstLine = 0;		//Clear note tag	_noteTagOperation = NULL;		//Set account columns visibility	for(i = 0; i < kAccountNumColumns; ++i) {		if(_appPrefs->accountsColumns[i].flags & kColumnFlag_Visible)		_appPrefs->accountsColumns[i].flags |= kColumnFlag_Displayed;		else		_appPrefs->accountsColumns[i].flags &= ~kColumnFlag_Displayed;	}		//Set operation columns visibility	for(i = 0; i < kOperationNumColumns; ++i) {		if(_appPrefs->operationsColumns[i].flags & kColumnFlag_Visible)		_appPrefs->operationsColumns[i].flags |= kColumnFlag_Displayed;		else		_appPrefs->operationsColumns[i].flags &= ~kColumnFlag_Displayed;				if((_appPrefs->operationsColumns[i].id == kOperationColumn_Balance) && TargetNumIsFilter(GetTargetNum()))		_appPrefs->operationsColumns[i].flags &= ~kColumnFlag_Displayed;		else if((_appPrefs->operationsColumns[i].id == kOperationColumn_Account) && TargetNumIsAccount(GetTargetNum()))		_appPrefs->operationsColumns[i].flags &= ~kColumnFlag_Displayed;		else if(_appPrefs->operationsColumns[i].id == kOperationColumn_Note)		_appPrefs->operationsColumns[i].flags &= ~kColumnFlag_Displayed;	}		//Force redraw	_InvalidWindow();}inline void SwitchWithNext(OperationPtr a){	OperationPtr	b = a->next;	OperationPtr	an = a->next,					ap = a->prev,					bn = b->next,					bp = b->prev;		if(b->next)	b->next->prev = a;	if(a->prev)	a->prev->next = b;		a->next = bn;	a->prev = an;	b->next = bp;	b->prev = ap;}void WindowServer::_SortOperationListCache(){	Boolean			increasing = _appPrefs->windowFlags & kWindowFlag_SortIncreasing,					exchanged;	long			i,					j;	OperationPtr	operation;	short			result;				if((_operationListCache == NULL) || !_operationListCacheSize)	return;		if(_operationListCacheSize > kSortingWatchThreshold)	SetThemeCursor(kThemeWatchCursor);		switch(_appPrefs->windowSortingColumn) {				case kOperationColumn_Date: //Sort by Date -> ID		for(i = 0; i < _operationListCacheSize - 1; ++i) {			exchanged = false;			operation = _operationListCache;			for(j = 0; j < _operationListCacheSize - 1 - i; ++j) {				if((operation->date > operation->next->date) 					|| ((operation->date == operation->next->date) && (operation->id > operation->next->id))) {					if(operation == _operationListCache)					_operationListCache = operation->next;					SwitchWithNext(operation);					exchanged = true;				}				else				operation = operation->next;			}			if(!exchanged)			break;		}		if(!increasing)		_ReverseOperationListCache();		break;				case kOperationColumn_Amount: //Sort by Amount -> Date -> ID		for(i = 0; i < _operationListCacheSize - 1; ++i) {			exchanged = false;			operation = _operationListCache;			for(j = 0; j < _operationListCacheSize - 1 - i; ++j) {				if((operation->absoluteAmount > operation->next->absoluteAmount)					|| ((operation->absoluteAmount == operation->next->absoluteAmount) && (operation->date > operation->next->date))					|| ((operation->absoluteAmount == operation->next->absoluteAmount) && (operation->date == operation->next->date) && (operation->id > operation->next->id))) {					if(operation == _operationListCache)					_operationListCache = operation->next;					SwitchWithNext(operation);					exchanged = true;				}				else				operation = operation->next;			}			if(!exchanged)			break;		}		if(!increasing)		_ReverseOperationListCache();		break;				case kOperationColumn_Category: //Sort by Category -> Date -> ID		for(i = 0; i < _operationListCacheSize - 1; ++i) {			exchanged = false;			operation = _operationListCache;			for(j = 0; j < _operationListCacheSize - 1 - i; ++j) {				if(((unsigned long) operation->categoryNum > (unsigned long) operation->next->categoryNum)					|| (((unsigned long) operation->categoryNum == (unsigned long) operation->next->categoryNum) && (operation->date > operation->next->date))					|| (((unsigned long) operation->categoryNum == (unsigned long) operation->next->categoryNum) && (operation->date == operation->next->date) && (operation->id > operation->next->id))) {					if(operation == _operationListCache)					_operationListCache = operation->next;					SwitchWithNext(operation);					exchanged = true;				}				else				operation = operation->next;			}			if(!exchanged)			break;		}		if(!increasing)		_ReverseOperationListCache();		break;				case kOperationColumn_PaymentType: //Sort by Payment -> Date -> ID		for(i = 0; i < _operationListCacheSize - 1; ++i) {			exchanged = false;			operation = _operationListCache;			for(j = 0; j < _operationListCacheSize - 1 - i; ++j) {				if(((unsigned long) operation->paymentTypeNum > (unsigned long) operation->next->paymentTypeNum)					|| (((unsigned long) operation->paymentTypeNum == (unsigned long) operation->next->paymentTypeNum) && (operation->date > operation->next->date))					|| (((unsigned long) operation->paymentTypeNum == (unsigned long) operation->next->paymentTypeNum) && (operation->date == operation->next->date) && (operation->id > operation->next->id))) {					if(operation == _operationListCache)					_operationListCache = operation->next;					SwitchWithNext(operation);					exchanged = true;				}				else				operation = operation->next;			}			if(!exchanged)			break;		}		if(!increasing)		_ReverseOperationListCache();		break;				case kOperationColumn_Balance: //Sort by Balance -> Date -> ID		for(i = 0; i < _operationListCacheSize - 1; ++i) {			exchanged = false;			operation = _operationListCache;			for(j = 0; j < _operationListCacheSize - 1 - i; ++j) {				if((operation->balance > operation->next->balance)					|| ((operation->balance == operation->next->balance) && (operation->date > operation->next->date))					|| ((operation->balance == operation->next->balance) && (operation->date == operation->next->date) && (operation->id > operation->next->id))) {					if(operation == _operationListCache)					_operationListCache = operation->next;					SwitchWithNext(operation);					exchanged = true;				}				else				operation = operation->next;			}			if(!exchanged)			break;		}		if(!increasing)		_ReverseOperationListCache();		break;				case kOperationColumn_Description: //Sort by Description -> Date -> ID		for(i = 0; i < _operationListCacheSize - 1; ++i) {			exchanged = false;			operation = _operationListCache;			for(j = 0; j < _operationListCacheSize - 1 - i; ++j) {				result = FastCompareString(operation->description, operation->next->description);				if((result == 1) 					|| ((result == 0) && (operation->date > operation->next->date))					|| ((result == 0) && (operation->date == operation->next->date) && (operation->id > operation->next->id))) {					if(operation == _operationListCache)					_operationListCache = operation->next;					SwitchWithNext(operation);					exchanged = true;				}				else				operation = operation->next;			}			if(!exchanged)			break;		}		if(!increasing)		_ReverseOperationListCache();		break;				case kOperationColumn_Custom: //Sort by Custom -> Date -> ID		for(i = 0; i < _operationListCacheSize - 1; ++i) {			exchanged = false;			operation = _operationListCache;			for(j = 0; j < _operationListCacheSize - 1 - i; ++j) {				result = FastCompareString(operation->customData, operation->next->customData);				if((result == 1) 					|| ((result == 0) && (operation->date > operation->next->date))					|| ((result == 0) && (operation->date == operation->next->date) && (operation->id > operation->next->id))) {					if(operation == _operationListCache)					_operationListCache = operation->next;					SwitchWithNext(operation);					exchanged = true;				}				else				operation = operation->next;			}			if(!exchanged)			break;		}		if(!increasing)		_ReverseOperationListCache();		break;				case kOperationColumn_Account: //Sort by Account -> Date -> ID		for(i = 0; i < _operationListCacheSize - 1; ++i) {			exchanged = false;			operation = _operationListCache;			for(j = 0; j < _operationListCacheSize - 1 - i; ++j) {				result = FastCompareString(operation->owner->data->name, operation->next->owner->data->name);				if((result == 1)					|| ((result == 0) && (operation->date > operation->next->date))					|| ((result == 0) && (operation->date == operation->next->date) && (operation->id > operation->next->id))) {					if(operation == _operationListCache)					_operationListCache = operation->next;					SwitchWithNext(operation);					exchanged = true;				}				else				operation = operation->next;			}			if(!exchanged)			break;		}		if(!increasing)		_ReverseOperationListCache();		break;				/*case kOperationColumn_Note:		for(i = 0; i < _operationListCacheSize - 1; ++i) {			exchanged = false;			operation = _operationListCache;			for(j = 0; j < _operationListCacheSize - 1; ++j) {				result = FastCompareString(operation->note, operation->next->note);				if((result == 1) || ((result == 0) && (operation->id > operation->next->id))) {					if(operation == _operationListCache)					_operationListCache = operation->next;					SwitchWithNext(operation);					exchanged = true;				}				else				operation = operation->next;			}			if(!exchanged)			break;		}		if(!increasing)		_ReverseOperationListCache();		break;*/				case kOperationColumn_Income: //Sort by Is expense -> Amount -> Date -> ID		if(increasing)		for(i = 0; i < _operationListCacheSize - 1; ++i) {			exchanged = false;			operation = _operationListCache;			for(j = 0; j < _operationListCacheSize - 1; ++j) {				if(((operation->flags & kOperationFlag_Expense) && !(operation->next->flags & kOperationFlag_Expense))					|| (((operation->flags & kOperationFlag_Expense) && (operation->next->flags & kOperationFlag_Expense)) && ((operation->amount > operation->next->amount) || ((operation->amount == operation->next->amount) && (operation->date > operation->next->date))))					|| (((operation->flags & kOperationFlag_Expense) && (operation->next->flags & kOperationFlag_Expense)) && ((operation->amount > operation->next->amount) || ((operation->amount == operation->next->amount) && (operation->date == operation->next->date) && (operation->id > operation->next->id))))					|| ((!(operation->flags & kOperationFlag_Expense) && !(operation->next->flags & kOperationFlag_Expense)) && ((operation->amount > operation->next->amount) || ((operation->amount == operation->next->amount) && (operation->date > operation->next->date))))					|| ((!(operation->flags & kOperationFlag_Expense) && !(operation->next->flags & kOperationFlag_Expense)) && ((operation->amount > operation->next->amount) || ((operation->amount == operation->next->amount) && (operation->date == operation->next->date) && (operation->id > operation->next->id))))) {					if(operation == _operationListCache)					_operationListCache = operation->next;					SwitchWithNext(operation);					exchanged = true;				}				else				operation = operation->next;			}			if(!exchanged)			break;		}		else		for(i = 0; i < _operationListCacheSize - 1; ++i) {			exchanged = false;			operation = _operationListCache;			for(j = 0; j < _operationListCacheSize - 1; ++j) {				if(((operation->flags & kOperationFlag_Expense) && !(operation->next->flags & kOperationFlag_Expense))					|| (((operation->flags & kOperationFlag_Expense) && (operation->next->flags & kOperationFlag_Expense)) && ((operation->amount < operation->next->amount) || ((operation->amount == operation->next->amount) && (operation->date < operation->next->date))))					|| (((operation->flags & kOperationFlag_Expense) && (operation->next->flags & kOperationFlag_Expense)) && ((operation->amount < operation->next->amount) || ((operation->amount == operation->next->amount) && (operation->date == operation->next->date) && (operation->id < operation->next->id))))					|| ((!(operation->flags & kOperationFlag_Expense) && !(operation->next->flags & kOperationFlag_Expense)) && ((operation->amount < operation->next->amount) || ((operation->amount == operation->next->amount) && (operation->date < operation->next->date))))					|| ((!(operation->flags & kOperationFlag_Expense) && !(operation->next->flags & kOperationFlag_Expense)) && ((operation->amount < operation->next->amount) || ((operation->amount == operation->next->amount) && (operation->date == operation->next->date) && (operation->id < operation->next->id))))) {					if(operation == _operationListCache)					_operationListCache = operation->next;					SwitchWithNext(operation);					exchanged = true;				}				else				operation = operation->next;			}			if(!exchanged)			break;		}		break;				case kOperationColumn_Expense: //Sort by Is expense -> Amount -> Date -> ID		if(increasing)		for(i = 0; i < _operationListCacheSize - 1; ++i) {			exchanged = false;			operation = _operationListCache;			for(j = 0; j < _operationListCacheSize - 1; ++j) {				if((!(operation->flags & kOperationFlag_Expense) && (operation->next->flags & kOperationFlag_Expense))					|| (((operation->flags & kOperationFlag_Expense) && (operation->next->flags & kOperationFlag_Expense)) && ((operation->amount > operation->next->amount) || ((operation->amount == operation->next->amount) && (operation->date > operation->next->date))))					|| (((operation->flags & kOperationFlag_Expense) && (operation->next->flags & kOperationFlag_Expense)) && ((operation->amount > operation->next->amount) || ((operation->amount == operation->next->amount) && (operation->date == operation->next->date) && (operation->id > operation->next->id))))					|| ((!(operation->flags & kOperationFlag_Expense) && !(operation->next->flags & kOperationFlag_Expense)) && ((operation->amount > operation->next->amount) || ((operation->amount == operation->next->amount) && (operation->date > operation->next->date))))					|| ((!(operation->flags & kOperationFlag_Expense) && !(operation->next->flags & kOperationFlag_Expense)) && ((operation->amount > operation->next->amount) || ((operation->amount == operation->next->amount) && (operation->date == operation->next->date) && (operation->id > operation->next->id))))) {					if(operation == _operationListCache)					_operationListCache = operation->next;					SwitchWithNext(operation);					exchanged = true;				}				else				operation = operation->next;			}			if(!exchanged)			break;		}		else		for(i = 0; i < _operationListCacheSize - 1; ++i) {			exchanged = false;			operation = _operationListCache;			for(j = 0; j < _operationListCacheSize - 1; ++j) {				if((!(operation->flags & kOperationFlag_Expense) && (operation->next->flags & kOperationFlag_Expense))					|| (((operation->flags & kOperationFlag_Expense) && (operation->next->flags & kOperationFlag_Expense)) && ((operation->amount < operation->next->amount) || ((operation->amount == operation->next->amount) && (operation->date < operation->next->date))))					|| (((operation->flags & kOperationFlag_Expense) && (operation->next->flags & kOperationFlag_Expense)) && ((operation->amount < operation->next->amount) || ((operation->amount == operation->next->amount) && (operation->date == operation->next->date) && (operation->id < operation->next->id))))					|| ((!(operation->flags & kOperationFlag_Expense) && !(operation->next->flags & kOperationFlag_Expense)) && ((operation->amount < operation->next->amount) || ((operation->amount == operation->next->amount) && (operation->date < operation->next->date))))					|| ((!(operation->flags & kOperationFlag_Expense) && !(operation->next->flags & kOperationFlag_Expense)) && ((operation->amount < operation->next->amount) || ((operation->amount == operation->next->amount) && (operation->date == operation->next->date) && (operation->id < operation->next->id))))) {					if(operation == _operationListCache)					_operationListCache = operation->next;					SwitchWithNext(operation);					exchanged = true;				}				else				operation = operation->next;			}			if(!exchanged)			break;		}		break;				case kOperationColumn_Checked: //Sort by Checked -> Date -> ID		for(i = 0; i < _operationListCacheSize - 1; ++i) {			exchanged = false;			operation = _operationListCache;			for(j = 0; j < _operationListCacheSize - 1 - i; ++j) {				if(((operation->flags & kOperationFlag_Checked) && !(operation->next->flags & kOperationFlag_Checked))					|| (((operation->flags & kOperationFlag_Checked) && (operation->next->flags & kOperationFlag_Checked)) && (operation->date > operation->next->date))					|| (((operation->flags & kOperationFlag_Checked) && (operation->next->flags & kOperationFlag_Checked)) && (operation->date == operation->next->date) && (operation->id > operation->next->id))					|| ((!(operation->flags & kOperationFlag_Checked) && !(operation->next->flags & kOperationFlag_Checked)) && (operation->date > operation->next->date))					|| ((!(operation->flags & kOperationFlag_Checked) && !(operation->next->flags & kOperationFlag_Checked)) && (operation->date == operation->next->date) && (operation->id > operation->next->id))) {					if(operation == _operationListCache)					_operationListCache = operation->next;					SwitchWithNext(operation);					exchanged = true;				}				else				operation = operation->next;			}			if(!exchanged)			break;		}		if(!increasing)		_ReverseOperationListCache();		break;				case kOperationColumn_Warning: //Sort by Warning -> Date -> ID		for(i = 0; i < _operationListCacheSize - 1; ++i) {			exchanged = false;			operation = _operationListCache;			for(j = 0; j < _operationListCacheSize - 1 - i; ++j) {				if(((operation->flags & kOperationFlag_Warning) && !(operation->next->flags & kOperationFlag_Warning))					|| (((operation->flags & kOperationFlag_Warning) && (operation->next->flags & kOperationFlag_Warning)) && (operation->date > operation->next->date))					|| (((operation->flags & kOperationFlag_Warning) && (operation->next->flags & kOperationFlag_Warning)) && (operation->date == operation->next->date) && (operation->id > operation->next->id))					|| ((!(operation->flags & kOperationFlag_Warning) && !(operation->next->flags & kOperationFlag_Warning)) && (operation->date > operation->next->date))					|| ((!(operation->flags & kOperationFlag_Warning) && !(operation->next->flags & kOperationFlag_Warning)) && (operation->date == operation->next->date) && (operation->id > operation->next->id))) {					if(operation == _operationListCache)					_operationListCache = operation->next;					SwitchWithNext(operation);					exchanged = true;				}				else				operation = operation->next;			}			if(!exchanged)			break;		}		if(!increasing)		_ReverseOperationListCache();		break;			}			if(_operationListCacheSize > kSortingWatchThreshold)	SetThemeCursor(kThemeArrowCursor);}void WindowServer::_RefreshOperationListSelection(){	ListInfoPtr		operationListInfo = &_listInfo[kList_Operations];	OperationPtr	operation;	long			i,					index;		if((_operationListCache == NULL) || !_operationListCacheSize)	return;		//Update selection	for(i = 0; i < operationListInfo->numSelectedLines; ++i) {		operation = _operationListCache;		operationListInfo->selectedNumList[i] = kUndefinedNum;		index = 0;		do {			if(operation->id == operationListInfo->selectedIDList[i]) {				operationListInfo->selectedNumList[i] = index;				break;			}			++index;			operation = operation->next;		} while(operation != NULL);	}}void WindowServer::_ReverseOperationListCache(){	OperationPtr	operation,					temp;		if((_operationListCache == NULL) || !_operationListCacheSize)	return;		//Switch linked list	if((_appPrefs->windowSortingColumn == kOperationColumn_Income) || (_appPrefs->windowSortingColumn == kOperationColumn_Expense))	_SortOperationListCache();	else {		operation = _operationListCache;		while(operation) {			temp = operation->next;			operation->next = operation->prev;			operation->prev = temp;						if(operation->prev == NULL)			_operationListCache = operation;			operation = operation->prev;		}	}}void WindowServer::_SetFocus(long newFocus, Boolean redraw){	GWorldPtr			oldGWorld;	GDHandle			oldGDHandle;	Rect				theRect;	long				oldFocus = userFocus;		//Save GWorld	GetGWorld(&oldGWorld, &oldGDHandle);		//Set focus	if(_suspended) {		_saveFocus = newFocus;		return;	}	userFocus = newFocus;		//Clear note tag	_noteTagOperation = NULL;		//Deactivate old focus	switch(oldFocus) {				case kFocus_Filter:		TEDeactivate(_filterTE);		if(redraw) {			SetGWorld(_windowBuffer, nil);			_DrawSkinImage(kSkinImage_Filter);			SetGWorld(oldGWorld, oldGDHandle);			_GetSkinImageRect(kSkinImage_Filter, &theRect);			CopyBits(BMPtrFromGWorld(_windowBuffer), BMPtrFromWindow(window), &theRect, &theRect, srcCopy, NULL);			_DrawFilterTE();		}		break;				case kFocus_AccountList:		_listInfo[kList_Accounts].active = false;		if(redraw && (_appPrefs->windowFlags & kWindowFlag_AccountList)) {			SetGWorld(_windowBuffer, nil);			_DrawListFrame(&_listInfo[kList_Accounts]);			_DrawList(&_listInfo[kList_Accounts]);			SetGWorld(oldGWorld, oldGDHandle);			_GetListWithFrameBounds(kList_Accounts, _listInfo[kList_Accounts].active, &theRect);			CopyBits(BMPtrFromGWorld(_windowBuffer), BMPtrFromWindow(window), &theRect, &theRect, srcCopy, NULL);		}		break;				case kFocus_OperationList:		_listInfo[kList_Operations].active = false;		if(redraw) {			SetGWorld(_windowBuffer, nil);			_DrawListFrame(&_listInfo[kList_Operations]);			_DrawList(&_listInfo[kList_Operations]);			SetGWorld(oldGWorld, oldGDHandle);			_GetListWithFrameBounds(kList_Operations, _listInfo[kList_Operations].active, &theRect);			CopyBits(BMPtrFromGWorld(_windowBuffer), BMPtrFromWindow(window), &theRect, &theRect, srcCopy, NULL);		}		break;			}		//Activate new focus	switch(userFocus) {				case kFocus_Filter:		TEActivate(_filterTE);		if(redraw) {			SetGWorld(_windowBuffer, nil);			_DrawSkinImage(kSkinImage_FilterSelected);			SetGWorld(oldGWorld, oldGDHandle);			_GetSkinImageRect(kSkinImage_FilterSelected, &theRect);			CopyBits(BMPtrFromGWorld(_windowBuffer), BMPtrFromWindow(window), &theRect, &theRect, srcCopy, NULL);			_DrawFilterTE();		}		break;				case kFocus_AccountList:		_listInfo[kList_Accounts].active = true;		if(redraw && (_appPrefs->windowFlags & kWindowFlag_AccountList)) {			SetGWorld(_windowBuffer, nil);			_DrawListFrame(&_listInfo[kList_Accounts]);			_DrawList(&_listInfo[kList_Accounts]);			SetGWorld(oldGWorld, oldGDHandle);			_GetListWithFrameBounds(kList_Accounts, _listInfo[kList_Accounts].active, &theRect);			CopyBits(BMPtrFromGWorld(_windowBuffer), BMPtrFromWindow(window), &theRect, &theRect, srcCopy, NULL);		}		break;				case kFocus_OperationList:		_listInfo[kList_Operations].active = true;		if(redraw) {			SetGWorld(_windowBuffer, nil);			_DrawListFrame(&_listInfo[kList_Operations]);			_DrawList(&_listInfo[kList_Operations]);			SetGWorld(oldGWorld, oldGDHandle);			_GetListWithFrameBounds(kList_Operations, _listInfo[kList_Operations].active, &theRect);			CopyBits(BMPtrFromGWorld(_windowBuffer), BMPtrFromWindow(window), &theRect, &theRect, srcCopy, NULL);		}		break;			}		//Update magic button	if(redraw) {		SetGWorld(_windowBuffer, nil);		switch(_GetMagicButtonMode()) {						case kMagicButtonMode_NewAccount:			_DrawSkinImage(kSkinButton_Magic_NewAccount);			_GetSkinImageRect(kMagicButtonMode_NewAccount, &theRect);			break;						case kMagicButtonMode_NewOperation:			_DrawSkinImage(kSkinButton_Magic_NewOperation);			_GetSkinImageRect(kSkinButton_Magic_NewOperation, &theRect);			break;						case kMagicButtonMode_Print:			_DrawSkinImage(kSkinButton_Magic_Print);			_GetSkinImageRect(kSkinButton_Magic_Print, &theRect);			break;					}		SetGWorld(oldGWorld, oldGDHandle);		CopyBits(BMPtrFromGWorld(_windowBuffer), BMPtrFromWindow(window), &theRect, &theRect, srcCopy, NULL);	}}void WindowServer::Copy(){	OperationListPtr	cache;	long				cacheSize,						i;	OperationPtr		operation;#if TARGET_API_MAC_CARBON	ScrapRef			theScrap;#endif		switch(userFocus) {				case kFocus_OperationList:		if(!_listInfo[kList_Operations].numSelectedLines)		break;		cacheSize = sizeof(OperationList) + _listInfo[kList_Operations].numSelectedLines * sizeof(Operation);		cache = (OperationListPtr) NewPtr(cacheSize);		if(cache == NULL)		break;		cache->count = 0;		cache->bufferCount = _listInfo[kList_Operations].numSelectedLines;		for(i = 0; i < _listInfo[kList_Operations].numSelectedLines; ++i) {			operation = _GetOperationFromAbsoluteNum(_listInfo[kList_Operations].selectedNumList[i]);			if(operation) {				cache->list[cache->count] = *operation;				++cache->count;			}		}#if TARGET_API_MAC_CARBON		if(ClearCurrentScrap() == noErr) {			if(GetCurrentScrap(&theScrap) == noErr)			PutScrapFlavor(theScrap, kOperationListResType, kScrapFlavorMaskNone, cacheSize, cache);		}#else		if(ZeroScrap() == noErr)		PutScrap(cacheSize, kOperationListResType, cache);#endif		DisposePtr((Ptr) cache);		break;				case kFocus_Filter:		TECopy(_filterTE);		break;			}}Boolean WindowServer::ClipBoardContentValid(){#if TARGET_API_MAC_CARBON	ScrapRef			theScrap;	ScrapFlavorFlags	flags;#else	long				offset;#endif#if TARGET_API_MAC_CARBON	if(GetCurrentScrap(&theScrap) != noErr)	return false;	if(GetScrapFlavorFlags(theScrap, kOperationListResType, &flags) != noErr)	return false;#else	if(GetScrap(NULL, kOperationListResType, &offset) <= 0)	return false;#endif	return true;}void WindowServer::Paste(){	long				targetNum = GetTargetNum();	long				selectedIDCount = 0;	ID					selectedIDList[kMaxSelectedLines];	long				size,						i;	OperationListPtr	cache;#if TARGET_API_MAC_CARBON	ScrapRef			theScrap;#else	long				offset;	Handle				temp;#endif		switch(userFocus) {				case kFocus_OperationList:#if !__DEMO__ && !__DEBUG__		if(!SNValid(appPrefs->serialNumber, kSNMagic))		break;#endif		if(TargetNumIsFilter(targetNum))		break;#if TARGET_API_MAC_CARBON		if(GetCurrentScrap(&theScrap) != noErr)		break;		if(GetScrapFlavorSize(theScrap, kOperationListResType, &size) != noErr)		break;		cache = (OperationListPtr) NewPtr(size);		if(cache == NULL)		break;		if(GetScrapFlavorData(theScrap, kOperationListResType, &size, cache) == noErr) {			for(i = 0; i < cache->count; ++i)			if(application->accountList[TargetNumToAccountNum(targetNum)]->AddOperation(&cache->list[i])) {				selectedIDList[selectedIDCount] = cache->list[i].id;				++selectedIDCount;			}			if(selectedIDCount) {				Invalidate(kUndefinedID, selectedIDCount, selectedIDList);				if(appPrefs->flags & kPreferencesFlag_AutoSave)				application->WriteAccountToDisk(application->accountList[TargetNumToAccountNum(targetNum)]);			}		}		DisposePtr((Ptr) cache);#else		temp = NewHandle(0);		if(temp == NULL)		break;		size = GetScrap(temp, kOperationListResType, &offset);		if(size > 0) {			HLock(temp);			cache = (OperationListPtr) *temp;			for(i = 0; i < cache->count; ++i)			if(application->accountList[TargetNumToAccountNum(targetNum)]->AddOperation(&cache->list[i])) {				selectedIDList[selectedIDCount] = cache->list[i].id;				++selectedIDCount;			}			if(selectedIDCount) {				Invalidate(kUndefinedID, selectedIDCount, selectedIDList);				if(appPrefs->flags & kPreferencesFlag_AutoSave)				application->WriteAccountToDisk(application->accountList[TargetNumToAccountNum(targetNum)]);			}		}		DisposeHandle(temp);#endif		break;				case kFocus_Filter:		TEPaste(_filterTE);		Invalidate();		break;			}}void WindowServer::Cut(){	switch(userFocus) {				case kFocus_OperationList:		if(!_listInfo[kList_Operations].numSelectedLines)		break;		Copy();		application->commandServer->Execute(kCommand_DeleteOperation);		break;				case kFocus_Filter:		TECut(_filterTE);		Invalidate();		break;			}}void WindowServer::Duplicate(){	long			targetNum = GetTargetNum();	long			selectedIDCount = 0;	ID				selectedIDList[kMaxSelectedLines];	Operation		operation;	OperationPtr	temp;	Str31			text;	long			i;		switch(userFocus) {				case kFocus_OperationList:		if(TargetNumIsFilter(targetNum))		break;		for(i = 0; i < _listInfo[kList_Operations].numSelectedLines; ++i) {			temp = _GetOperationFromAbsoluteNum(_listInfo[kList_Operations].selectedNumList[i]);			if(temp) {				operation = *temp;				XGetIndString(text, kMiscStringResID, 16);				if(!StringInString(operation.description, text) && (operation.description[0] + text[0] < 63))				AppendString(operation.description, text);				if(application->accountList[TargetNumToAccountNum(targetNum)]->AddOperation(&operation)) {					selectedIDList[selectedIDCount] = operation.id;					++selectedIDCount;				}			}		}		if(selectedIDCount) {			Invalidate(kUndefinedID, selectedIDCount, selectedIDList);			if(appPrefs->flags & kPreferencesFlag_AutoSave)			application->WriteAccountToDisk(application->accountList[TargetNumToAccountNum(targetNum)]);		}		break;			}}short WindowServer::GetSkinAboutResID(){	return (**_skinDef).skinDLOGResID;}long WindowServer::GetTargetNum(){	if(_listInfo[kList_Accounts].numSelectedLines)	return _listInfo[kList_Accounts].selectedNumList[0];		return kUndefinedNum;}long WindowServer::_GetMagicButtonMode(){	//Check for new account mode	if(!application->accountCount)	return kMagicButtonMode_NewAccount;		//Check for print mode	if(_operationListCacheSize) {		if(userFocus == kFocus_AccountList)		return kMagicButtonMode_Print;		if(TargetNumIsFilter(GetTargetNum()))		return kMagicButtonMode_Print;	}		//Default: new operation mode	return kMagicButtonMode_NewOperation;}void WindowServer::_DrawScrollBarBody(Rect* bounds, long num, long mode, Boolean hasAlpha){	Rect				sourceRect,						copyRect;	Point				tempSize,						tempDest;							//Set source rect	sourceRect.left = (**_scrollBar).images[num].modes[mode].h;	sourceRect.right = sourceRect.left + (**_scrollBar).width;	sourceRect.top = (**_scrollBar).images[num].modes[mode].v;	sourceRect.bottom = sourceRect.top + (**_scrollBar).images[num].height;		//Set dest rect	copyRect.left = bounds->left;	copyRect.right = bounds->right;	switch(num) {		case kScrollBarPart_ArrowUp: copyRect.top = bounds->top; break;		case kScrollBarPart_ArrowDown: copyRect.top = bounds->bottom - (**_scrollBar).images[kScrollBarPart_ArrowDown].height; break;				case kScrollBarPart_BodyTop: copyRect.top = bounds->top + (**_scrollBar).images[kScrollBarPart_ArrowUp].height; break;		case kScrollBarPart_BodyMiddle: copyRect.top = bounds->top + (**_scrollBar).images[kScrollBarPart_ArrowUp].height + (**_scrollBar).images[kScrollBarPart_BodyTop].height; break;		case kScrollBarPart_BodyBottom: copyRect.top = bounds->bottom - (**_scrollBar).images[kScrollBarPart_ArrowDown].height - (**_scrollBar).images[kScrollBarPart_BodyBottom].height; break;				default: return; break;	}		//Draw image	if(num == kScrollBarPart_BodyMiddle) {		tempSize.h = copyRect.right - copyRect.left;		tempSize.v = (**_scrollBar).images[kScrollBarPart_BodyMiddle].height;		tempDest.h = copyRect.left;		tempDest.v = copyRect.top;		_DrawImageRepeatV((**_scrollBar).images[kScrollBarPart_BodyMiddle].modes[mode], tempSize, tempDest, bounds->bottom - bounds->top - (**_scrollBar).images[kScrollBarPart_ArrowUp].height - (**_scrollBar).images[kScrollBarPart_ArrowDown].height - (**_scrollBar).images[kScrollBarPart_BodyTop].height - (**_scrollBar).images[kScrollBarPart_BodyBottom].height, hasAlpha, false);	}	else {		copyRect.bottom = copyRect.top + (**_scrollBar).images[num].height;				if(hasAlpha)		CopyDeepMask(BMPtrFromGWorld(_windowImage), BMPtrFromGWorld(_windowAlpha), BMPtrFromGWorld(_windowBuffer), &sourceRect, &sourceRect, &copyRect, srcCopy, NULL);		else		CopyBits(BMPtrFromGWorld(_windowImage), BMPtrFromGWorld(_windowBuffer), &sourceRect, &copyRect, srcCopy, NULL);	}}void WindowServer::_DrawScrollBarThumb(Rect* bounds, long num, long mode, Boolean hasAlpha){	short				middleHeight = bounds->bottom - bounds->top - (**_scrollBar).images[kScrollBarPart_ThumbTop].height - (**_scrollBar).images[kScrollBarPart_ThumbBottom].height;	Rect				sourceRect,						copyRect;	Point				tempSize,						tempDest;							//Set source rect	sourceRect.left = (**_scrollBar).images[num].modes[mode].h;	sourceRect.right = sourceRect.left + (**_scrollBar).width;	sourceRect.top = (**_scrollBar).images[num].modes[mode].v;	sourceRect.bottom = sourceRect.top + (**_scrollBar).images[num].height;		//Set dest rect	copyRect.left = bounds->left;	copyRect.right = bounds->right;	switch(num) {		case kScrollBarPart_ThumbTop: copyRect.top = bounds->top; break;		case kScrollBarPart_ThumbMiddle: copyRect.top = bounds->top + (**_scrollBar).images[kScrollBarPart_ThumbTop].height; break;		case kScrollBarPart_ThumbBottom: copyRect.top = bounds->bottom - (**_scrollBar).images[kScrollBarPart_ThumbBottom].height; break;		case kScrollBarPart_ThumbMark: copyRect.top = bounds->top + (**_scrollBar).images[kScrollBarPart_ThumbTop].height + middleHeight / 2.0 - (**_scrollBar).images[kScrollBarPart_ThumbMark].height / 2.0; break;				default: return; break;	}		//Draw image	if(num == kScrollBarPart_ThumbMiddle) {		tempSize.h = copyRect.right - copyRect.left;		tempSize.v = (**_scrollBar).images[kScrollBarPart_ThumbMiddle].height;		tempDest.h = copyRect.left;		tempDest.v = copyRect.top;		_DrawImageRepeatV((**_scrollBar).images[kScrollBarPart_ThumbMiddle].modes[mode], tempSize, tempDest, middleHeight, hasAlpha, false);	}	else {		copyRect.bottom = copyRect.top + (**_scrollBar).images[num].height;				if(hasAlpha)		CopyDeepMask(BMPtrFromGWorld(_windowImage), BMPtrFromGWorld(_windowAlpha), BMPtrFromGWorld(_windowBuffer), &sourceRect, &sourceRect, &copyRect, srcCopy, NULL);		else		CopyBits(BMPtrFromGWorld(_windowImage), BMPtrFromGWorld(_windowBuffer), &sourceRect, &copyRect, srcCopy, NULL);	}}void WindowServer::_GetListScrollBarBounds(ListInfoPtr list, Rect* bounds){	bounds->left = list->bounds.right - (**_scrollBar).width;	bounds->right = list->bounds.right;	bounds->top = list->bounds.top + list->definition->headerImageSize.v;	bounds->bottom = list->bounds.bottom;}void WindowServer::_GetListScrollBarThumbBounds(ListInfoPtr list, Rect* bounds){	long				value = list->firstLine,						max = list->numLines - list->numVisibleLines;	short				minHeight = (**_scrollBar).images[kScrollBarPart_ThumbTop].height + (**_scrollBar).images[kScrollBarPart_ThumbBottom].height;	Rect				thumbAreaRect;		if((**_scrollBar).flags & kScrollBarFlag_HasThumbMark)	minHeight += (**_scrollBar).images[kScrollBarPart_ThumbMark].height;		_GetListScrollBarBounds(list, &thumbAreaRect);	thumbAreaRect.top += (**_scrollBar).images[kScrollBarPart_ArrowUp].height;	thumbAreaRect.bottom -= (**_scrollBar).images[kScrollBarPart_ArrowDown].height;		bounds->left = thumbAreaRect.left;	bounds->right = thumbAreaRect.right;	if(thumbAreaRect.bottom - thumbAreaRect.top - max * (**_scrollBar).step < minHeight) {		bounds->top = thumbAreaRect.top + (float) (thumbAreaRect.bottom - thumbAreaRect.top - minHeight) * (float) value / (float) max;		bounds->bottom = bounds->top + minHeight;	}	else {		bounds->top = thumbAreaRect.top + value * (**_scrollBar).step;		bounds->bottom = thumbAreaRect.bottom - (max - value) * (**_scrollBar).step;	}}void WindowServer::_DrawListScrollBar(long barMode, ListInfoPtr list, Boolean eraseBackground){	Rect				barRect;	long				imageMode;		//Find scrollbar rect	_GetListScrollBarBounds(list, &barRect);			//Erase background	if(eraseBackground && ((**_scrollBar).flags & (kScrollBarFlag_ArrowUseAlpha | kScrollBarFlag_BodyUseAlpha | kScrollBarFlag_ThumbUseAlpha))) {		//Clip drawing to scrollbar		GetClip(_saveClip);		ClipRect(&barRect);				//Draw lines		_DrawListLines(list, true);				//Restore clip		SetClip(_saveClip);	}		//Draw body	switch(barMode) {				case kScrollBarMode_Inactive:		imageMode = kScrollBarImageMode_Inactive;		break;				case kScrollBarMode_Off:		imageMode = kScrollBarImageMode_Off;		break;				case kScrollBarMode_Disabled:		imageMode = kScrollBarImageMode_Disabled;		break;				case kScrollBarMode_ArrowUp:		_DrawScrollBarBody(&barRect, kScrollBarPart_ArrowUp, kScrollBarImageMode_Active, (**_scrollBar).flags & kScrollBarFlag_ArrowUseAlpha);		imageMode = kScrollBarImageMode_Inactive;		break;				case kScrollBarMode_ArrowDown:		_DrawScrollBarBody(&barRect, kScrollBarPart_ArrowDown, kScrollBarImageMode_Active, (**_scrollBar).flags & kScrollBarFlag_ArrowUseAlpha);		imageMode = kScrollBarImageMode_Inactive;		break;				case kScrollBarMode_Thumb:		imageMode = kScrollBarImageMode_Inactive;		break;			}	if(barMode != kScrollBarMode_ArrowUp)	_DrawScrollBarBody(&barRect, kScrollBarPart_ArrowUp, imageMode, (**_scrollBar).flags & kScrollBarFlag_ArrowUseAlpha);	if(barMode != kScrollBarMode_ArrowDown)	_DrawScrollBarBody(&barRect, kScrollBarPart_ArrowDown, imageMode, (**_scrollBar).flags & kScrollBarFlag_ArrowUseAlpha);	_DrawScrollBarBody(&barRect, kScrollBarPart_BodyTop, imageMode, (**_scrollBar).flags & kScrollBarFlag_BodyUseAlpha);	_DrawScrollBarBody(&barRect, kScrollBarPart_BodyMiddle, imageMode, (**_scrollBar).flags & kScrollBarFlag_BodyUseAlpha);	_DrawScrollBarBody(&barRect, kScrollBarPart_BodyBottom, imageMode, (**_scrollBar).flags & kScrollBarFlag_BodyUseAlpha);		//Draw thumb	if(barMode != kScrollBarMode_Disabled) {		_GetListScrollBarThumbBounds(list, &barRect);				switch(barMode) {						case kScrollBarMode_Inactive:			imageMode = kScrollBarImageMode_Inactive;			break;						case kScrollBarMode_Off:			imageMode = kScrollBarImageMode_Off;			break;						case kScrollBarMode_Disabled:			imageMode = kScrollBarImageMode_Disabled;			break;						case kScrollBarMode_Thumb:			imageMode = kScrollBarImageMode_Active;			break;				}				_DrawScrollBarThumb(&barRect, kScrollBarPart_ThumbTop, imageMode, (**_scrollBar).flags & kScrollBarFlag_ThumbUseAlpha);		_DrawScrollBarThumb(&barRect, kScrollBarPart_ThumbMiddle, imageMode, (**_scrollBar).flags & kScrollBarFlag_ThumbUseAlpha);		_DrawScrollBarThumb(&barRect, kScrollBarPart_ThumbBottom, imageMode, (**_scrollBar).flags & kScrollBarFlag_ThumbUseAlpha);		if((**_scrollBar).flags & kScrollBarFlag_HasThumbMark)		_DrawScrollBarThumb(&barRect, kScrollBarPart_ThumbMark, imageMode, (**_scrollBar).flags & kScrollBarFlag_ThumbUseAlpha);	}}void WindowServer::_ScrollListFirstLine(ListInfoPtr list, long targetLine){	if(list->numLines <= list->numVisibleLines)	list->firstLine = 0;	else {		if(targetLine != kUndefinedNum) {			if(targetLine < list->firstLine)			list->firstLine = targetLine;			else if(targetLine >= list->firstLine + list->numVisibleLines)			list->firstLine = targetLine - list->numVisibleLines + 1;		}		if(list->firstLine + list->numVisibleLines > list->numLines)		list->firstLine = list->numLines - list->numVisibleLines;		if(list->firstLine < 0)		list->firstLine = 0;	}}OperationPtr WindowServer::GetOperationCacheList(){	return _operationListCache;}long WindowServer::GetOperationsSelectionSize(){	return _listInfo[kList_Operations].numSelectedLines;}OperationSelectionPtr WindowServer::GetOperationSelection(){	ListInfoPtr				list = &_listInfo[kList_Operations];	long					i;	OperationPtr			operation;		_operationSelectionCache.count = 0;	for(i = 0; i < list->numSelectedLines; ++i) {		operation = _GetOperationFromAbsoluteNum(list->selectedNumList[i]);		if(operation) {			_operationSelectionCache.owner[_operationSelectionCache.count] = operation->owner;			_operationSelectionCache.id[_operationSelectionCache.count] = operation->id;			_operationSelectionCache.operation[_operationSelectionCache.count] = operation;						++_operationSelectionCache.count;		}	}		return &_operationSelectionCache;}