/***************************************************************************** * Copyright (c) 1999-2002, Pierre-Olivier Latour * http://www.pol-online.net * info@pol-online.net * * This program is free software; you can redistribute it and/or modify * it under the terms of the GNU General Public License as published by * the Free Software Foundation; either version 2 of the License, or * (at your option) any later version. *  * This program is distributed in the hope that it will be useful, * but WITHOUT ANY WARRANTY; without even the implied warranty of * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the * GNU General Public License for more details. * * You should have received a copy of the GNU General Public License * along with this program; if not, write to the Free Software * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111, USA. *****************************************************************************/#include			"Application.h"#include			"Utils.h"#include			"Preferences.h"//CONSTANTS:#define				kFatalInitStringTableResID		128#define				kIconFileName					"\pIcon\r"#define				kIconFileCreator				'MACS'#define				kIconFileType					'icon'#define				kIconFileDataResType			'data'#define				kTempPrefixFileName				"\p_Temp_"#define				kDefaultWindowSizeH				620#define				kDefaultWindowSizeV				440#define				kStringResType					'STR#'//VARIABLES:unsigned char		sortingTable[kCharSortingTableSize];//ROUTINES:OSErr GetFolderNameFromID(short vRefNum, long folderID, Str255 name){	DirInfo				info;	OSErr				theError;		info.ioCompletion = NULL;	info.ioNamePtr = name;	info.ioVRefNum = vRefNum;	info.ioFDirIndex = -1;	info.ioDrDirID = folderID;		theError = PBGetCatInfo((CInfoPBRec*) &info, false);	if(theError)	name[0] = 0;		return theError;}Boolean FolderExists(short vRefNum, long folderID){	DirInfo				info;	Str255				name;		info.ioCompletion = NULL;	info.ioNamePtr = name;	info.ioVRefNum = vRefNum;	info.ioFDirIndex = -1;	info.ioDrDirID = folderID;		if(PBGetCatInfo((CInfoPBRec*) &info, false))	return false;		return true;}#if __DEMO__OSErr GetDefaultAccountFolder(FSSpec* folder){	OSErr				theError;	Str255				name;	ProcessSerialNumber	psn;	ProcessInfoRec		pInfo;	DirInfo				info;		//Get process info	theError = GetCurrentProcess(&psn);	if(theError)	return theError;	//Find current application folder	pInfo.processInfoLength = sizeof(ProcessInfoRec);	pInfo.processName = name;	pInfo.processAppSpec = folder;	theError = GetProcessInformation(&psn, &pInfo);	if(theError)	return theError;		//Find the Accounts folder	XGetIndString(name, kMiscStringResID, 26);	info.ioCompletion = NULL;	info.ioNamePtr = name;	info.ioVRefNum = folder->vRefNum;	info.ioFDirIndex = 0;	info.ioDrDirID = folder->parID;	theError = PBGetCatInfo((CInfoPBRec*) &info, false);	if(theError)	return theError;		folder->parID = info.ioDrDirID;	folder->name[0] = 0;		return noErr;}#elsestatic OSErr AddIconToFolder(FSSpec* folder, long dirID){	FSSpec			theFile;	OSErr			theError;	FInfo			info;	short			fileID;	long			bufferCount;	Handle			data;	DirInfo			dInfo;	Str255			name;		//Create file	theFile.vRefNum = folder->vRefNum;	theFile.parID = dirID;	BlockMove(kIconFileName, theFile.name, sizeof(Str31));	FSpCreateResFile(&theFile, kIconFileCreator, kIconFileType, smSystemScript);	if(ResError())	return ResError();		//Copy data into resource fork	theError = FSpOpenRF(&theFile, fsRdWrPerm, &fileID);	if(theError == noErr) {		data = Get1IndResource(kIconFileDataResType, 1);		if(data == NULL)		theError = ResError();		else {			SetFPos(fileID, fsFromStart, 0);			bufferCount = GetHandleSize(data);			theError = FSWrite(fileID, &bufferCount, *data);			ReleaseResource(data);		}		FSClose(fileID);	}		if(theError) {		FSpDelete(&theFile);		return theError;	}	else {		//Set invisible bit		theError = FSpGetFInfo(&theFile, &info);		if(theError)		return theError;		info.fdFlags |= kIsInvisible;		theError = FSpSetFInfo(&theFile, &info);		if(theError)		return theError;	}		//Set folder icon bit	BlockMove(folder->name, name, sizeof(Str63));	dInfo.ioCompletion = nil;	dInfo.ioNamePtr = name;	dInfo.ioVRefNum = folder->vRefNum;	dInfo.ioFDirIndex = 0;	dInfo.ioDrDirID = folder->parID;	theError = PBGetCatInfo((CInfoPBRec*) &dInfo, false);	if(theError)	return theError;	dInfo.ioDrUsrWds.frFlags |= kHasCustomIcon;	dInfo.ioDrDirID = folder->parID;	theError = PBSetCatInfo((CInfoPBRec*) &dInfo, false);	if(theError)	return theError;		return noErr;}OSErr GetDefaultAccountFolder(FSSpec* folder){	OSErr			theError;	Boolean			targetIsFolder,					wasAliased;	DirInfo			info;	long			folderID;	Str255			name;		//Find user Documents folder	theError = FindFolder(kOnSystemDisk, kDocumentsFolderType, kCreateFolder, &folder->vRefNum, &folder->parID);	if(theError)	return theError;		//Find or create the Accounts folder	XGetIndString(name, kMiscStringResID, 7);	BlockMove(name, folder->name, sizeof(Str63));	theError = ResolveAliasFile(folder, true, &targetIsFolder, &wasAliased);	if(theError || !targetIsFolder) {		BlockMove(name, folder->name, sizeof(Str63));		theError = DirCreate(folder->vRefNum, folder->parID, folder->name, &folderID);		if(theError == noErr) {			AddIconToFolder(folder, folderID);			folder->parID = folderID;		}	}	else {		BlockMove(folder->name, name, sizeof(Str63));		info.ioCompletion = NULL;		info.ioNamePtr = name;		info.ioVRefNum = folder->vRefNum;		info.ioFDirIndex = 0;		info.ioDrDirID = folder->parID;		theError = PBGetCatInfo((CInfoPBRec*) &info, false);		if(theError)		return theError;		folder->parID = info.ioDrDirID;	}	folder->name[0] = 0;		return theError;}#endifvoid PanicError(long num){	Str255			text;		XGetIndString(text, kFatalInitStringTableResID, num);	ParamText(text, nil, nil, nil);	Alert(128, nil);	ExitToShell();}Point GetWindowPosition(WindowPtr window){	GrafPtr				savePort;	Point				thePoint = {0,0};		GetPort(&savePort);	SetPortWindowPort(window);	LocalToGlobal(&thePoint);	SetPort(savePort);		return thePoint;}void GetWindowMaxSize(Rect* content, Point* position){	Rect					screenRect;		screenRect = (**(**GetMainDevice()).gdPMap).bounds;	screenRect.top = GetMBarHeight();		*content = screenRect;	OffsetRect(content, -screenRect.left, -screenRect.top);	position->h = screenRect.left;	position->v = screenRect.top;}void GetWindowDefaultBounds(Point* position, Rect* content){	Rect					screenRect;		screenRect = (**(**GetMainDevice()).gdPMap).bounds;	SetRect(content, 0, 0, kDefaultWindowSizeH, kDefaultWindowSizeV);	position->v = screenRect.top + (screenRect.bottom - screenRect.top - kDefaultWindowSizeV) / 2;	position->h = screenRect.left + (screenRect.right - screenRect.left - kDefaultWindowSizeH) / 2;}Boolean EqualFileNames(StringPtr a, StringPtr b){	unsigned char			la = a[0],							lb = b[0];	Boolean					result;		if(a[0] > kMaxFileNameChars)	a[0] = kMaxFileNameChars;	if(b[0] > kMaxFileNameChars)	b[0] = kMaxFileNameChars;	result = FastEqualString(a, b, false);			a[0] = la;	b[0] = lb;		return result;}void AppendString(StringPtr dest, StringPtr add){	long					i;		for(i = 1; i <= add[0]; ++i) {		if(dest[0] == 255)		return;		dest[++dest[0]] = add[i];	}}void SetTempFileName(Str31 name){	Str31		temp;		NumToString((unsigned short) Random(), temp);	name[0] = 0;	AppendString(name, kTempPrefixFileName);	AppendString(name, temp);}Boolean FilterOperation(OperationPtr operation, StringPtr filter, CategoryListPtr categories, PaymentListPtr payments){	Str63				temp;		if(StringInString(operation->description, filter))	return true;		if((operation->categoryNum != kUndefinedNum) && StringInString(categories->list[operation->categoryNum].name, filter))	return true;		if((operation->paymentTypeNum != kUndefinedNum) && StringInString(payments->list[operation->paymentTypeNum].name, filter))	return true;		if(appPrefs->flags & kPreferencesFlag_DisplayCurrencySymbol)	AmountToCurrencyString(operation->absoluteAmount, temp, operation->owner->data->currencySymbol, !(operation->owner->data->flags & kAccountFlag_NoCents), operation->owner->data->flags & kAccountFlag_SymbolLeads);	else	AmountToString(operation->absoluteAmount, temp, 0, 0, !(operation->owner->data->flags & kAccountFlag_NoCents));	if(StringInString(temp, filter))	return true;		if(operation->customData[0] && StringInString(operation->customData, filter))	return true;		if((appPrefs->flags & kPreferencesFlag_FilterNotes) && operation->note[0] && StringInString(operation->note, filter))	return true;		if(appPrefs->flags & kPreferencesFlag_LongDates)	IUDateString(operation->date, longDate, temp);	else	IUDateString(operation->date, shortDate, temp);	if(StringInString(temp, filter))	return true;		return false;}void XGetIndString(StringPtr text, short resID, short index){	short			num = 1,					count;	Handle			data;	StringPtr		string;		//Clear string	text[0] = 0;		//Load resource	data = GetResource(kStringResType, resID);	if(data == NULL)	return;		//Get string count	count = *((short*) *data);	if((index < 1) || (index > count))	return;		//Find string	string = (StringPtr) (*data + sizeof(short));	while(num != index) {		string += string[0] + 1;		++num;	}		//Copy string	BlockMove(string, text, string[0] + 1);}void CategoriesMenu_Update(Boolean includeNoneItem){	long					categorycount = appPrefs->categories->count;	CategoryPtr				categoryList = appPrefs->categories->list;	MenuHandle				menu = GetMenuHandle(kCategoryMenuID);	Str31					text;	long					i;		//Remove all menu items	while(CountMenuItems(menu))	DeleteMenuItem(menu, 1);		//Append "none" & separator items if necessary	if(includeNoneItem) {		XGetIndString(text, kMiscStringResID, 29);		AppendMenuItemText(menu, text);		SetItemStyle(menu, 1, italic);		SetMenuItemRefCon(menu, 1, kUndefinedID);				AppendMenu(menu, "\p(-");	}		//Append categories	for(i = 0; i < categorycount; ++i) {		AppendMenuItemText(menu, categoryList[i].name);		SetMenuItemRefCon(menu, CountMenuItems(menu), categoryList[i].id);	}}short CategoriesMenu_SetChoice(ID id){	MenuHandle				menu = GetMenuHandle(kCategoryMenuID);	ID						temp;	long					index;		for(index = 1; index <= CountMenuItems(menu); ++index)	if((GetMenuItemRefCon(menu, index, &temp) == noErr) && (temp == id))	return index;		return 0;}ID CategoriesMenu_GetChoice(short item){	ID						temp;		if(GetMenuItemRefCon(GetMenuHandle(kCategoryMenuID), item, &temp) != noErr)	return kUndefinedID;		return temp;}void PaymentTypesMenu_Update(Boolean includeNoneItem){	long					paymentCount = appPrefs->payments->count;	PaymentTypePtr			paymentList = appPrefs->payments->list;	MenuHandle				menu = GetMenuHandle(kPaymentMenuID);	Str31					text;	long					i;		//Remove all menu items	while(CountMenuItems(menu))	DeleteMenuItem(menu, 1);		//Append "none" & separator items if necessary	if(includeNoneItem) {		XGetIndString(text, kMiscStringResID, 30);		AppendMenuItemText(menu, text);		SetItemStyle(menu, 1, italic);		SetMenuItemRefCon(menu, 1, kUndefinedID);				AppendMenu(menu, "\p(-");	}		//Append payment types	for(i = 0; i < paymentCount; ++i) {		AppendMenuItemText(menu, paymentList[i].name);		SetMenuItemRefCon(menu, CountMenuItems(menu), paymentList[i].id);	}}short PaymentTypesMenu_SetChoice(ID id){	MenuHandle				menu = GetMenuHandle(kPaymentMenuID);	ID						temp;	long					index;		for(index = 1; index <= CountMenuItems(menu); ++index)	if((GetMenuItemRefCon(menu, index, &temp) == noErr) && (temp == id))	return index;		return 0;}ID PaymentTypesMenu_GetChoice(short item){	ID						temp;		if(GetMenuItemRefCon(GetMenuHandle(kPaymentMenuID), item, &temp) != noErr)	return kUndefinedID;		return temp;}void AccountMenu_Update(Boolean includeAllItem){	MenuHandle				menu = GetMenuHandle(kAccountMenuID);	Str63					text;	long					i;		//Remove all menu items	while(CountMenuItems(menu))	DeleteMenuItem(menu, 1);		//Append "all" & separator items if necessary	if(includeAllItem) {		XGetIndString(text, kMiscStringResID, 31);		AppendMenuItemText(menu, text);		SetItemStyle(menu, 1, italic);		SetMenuItemRefCon(menu, 1, kUndefinedID);				AppendMenu(menu, "\p(-");	}		//Append accounts	for(i = 0; i < application->accountCount; ++i) {		AppendMenuItemText(menu, application->accountList[i]->data->name);		SetMenuItemRefCon(menu, CountMenuItems(menu), application->accountList[i]->data->id);	}}short AccountMenu_SetChoice(ID id){	MenuHandle				menu = GetMenuHandle(kAccountMenuID);	ID						temp;	long					index;		for(index = 1; index <= CountMenuItems(menu); ++index)	if((GetMenuItemRefCon(menu, index, &temp) == noErr) && (temp == id))	return index;		return 0;}ID AccountMenu_GetChoice(short item){	ID						temp;		if(GetMenuItemRefCon(GetMenuHandle(kAccountMenuID), item, &temp) != noErr)	return kUndefinedID;		return temp;}void MacroMenu_Update(){	long					macroCount = appPrefs->macros->count;	MacroPtr				macroList = appPrefs->macros->list;	MenuHandle				menu = GetMenuHandle(kMacroMenuID);	long					i;		//Remove all menu items	while(CountMenuItems(menu))	DeleteMenuItem(menu, 1);		//Append macros	for(i = 0; i < macroCount; ++i)	AppendMenuItemText(menu, macroList[i].name);}void InitFastCompareStringCacheTable(){	unsigned char			buffer[kCharSortingTableSize];	long					i,							j;	Str31					a,							b;	unsigned char			temp;		for(i = 0; i < kCharSortingTableSize; ++i)	buffer[i] = i;	a[0] = 1;	b[0] = 1;		for(i = 0; i < kCharSortingTableSize - 1; ++i)	for(j = 0; j < kCharSortingTableSize - 1; ++j) {		a[1] = buffer[j];		b[1] = buffer[j + 1];		if(CompareString(a, b, NULL) == 1) {			temp = buffer[j];			buffer[j] = buffer[j + 1];			buffer[j + 1] = temp;		}	}		for(i = 0; i < kCharSortingTableSize; ++i) {		for(j = 0; j < kCharSortingTableSize; ++j)		if(buffer[j] == i) {			sortingTable[i] = j;			break;		}	}}Boolean UseMetricSystem(){	Intl0Hndl			iuSettings = NULL;		iuSettings = (Intl0Hndl) GetIntlResource(0);	if((iuSettings != NULL) && ((**iuSettings).metricSys == 255))	return true;		return false;}