/***************************************************************************** * Copyright (c) 1999-2002, Pierre-Olivier Latour * http://www.pol-online.net * info@pol-online.net * * This program is free software; you can redistribute it and/or modify * it under the terms of the GNU General Public License as published by * the Free Software Foundation; either version 2 of the License, or * (at your option) any later version. *  * This program is distributed in the hope that it will be useful, * but WITHOUT ANY WARRANTY; without even the implied warranty of * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the * GNU General Public License for more details. * * You should have received a copy of the GNU General Public License * along with this program; if not, write to the Free Software * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111, USA. *****************************************************************************/#include			"Account.h"#include			"Utils.h"#include			"File Utils.h"#include			"Dialog Utils.h"#include			"Filter.h"#include			"Preferences.h"#include			"Window Server.h"#if !__DEMO__ && !__DEBUG__#include			"Serial Number.h"#endif//VARIABLES:#define				kOperationBlockSize			32#define				kEditDialogID				129#define				kTabItemID					3#define				kNumItems					3#define				kGeneralID					600#define				kUserID						601#define				kBankID						602#define				kContactID					603#define				kPasswordDialogID			130#define				kPasswordItemID				3#define				kPasswordRequestDialogID	131#define				kPasswordRequestItemID		3#define				kAutomaticListDialogID		132#define				kAutomaticEditDialogID		133#define				kOperationEditDialogID		134#define				kEnterCharCode				0x03//ROUTINES:Account::Account(){	data = NULL;	_file.name[0] = 0;	_locked = false;}Account::~Account(){	//Release memory	_ReleaseAccountMemory();}void Account::_ReleaseAccountMemory(){	if(data) {		if(data->operations)		DisposePtr((Ptr) data->operations);		if(data->automatics)		DisposePtr((Ptr) data->automatics);				DisposePtr((Ptr) data);	}	data = NULL;}OSErr Account::CreateNew(){	Intl0Hndl			iuSettings = nil;	Str31				temp;		//Release memory	_ReleaseAccountMemory();		//Allocate memory	data = (AccountDataPtr) NewPtrClear(sizeof(AccountData));	if(data == NULL)	return MemError();	data->operations = (OperationListPtr) NewPtr(sizeof(OperationList) + kOperationBlockSize * sizeof(Operation));	if(data->operations == NULL)	return MemError();	data->automatics = (AutomaticListPtr) NewPtr(sizeof(AutomaticList));	if(data->automatics == NULL)	return MemError();		//Set data	data->version = kAccount_Version;	data->operations->count = 0;	data->operations->bufferCount = kOperationBlockSize;	data->automatics->count = 0;	XGetIndString(data->name, kMiscStringResID, 4);	XGetIndString(data->currencyName, kMiscStringResID, 5);	XGetIndString(temp, kMiscStringResID, 6);	if(temp[0] > kCurrency_SymbolMaxChars)	temp[0] = kCurrency_SymbolMaxChars;	BlockMove(temp, data->currencySymbol, temp[0] + 1);	data->operationListSorted = false;	data->firstLine = 0;		iuSettings = (Intl0Hndl) GetIntlResource(0);	if((iuSettings != nil) && ((**iuSettings).currFmt & currSymLead))	data->flags |= kAccountFlag_SymbolLeads;		//Create unique ID	data->id = application->GenerateUniqueID();		//Clear previous file	_file.name[0] = 0;		//Clear lock	_locked = false;		return noErr;}OSErr Account::WriteToDisk(FSSpec* folder){	OSErr			theError;	short			fileID;	FSSpec			tempFile;	Str63			newName;		if(data == NULL)	return paramErr;		//Create new file location	tempFile = *folder;	SetTempFileName(tempFile.name);		//Update save date	GetDateTime(&data->saveDate);		//Create temp file	theError = FSpCreate(&tempFile, kAccount_FileCreator, kAccount_FileType, smSystemScript);	if(theError)	return theError;		//Open file	theError = FSpOpenDF(&tempFile, fsRdWrPerm, &fileID);	if(theError)	return theError;		//Write data	SetFPos(fileID, fsFromStart, 0);	theError = WritePtr(fileID, data);	if(theError)	goto End;#if __DEMO__	if(data->operations->count > kAccount_MaxOperations)	data->operations->count = kAccount_MaxOperations;#endif	theError = WritePtr(fileID, data->operations);	if(theError)	goto End;	theError = WritePtr(fileID, data->automatics);	if(theError)	goto End;	End:	//Close file	FSClose(fileID);		//Swap files	if(theError)	FSpDelete(&tempFile);	else {		//Delete original file		if(_file.name[0])		FSpDelete(&_file);				//Build file name		BlockMove(data->name, newName, sizeof(Str63));		if(newName[0] > kMaxFileNameChars)		newName[0] = kMaxFileNameChars;				//Rename temp file		theError = FSpRename(&tempFile, newName);		_file = tempFile;		if(theError == noErr)		BlockMove(newName, _file.name, sizeof(Str63));	}		return theError;}OSErr Account::ReadFromDisk(FSSpec* file){	OSErr		theError;	short		fileID;	long		i;		//Release memory	_ReleaseAccountMemory();		//Open file	theError = FSpOpenDF(file, fsRdPerm, &fileID);	if(theError)	return theError;		//Read data	SetFPos(fileID, fsFromStart, 0);	theError = ReadPtr(fileID, (void**) &data);	if(theError)	goto End;	data->operations = NULL;	data->automatics = NULL;	theError = ReadPtr(fileID, (void**) &data->operations);	if(theError)	goto End;	theError = ReadPtr(fileID, (void**) &data->automatics);	End:	if(theError)	_ReleaseAccountMemory();		//Close file	_file = *file;	FSClose(fileID);		//Check version	if(data->version != kAccount_Version) {		if((data->version == 0x0000) || (data->version == 0x0100)) {			data->unusedStartBalance = (float) kAmountPrecision * *((float*) &data->unusedStartBalance);			for(i = 0; i < data->operations->count; ++i)			data->operations->list[i].amount = (float) kAmountPrecision * *((float*) &data->operations->list[i].amount);						data->version = kAccount_Version;		}		else {			_ReleaseAccountMemory();			return paramErr;		}	}		//Set lock	if(theError == noErr) {		if(data->password[0])		_locked = true;		else		_locked = false;	}		//Force sorting	data->operationListSorted = false;		return theError;}OSErr Account::RemoveFromDisk(){	Str63			newName;	Str31			temp;		if(!_file.name[0])	return noErr;	#if 0	return FSpDelete(&_file);#else	newName[0] = 1;	newName[1] = kSkipFileChar;	AppendString(newName, _file.name);	AppendString(newName, "\p_");	NumToString((unsigned short) Random(), temp);	AppendString(newName, temp);	if(newName[0] > kMaxFileNameChars)	newName[0] = kMaxFileNameChars;	return FSpRename(&_file, newName);#endif}void Account::_ShowPane_General(DialogPtr dialog, short offset){	ControlHandle		items[6];	long				i;		//Append DITL pane	AppendDialogItemList(dialog, kGeneralID, overlayDITL);		//Get items	for(i = 0; i < 6; ++i)	GetDialogItemAsControl(dialog, offset + 1 + i, &items[i]);		//Set items	XSetDialogItemText(items[0], data->name);	XSetDialogItemText(items[1], data->currencyName);	XSetDialogItemText(items[2], data->currencySymbol);	if(!(data->flags & kAccountFlag_NoCents))	SetControlValue(items[3], 1);	if(!(data->flags & kAccountFlag_SymbolLeads))	SetControlValue(items[4], 1);	XSetDialogItemText(items[5], data->note);		SelectDialogItemText(dialog, offset + 1, 0, 32000);}void Account::_ClickPane_General(DialogPtr dialog, short itemHit, short offset){	ControlHandle			item;		switch(itemHit) {				case 4:		case 5:		GetDialogItemAsControl(dialog, offset + itemHit, &item);		SetControlValue(item, !GetControlValue(item));		break;			}}void Account::_HidePane_General(DialogPtr dialog, short offset){	ControlHandle		items[6];	long				i;		//Get items	for(i = 0; i < 6; ++i)	GetDialogItemAsControl(dialog, offset + 1 + i, &items[i]);		XGetDialogItemText(items[0], data->name, kStr255MaxLength);	XGetDialogItemText(items[1], data->currencyName, kStr63MaxLength);	XGetDialogItemText(items[2], data->currencySymbol, kCurrency_SymbolMaxChars);	if(GetControlValue(items[3]))	data->flags &= ~kAccountFlag_NoCents;	else	data->flags |= kAccountFlag_NoCents;	if(GetControlValue(items[4]))	data->flags &= ~kAccountFlag_SymbolLeads;	else	data->flags |= kAccountFlag_SymbolLeads;	XGetDialogItemText(items[5], data->note, kStr255MaxLength);		//Remove DITL pane	ShortenDITL(dialog, CountDITL(dialog) - offset);}void Account::_ShowPane_User(DialogPtr dialog, short offset){	ControlHandle		items[10];	long				i;		//Append DITL pane	AppendDialogItemList(dialog, kUserID, overlayDITL);		//Get items	for(i = 0; i < 10; ++i)	GetDialogItemAsControl(dialog, offset + 1 + i, &items[i]);		//Set items	XSetDialogItemText(items[0], data->user.name);	XSetDialogItemText(items[1], data->user.firstName);	XSetDialogItemText(items[2], data->user.address);	XSetDialogItemText(items[3], data->user.zipCode);	XSetDialogItemText(items[4], data->user.city);	XSetDialogItemText(items[5], data->user.state);	XSetDialogItemText(items[6], data->user.country);	XSetDialogItemText(items[7], data->user.phone);	XSetDialogItemText(items[8], data->user.fax);	XSetDialogItemText(items[9], data->user.email);		SelectDialogItemText(dialog, offset + 1, 0, 32000);}void Account::_HidePane_User(DialogPtr dialog, short offset){	ControlHandle		items[10];	long				i;		//Get items	for(i = 0; i < 10; ++i)	GetDialogItemAsControl(dialog, offset + 1 + i, &items[i]);		XGetDialogItemText(items[0], data->user.name, kStr255MaxLength);	XGetDialogItemText(items[1], data->user.firstName, kStr255MaxLength);	XGetDialogItemText(items[2], data->user.address, kStr255MaxLength);	XGetDialogItemText(items[3], data->user.zipCode, kStr31MaxLength);	XGetDialogItemText(items[4], data->user.city, kStr255MaxLength);	XGetDialogItemText(items[5], data->user.state, kStr63MaxLength);	XGetDialogItemText(items[6], data->user.country, kStr63MaxLength);	XGetDialogItemText(items[7], data->user.phone, kStr31MaxLength);	XGetDialogItemText(items[8], data->user.fax, kStr31MaxLength);	XGetDialogItemText(items[9], data->user.email, kStr63MaxLength);		//Remove DITL pane	ShortenDITL(dialog, CountDITL(dialog) - offset);}void Account::_ShowPane_Bank(DialogPtr dialog, short offset){	ControlHandle		items[9];	long				i;		//Append DITL pane	AppendDialogItemList(dialog, kBankID, overlayDITL);		//Get items	for(i = 0; i < 9; ++i)	GetDialogItemAsControl(dialog, offset + 1 + i, &items[i]);		//Set items	XSetDialogItemText(items[0], data->bank.accountNumber);	XSetDialogItemText(items[1], data->bank.name);	XSetDialogItemText(items[2], data->bank.clearing);	XSetDialogItemText(items[3], data->bank.address);	XSetDialogItemText(items[4], data->bank.zipCode);	XSetDialogItemText(items[5], data->bank.city);	XSetDialogItemText(items[6], data->bank.state);	XSetDialogItemText(items[7], data->bank.country);	XSetDialogItemText(items[8], data->bank.webSite);		SelectDialogItemText(dialog, offset + 1, 0, 32000);}void Account::_HidePane_Bank(DialogPtr dialog, short offset){	ControlHandle		items[9];	long				i;		//Get items	for(i = 0; i < 9; ++i)	GetDialogItemAsControl(dialog, offset + 1 + i, &items[i]);		XGetDialogItemText(items[0], data->bank.accountNumber, kStr63MaxLength);	XGetDialogItemText(items[1], data->bank.name, kStr63MaxLength);	XGetDialogItemText(items[2], data->bank.clearing, kStr31MaxLength);	XGetDialogItemText(items[3], data->bank.address, kStr255MaxLength);	XGetDialogItemText(items[4], data->bank.zipCode, kStr31MaxLength);	XGetDialogItemText(items[5], data->bank.city, kStr255MaxLength);	XGetDialogItemText(items[6], data->bank.state, kStr63MaxLength);	XGetDialogItemText(items[7], data->bank.country, kStr63MaxLength);	XGetDialogItemText(items[8], data->bank.webSite, kStr63MaxLength);		//Remove DITL pane	ShortenDITL(dialog, CountDITL(dialog) - offset);}void Account::_ShowPane_Contacts(DialogPtr dialog, short offset){	ControlHandle		items[10];	long				i;		//Append DITL pane	AppendDialogItemList(dialog, kContactID, overlayDITL);		//Get items	for(i = 0; i < 10; ++i)	GetDialogItemAsControl(dialog, offset + 1 + i, &items[i]);		//Set items	XSetDialogItemText(items[0], data->bank.contactList[0].name);	XSetDialogItemText(items[1], data->bank.contactList[0].title);	XSetDialogItemText(items[2], data->bank.contactList[0].phone);	XSetDialogItemText(items[3], data->bank.contactList[0].fax);	XSetDialogItemText(items[4], data->bank.contactList[0].email);		XSetDialogItemText(items[5], data->bank.contactList[1].name);	XSetDialogItemText(items[6], data->bank.contactList[1].title);	XSetDialogItemText(items[7], data->bank.contactList[1].phone);	XSetDialogItemText(items[8], data->bank.contactList[1].fax);	XSetDialogItemText(items[9], data->bank.contactList[1].email);		SelectDialogItemText(dialog, offset + 1, 0, 32000);}void Account::_HidePane_Contacts(DialogPtr dialog, short offset){	ControlHandle		items[10];	long				i;		//Get items	for(i = 0; i < 10; ++i)	GetDialogItemAsControl(dialog, offset + 1 + i, &items[i]);		XGetDialogItemText(items[0], data->bank.contactList[0].name, kStr255MaxLength);	XGetDialogItemText(items[1], data->bank.contactList[0].title, kStr255MaxLength);	XGetDialogItemText(items[2], data->bank.contactList[0].phone, kStr31MaxLength);	XGetDialogItemText(items[3], data->bank.contactList[0].fax, kStr31MaxLength);	XGetDialogItemText(items[4], data->bank.contactList[0].email, kStr63MaxLength);		XGetDialogItemText(items[5], data->bank.contactList[1].name, kStr255MaxLength);	XGetDialogItemText(items[6], data->bank.contactList[1].title, kStr255MaxLength);	XGetDialogItemText(items[7], data->bank.contactList[1].phone, kStr31MaxLength);	XGetDialogItemText(items[8], data->bank.contactList[1].fax, kStr31MaxLength);	XGetDialogItemText(items[9], data->bank.contactList[1].email, kStr63MaxLength);		//Remove DITL pane	ShortenDITL(dialog, CountDITL(dialog) - offset);}static Boolean AccountNameIsUnique(AccountPtr account){	long					i;	Boolean					unique = true;		if(!account->data->name[0])	return false;		for(i = 0; i < application->accountCount; ++i)	if(application->accountList[i] != account) {		if(EqualFileNames(account->data->name, application->accountList[i]->data->name)) {			unique = false;			break;		}	}		if(unique)	for(i = 0; i < application->filterCount; ++i)	if(EqualFileNames(account->data->name, application->filterList[i]->data->name)) {		unique = false;		break;	}		return unique;}Boolean Account::EditInfo(){	AccountData				copy;	GrafPtr					savePort;	DialogPtr				theDialog;	ControlHandle			tabItem;	short					itemHit,							curPane = 1;								//Backup current preferences	BlockMove(data, &copy, sizeof(AccountData));		//Display dialog	GetPort(&savePort);	theDialog = GetNewDialog(kEditDialogID, nil, (WindowPtr) -1);	SetPortDialogPort(theDialog);	NormalizeThemeDrawingState();	GetDialogItemAsControl(theDialog, kTabItemID, &tabItem);		_ShowPane_General(theDialog, kNumItems);	SetControlValue((ControlHandle) tabItem, 1);		SetDialogDefaultItem(theDialog, 1);	SetDialogCancelItem(theDialog, 2);		//Run	do {		//Get dialog events		ModalDialog(ModalDialogRoutine, &itemHit);		if(itemHit > kNumItems) {			if(curPane == 1)			_ClickPane_General(theDialog, itemHit - kNumItems, kNumItems);		}		else if(itemHit == kTabItemID) { //Tab switch			if(curPane == 1) {				_HidePane_General(theDialog, kNumItems);				if(!AccountNameIsUnique(this)) {					SetControlValue(tabItem, 1);					_ShowPane_General(theDialog, kNumItems);					application->errorManager->StandardError(44, (void*) data->name);					itemHit = 0;					continue;				}			}			else if(curPane == 2)			_HidePane_User(theDialog, kNumItems);			else if(curPane == 3)			_HidePane_Bank(theDialog, kNumItems);			else if(curPane == 4)			_HidePane_Contacts(theDialog, kNumItems);						//Get new pane			curPane = GetControlValue(tabItem);						//Display			if(curPane == 1)			_ShowPane_General(theDialog, kNumItems);			else if(curPane == 2)			_ShowPane_User(theDialog, kNumItems);			else if(curPane == 3)			_ShowPane_Bank(theDialog, kNumItems);			else if(curPane == 4)			_ShowPane_Contacts(theDialog, kNumItems);		}		else if(itemHit == 1) {			if(curPane == 1) {				_HidePane_General(theDialog, kNumItems);				if(!AccountNameIsUnique(this)) {					SetControlValue(tabItem, 1);					_ShowPane_General(theDialog, kNumItems);					application->errorManager->StandardError(44, (void*) data->name);					itemHit = 0;					continue;				}			}			else if(curPane == 2)			_HidePane_User(theDialog, kNumItems);			else if(curPane == 3)			_HidePane_Bank(theDialog, kNumItems);			else if(curPane == 4)			_HidePane_Contacts(theDialog, kNumItems);		}	} while((itemHit != 1) && (itemHit != 2));		DisposeDialog(theDialog);	SetPort(savePort);		//Has the user clicked cancel?	if(itemHit == 2) {		BlockMove(&copy, data, sizeof(AccountData));		return false;	}		return true;}Boolean Account::Unlock(){	Str255					password;	GrafPtr					savePort;	DialogPtr				theDialog;	ControlHandle			item;	short					itemHit;								if(!_locked)	return true;		//Display dialog	ParamText(nil, nil, nil, data->name);	GetPort(&savePort);	theDialog = GetNewDialog(kPasswordRequestDialogID, nil, (WindowPtr) -1);	SetPortDialogPort(theDialog);	NormalizeThemeDrawingState();		GetDialogItemAsControl(theDialog, kPasswordRequestItemID, &item);		SetDialogDefaultItem(theDialog, 1);	SetDialogCancelItem(theDialog, 2);	SetKeyboardFocus(GetDialogWindow(theDialog), item, kControlFocusNextPart);		//Run	do {		//Get dialog events		ModalDialog(ModalDialogRoutine, &itemHit);				//Check password		if(itemHit == 1) {			GetEditTextPasswordText(item, password);			if(!FastEqualString(password, data->password, true)) {				application->errorManager->StandardError(26);				SetEditTextSelection(item, 0, 32000);				itemHit = 0;			}			else			_locked = false;		}			} while((itemHit != 1) && (itemHit != 2));		//Bug fix workaround	ShortenDITL(theDialog, 5);		DisposeDialog(theDialog);	SetPort(savePort);		//Has the user clicked cancel?	if(itemHit == 2)	return false;		return true;}Boolean Account::EditPassword(){	GrafPtr					savePort;	DialogPtr				theDialog;	ControlHandle			item;	short					itemHit;								//Display dialog	ParamText(data->name, nil, nil, nil);	GetPort(&savePort);	theDialog = GetNewDialog(kPasswordDialogID, nil, (WindowPtr) -1);	SetPortDialogPort(theDialog);	NormalizeThemeDrawingState();		GetDialogItemAsControl(theDialog, kPasswordItemID, &item);		XSetDialogItemText(item, data->password);	SelectDialogItemText(theDialog, 3, 0, 32000);	SetDialogDefaultItem(theDialog, 1);	SetDialogCancelItem(theDialog, 2);		//Run	do {		//Get dialog events		ModalDialog(ModalDialogRoutine, &itemHit);	} while((itemHit != 1) && (itemHit != 2));		if(itemHit == 1)	XGetDialogItemText(item, data->password, kStr31MaxLength);		DisposeDialog(theDialog);	SetPort(savePort);		//Has the user clicked cancel?	if(itemHit == 2)	return false;		return true;}#if !__BASIC__Boolean Account::EditAutomatic(AutomaticPtr automatic){	GrafPtr					savePort;	DialogPtr				theDialog;	ControlHandle			items[8];	short					itemHit;	long					i;	unsigned long			temp1,							temp2;	DateTimeRec				dateRec;								//Set currency	ParamText(data->currencySymbol, nil, nil, nil);		//Display dialog	GetPort(&savePort);	theDialog = GetNewDialog(kAutomaticEditDialogID, nil, (WindowPtr) -1);	SetPortDialogPort(theDialog);	NormalizeThemeDrawingState();		//Get items	for(i = 0; i < 8; ++i)	GetDialogItemAsControl(theDialog, 3 + i, &items[i]);		SetClockDateTime(items[0], automatic->nextDate);	XSetDialogItemNum(items[1], automatic->repetitionValue);	SetControlValue(items[2], automatic->repetitionType);	XSetDialogItemNum(items[3], automatic->creationPreDelay);		SetClockDateTime(items[5], automatic->endDate);	XSetDialogItemNum(items[7], automatic->numRepetitions);	if(automatic->endType == kAutomatic_End_ByDate) {		SetControlValue(items[4], 1);		HiliteControl(items[7], 255);	}	else {		SetControlValue(items[6], 1);		HiliteControl(items[5], 255);	}		SelectDialogItemText(theDialog, 4, 0, 32000);	SetDialogDefaultItem(theDialog, 1);	SetDialogCancelItem(theDialog, 2);		//Run	do {		//Get dialog events		ModalDialog(ModalDialogRoutine, &itemHit);				switch(itemHit) {						case 7:			SetControlValue(items[4], 1);			SetControlValue(items[6], 0);			HiliteControl(items[5], 0);			HiliteControl(items[7], 255);			break;						case 9:			SetControlValue(items[4], 0);			SetControlValue(items[6], 1);			HiliteControl(items[5], 255);			HiliteControl(items[7], 0);			break;						case 11: //Bug workaround			GetClockDateTime(items[0], &temp1);			GetClockDateTime(items[5], &temp2);			EditOperation(&automatic->operationTemplate, true);			SetClockDateTime(items[0], temp1);			SetClockDateTime(items[5], temp2);			break;					}	} while((itemHit != 1) && (itemHit != 2));		if(itemHit == 1) {		GetClockDateTime(items[0], &automatic->nextDate);		automatic->repetitionValue = XGetDialogItemNum(items[1]);		automatic->repetitionType = GetControlValue(items[2]);		automatic->creationPreDelay = XGetDialogItemNum(items[3]);				GetClockDateTime(items[5], &automatic->endDate);		automatic->numRepetitions = XGetDialogItemNum(items[7]);		if(GetControlValue(items[4]))		automatic->endType = kAutomatic_End_ByDate;		else		automatic->endType = kAutomatic_End_ByNumber;				if(automatic->repetitionType == kAutomatic_Repetition_Monthly) {			SecondsToDate(automatic->nextDate, &dateRec);			automatic->monthlyRepetitionDay = dateRec.day;		}		else		automatic->monthlyRepetitionDay = 0;	}		DisposeDialog(theDialog);	SetPort(savePort);		if(itemHit == 2)	return false;		//Mark automatic active again!	automatic->flags |= kAutomaticFlag_Active;		return true;}static void ClearAutomatic(AutomaticPtr automatic){	BlockZero(automatic, sizeof(Automatic));	automatic->flags = kAutomaticFlag_Active;	GetDateTime(&automatic->nextDate);	automatic->repetitionType = kAutomatic_Repetition_Weekly;	automatic->endType = kAutomatic_End_ByNumber;	automatic->repetitionValue = 1;	GetDateTime(&automatic->endDate);	automatic->numRepetitions = 1;		XGetIndString(automatic->operationTemplate.description, kMiscStringResID, 11);}Boolean Account::EditAutomaticList(){	Cell					theCell = {0,0};	AutomaticListPtr		copy,							temp;	GrafPtr					savePort;	DialogPtr				theDialog;	ControlHandle			items[7];	short					itemHit;	long					i,							j;	ListHandle				theList;	Automatic				theAutomatic;	Str255					text,							text2;	Str63					dateText;	Boolean					doubleClick;		//Backup current automatic list	copy = (AutomaticListPtr) NewPtr(GetPtrSize((Ptr) data->automatics));	if(copy == NULL)	return false;	BlockMove(data->automatics, copy, GetPtrSize((Ptr) data->automatics));		//Bubble sort	for(i = 0; i < data->automatics->count - 1; ++i)	for(j = 0; j < data->automatics->count - 1 - i; ++j) {		if(FastCompareString(data->automatics->list[j].operationTemplate.description, data->automatics->list[j + 1].operationTemplate.description) == 1) {			theAutomatic = data->automatics->list[j];			data->automatics->list[j] = data->automatics->list[j + 1];			data->automatics->list[j + 1] = theAutomatic;		}	}		//Display dialog	GetPort(&savePort);	theDialog = GetNewDialog(kAutomaticListDialogID, nil, (WindowPtr) -1);	SetPortDialogPort(theDialog);	NormalizeThemeDrawingState();		//Get items	for(i = 0; i < 7; ++i)	GetDialogItemAsControl(theDialog, 3 + i, &items[i]);	GetListBoxListHandle(items[0], &theList);	LSetDrawingMode(true, theList);	(**theList).selFlags |= lNoExtend | lOnlyOne;	LAddRow(data->automatics->count, 1000, theList);	for(theCell.v = 0; theCell.v < data->automatics->count; ++theCell.v)	LSetCell(&data->automatics->list[theCell.v].operationTemplate.description[1], data->automatics->list[theCell.v].operationTemplate.description[0], theCell, theList);		theCell.v = 0;	LSetSelect(true, theCell, theList);		if(!data->automatics->count) {		HiliteControl(items[2], 255);		HiliteControl(items[3], 255);		HiliteControl(items[4], 255);		XSetDialogItemText(items[6], "\p");	}	else {		if(data->automatics->list[theCell.v].flags & kAutomaticFlag_Active) {			XGetIndString(text2, kMiscStringResID, 14);			IUDateString(data->automatics->list[theCell.v].nextDate, longDate, dateText);			application->errorManager->ExpandString(text2, text, dateText, NULL, NULL, NULL);		}		else		XGetIndString(text, kMiscStringResID, 13);		XSetDialogItemText(items[6], text);	}		SetDialogDefaultItem(theDialog, 1);	SetDialogCancelItem(theDialog, 2);		//Run	do {		//Get dialog events		ModalDialog(ModalDialogRoutine, &itemHit);				BackColor(whiteColor);		switch(itemHit) {						//User has selected another automatic			case 3:			if(!data->automatics->count)			break;			theCell.v = 0;			if(!LGetSelect(true, &theCell, theList))			theCell.v = data->automatics->count - 1;			if((LLastClick(theList).v >= 0) && !GetControlData(items[0], 0, kControlListBoxDoubleClickTag, sizeof(Boolean), &doubleClick, &i) && doubleClick) {				if(EditAutomatic(&data->automatics->list[theCell.v]))				LSetCell(&data->automatics->list[theCell.v].operationTemplate.description[1], data->automatics->list[theCell.v].operationTemplate.description[0], theCell, theList);			}			break;						//User wants to create a new automatic			case 4:			ClearAutomatic(&theAutomatic);			if(!EditAutomatic(&theAutomatic))			break;			temp = (AutomaticListPtr) NewPtr(sizeof(AutomaticList) + (data->automatics->count + 1) * sizeof(Automatic));			if(temp) {				BlockMove(data->automatics, temp, sizeof(AutomaticList) + data->automatics->count * sizeof(Automatic));				DisposePtr((Ptr) data->automatics);				data->automatics = temp;				data->automatics->list[data->automatics->count] = theAutomatic;				++data->automatics->count;								LSetSelect(false, theCell, theList);				LAddRow(1, 1000, theList);				theCell.v = data->automatics->count - 1;								LSetCell(&data->automatics->list[theCell.v].operationTemplate.description[1], data->automatics->list[theCell.v].operationTemplate.description[0], theCell, theList);				HiliteControl(items[2], 0);				HiliteControl(items[3], 0);				HiliteControl(items[4], 0);								LSetSelect(true, theCell, theList);				LAutoScroll(theList);			}			else			SysBeep(0);			break;						//User wants to edit automatic			case 5:			if(!data->automatics->count)			break;			if(EditAutomatic(&data->automatics->list[theCell.v]))			LSetCell(&data->automatics->list[theCell.v].operationTemplate.description[1], data->automatics->list[theCell.v].operationTemplate.description[0], theCell, theList);			break;						//User wants to delete automatic			case 6:			if(!data->automatics->count)			break;			for(i = theCell.v; i < data->automatics->count - 1; ++i)			data->automatics->list[i] = data->automatics->list[i + 1];			--data->automatics->count;			SetPtrSize((Ptr) data->automatics, sizeof(AutomaticList) + data->automatics->count * sizeof(Automatic));						LDelRow(1, theCell.v, theList);			if(theCell.v == data->automatics->count)			--theCell.v;						if(!data->automatics->count) {				HiliteControl(items[2], 255);				HiliteControl(items[3], 255);				HiliteControl(items[4], 255);			}			break;						//User wants to duplicate automatic			case 7:			if(!data->automatics->count)			break;			temp = (AutomaticListPtr) NewPtr(sizeof(AutomaticList) + (data->automatics->count + 1) * sizeof(Automatic));			if(temp) {				BlockMove(data->automatics, temp, sizeof(AutomaticList) + data->automatics->count * sizeof(Automatic));				DisposePtr((Ptr) data->automatics);				data->automatics = temp;				data->automatics->list[data->automatics->count] = data->automatics->list[theCell.v];				XGetIndString(text, kMiscStringResID, 16);				if(!StringInString(data->automatics->list[data->automatics->count].operationTemplate.description, text) && (data->automatics->list[data->automatics->count].operationTemplate.description[0] + text[0] < 63))				AppendString(data->automatics->list[data->automatics->count].operationTemplate.description, text);				++data->automatics->count;								LSetSelect(false, theCell, theList);				LAddRow(1, 1000, theList);				theCell.v = data->automatics->count - 1;								LSetCell(&data->automatics->list[theCell.v].operationTemplate.description[1], data->automatics->list[theCell.v].operationTemplate.description[0], theCell, theList);								LSetSelect(true, theCell, theList);				LAutoScroll(theList);			}			else			SysBeep(0);			break;					}		if(itemHit) {			if(data->automatics->count) {				if(data->automatics->list[theCell.v].flags & kAutomaticFlag_Active) {					XGetIndString(text2, kMiscStringResID, 14);					IUDateString(data->automatics->list[theCell.v].nextDate, longDate, dateText);					application->errorManager->ExpandString(text2, text, dateText, NULL, NULL, NULL);				}				else				XGetIndString(text, kMiscStringResID, 13);				XSetDialogItemText(items[6], text);								LSetSelect(true, theCell, theList);				LDraw(theCell, theList);			}			else			XSetDialogItemText(items[6], "\p");		}	} while((itemHit != 1) && (itemHit != 2));		DisposeDialog(theDialog);	SetPort(savePort);		//Has the user clicked cancel?	if(itemHit == 2) {		DisposePtr((Ptr) data->automatics);		data->automatics = copy;		return false;	}	else	DisposePtr((Ptr) copy);		return true;}Boolean Account::ExecuteAutomatics(){	AutomaticPtr			automatic = data->automatics->list;	long					count = 0;	long					i;	DateTimeRec				temp;	Boolean					loop;	Operation				theOperation;	Date					current;	short					targetMonth;		//Get current date	GetDateTime(&current);		//Scan automatics	for(i = 0; i < data->automatics->count; ++i, ++automatic) {		if((automatic->repetitionValue <= 0) || ((automatic->endType == kAutomatic_End_ByNumber) && (automatic->numRepetitions <= 0)))		automatic->flags &= ~kAutomaticFlag_Active;		if(!(automatic->flags & kAutomaticFlag_Active))		continue;		loop = true;		do {			//Are we after next occurence date - include predelay!			if(DateToDay(current) >= DateToDay(automatic->nextDate) - automatic->creationPreDelay) {				//Setup operation				theOperation = automatic->operationTemplate;				theOperation.parent = kUndefinedID;				theOperation.date = automatic->nextDate;				theOperation.attachment = kUndefinedID;								//Add operation to list				if(!AddOperation(&theOperation))				return false;				++count;								//Compute next date				SecondsToDate(automatic->nextDate, &temp);				switch(automatic->repetitionType) {					case kAutomatic_Repetition_Daily: temp.day += automatic->repetitionValue; break;					case kAutomatic_Repetition_Weekly: temp.day += automatic->repetitionValue * 7; break;					case kAutomatic_Repetition_Monthly: temp.month += automatic->repetitionValue; break;				}				DateToSeconds(&temp, &automatic->nextDate);				if(automatic->repetitionType == kAutomatic_Repetition_Monthly) {					targetMonth = 1 + (temp.month - 1) % 12;					SecondsToDate(automatic->nextDate, &temp);										//Make sure we are the correct day					if(automatic->monthlyRepetitionDay && (temp.day != automatic->monthlyRepetitionDay)) {						temp.day = automatic->monthlyRepetitionDay;						DateToSeconds(&temp, &automatic->nextDate);						SecondsToDate(automatic->nextDate, &temp);					}										//Make sure we are the correct month					while(temp.month != targetMonth) {						temp.day -= 1;						DateToSeconds(&temp, &automatic->nextDate);						SecondsToDate(automatic->nextDate, &temp);					}				}								//Update end info & check if we're done				if(automatic->endType == kAutomatic_End_ByDate) {					if(DateToDay(automatic->nextDate) > DateToDay(automatic->endDate))					automatic->flags &= ~kAutomaticFlag_Active;				}				else {//kAutomatic_End_ByNumber					--automatic->numRepetitions;					if(automatic->numRepetitions <= 0)					automatic->flags &= ~kAutomaticFlag_Active;				}								//Check if the automatic has expired				if(!(automatic->flags & kAutomaticFlag_Active)) {					automatic->flags |= kAutomaticFlag_Trash;					loop = false;				}			}			else			loop = false;		} while(loop);	}		//Notify window server of changes if any!	if(count)	application->windowServer->Invalidate();		//Trash expired automatics	for(i = 0; i < data->automatics->count; ++i)	if(data->automatics->list[i].flags & kAutomaticFlag_Trash) {		if(application->errorManager->Warning(31, data->automatics->list[i].operationTemplate.description, data->name)) {			data->automatics->list[i] = data->automatics->list[data->automatics->count - 1];			--data->automatics->count;			SetPtrSize((Ptr) data->automatics, sizeof(AutomaticList) + data->automatics->count * sizeof(Automatic));			--i;		}		else		data->automatics->list[i].flags &= ~kAutomaticFlag_Trash;	}		//Check if operations have been created	if(count) {		application->errorManager->Note(28, (void*) count, data->name);		return true;	}		return false;}#endifstatic void IncrementCustomInfo(StringPtr in, StringPtr out){	long					i;		//Make sure there are only digits in the string	for(i = 1; i <= in[0]; ++i)	if((in[i] < '0') || (in[i] > '9')) {		BlockMove(in, out, in[0] + 1);		return;	}		//Increment number	StringToNum(in, &i);	NumToString(i + 1, out);		//Fix leading zeros	while(out[0] < in[0]) {		for(i = out[0]; i >= 1; --i)		out[i + 1] = out[i];		out[1] = '0';		++out[0];	}}Boolean Account::EditOperation(OperationPtr operation, Boolean automaticMode){	MacroPtr				macros = appPrefs->macros->list;	GrafPtr					savePort;	DialogPtr				theDialog;	ControlHandle			items[11];	short					itemHit;	long					i;	Str255					text;	Str63					text2;	short					value;	Amount					amount;	Date					dateCache;	Str63					customInfoCache;		//Check operation	if(operation == NULL)	return false;	dateCache = operation->date;	BlockMove(operation->customData, customInfoCache, 64);		//Update menus	CategoriesMenu_Update(true);	PaymentTypesMenu_Update(true);	MacroMenu_Update();		//Display dialog	GetPort(&savePort);	theDialog = GetNewDialog(kOperationEditDialogID, nil, (WindowPtr) -1);	SetPortDialogPort(theDialog);	NormalizeThemeDrawingState();		//Disable check autocompletion	if(automaticMode) {		GetDialogItemAsControl(theDialog, 14, &items[0]);		HiliteControl(items[0], 255);	}		//Get items	for(i = 0; i < 11; ++i)	GetDialogItemAsControl(theDialog, 3 + i, &items[i]);		XSetDialogItemText(items[0], operation->description);	if(automaticMode) {		GetDateTime((unsigned long*) &i);		SetClockDateTime(items[1], i);		HiliteControl(items[1], 255);	}	else	SetClockDateTime(items[1], operation->date);	XSetDialogItemAmount(items[2], operation->amount, !(data->flags & kAccountFlag_NoCents));	if(operation->flags & kOperationFlag_Expense)	SetControlValue(items[3], 1);	SetControlValue(items[4], PaymentTypesMenu_SetChoice(operation->paymentType));	XSetDialogItemText(items[5], operation->customData);		SetControlValue(items[6], CategoriesMenu_SetChoice(operation->category));	if(operation->flags & kOperationFlag_Checked)	SetControlValue(items[7], 1);	if(operation->flags & kOperationFlag_Warning)	SetControlValue(items[8], 1);		XSetDialogItemText(items[9], operation->note);		SelectDialogItemText(theDialog, 3, 0, 32000);	SetDialogDefaultItem(theDialog, 1);	SetDialogCancelItem(theDialog, 2);		//Run	InstallNumericKeyFilter(items[2]);	do {		//Get dialog events		ModalDialog(ModalDialogRoutine, &itemHit);				switch(itemHit) {						case 3:			GetDialogItemText((Handle) items[0], text);			if(dialogCharReceived && text[0]) {				i = application->AutoCompleteDescription(text);				if(i != kUndefinedNum) {					SetDialogItemText((Handle) items[0], text);					SelectDialogItemText(theDialog, 3, i, 32000);				}			}			break;						case 6:			case 10:			case 11:			SetControlValue(items[itemHit - 3], !GetControlValue(items[itemHit - 3]));			break;						case 13:			if(appPrefs->macros->count) {				GetBevelButtonMenuValue(items[10], &value);				XGetDialogItemAmount(items[2], &amount);				amount = AmountByCurrencyFactor(amount, macros[value - 1].factor);				XSetDialogItemAmount(items[2], amount, !(data->flags & kAccountFlag_NoCents));				SelectDialogItemText(theDialog, 5, 0, 32000);			}			else			SysBeep(0);			break;						case 14:			XGetDialogItemText(items[5], text, kStr63MaxLength);			if(text[0]) {				IncrementCustomInfo(text, text2);				SetDialogItemText((Handle) items[5], text2);				SelectDialogItemText(theDialog, 8, 0, 32000);			}			else if(data->lastCustomData[0]) {				IncrementCustomInfo(data->lastCustomData, text2);				SetDialogItemText((Handle) items[5], text2);				SelectDialogItemText(theDialog, 8, 0, 32000);			}			else			SysBeep(0);			break;					}	} while((itemHit != 1) && (itemHit != 2));		if(itemHit == 1) {		operation->flags = 0;				XGetDialogItemText(items[0], operation->description, kStr63MaxLength);		GetClockDateTime(items[1], &operation->date);		XGetDialogItemAmount(items[2], &operation->amount);		if(GetControlValue(items[3]) || (operation->amount < 0))		operation->flags |= kOperationFlag_Expense;		if(operation->amount < 0)		operation->amount = -operation->amount;		operation->paymentType = PaymentTypesMenu_GetChoice(GetControlValue(items[4]));		XGetDialogItemText(items[5], operation->customData, kStr63MaxLength);				operation->category = CategoriesMenu_GetChoice(GetControlValue(items[6]));		if(GetControlValue(items[7]))		operation->flags |= kOperationFlag_Checked;		if(GetControlValue(items[8]))		operation->flags |= kOperationFlag_Warning;				XGetDialogItemText(items[9], operation->note, kStr255MaxLength);				if(operation->customData[0] && !FastEqualString(operation->customData, customInfoCache, false))		BlockMove(operation->customData, data->lastCustomData, 64);	}		DisposeDialog(theDialog);	SetPort(savePort);		if(itemHit == 2)	return false;		//Update	GetDateTime(&operation->lastEditDate);	if(!automaticMode && operation->id && (operation->date != dateCache))	data->operationListSorted = false;		return true;}Boolean Account::AddOperation(OperationPtr operation){	OperationListPtr	temp;	long				i;	#if __DEMO__	if(data->operations->count >= kAccount_MaxOperations)	return false;#endif	//Allocate memory	if(data->operations->count >= data->operations->bufferCount) {		temp = (OperationListPtr) NewPtr(sizeof(OperationList) + (data->operations->bufferCount + kOperationBlockSize) * sizeof(Operation));		if(temp == NULL) {			application->errorManager->StandardError(27);			return false;		}		BlockMove(data->operations, temp, sizeof(OperationList) + data->operations->bufferCount * sizeof(Operation));		DisposePtr((Ptr) data->operations);		data->operations = temp;		data->operations->bufferCount += kOperationBlockSize;	}		//Create unique ID	operation->id = application->GenerateUniqueID();		//Note operation edit date	GetDateTime(&operation->lastEditDate);		//Add operation to list at the correct place	if(!data->operations->count || (operation->date >= data->operations->list[data->operations->count - 1].date))	data->operations->list[data->operations->count] = *operation;	else {		for(i = 0; i < data->operations->count; ++i)		if(operation->date < data->operations->list[i].date) {			BlockMove(&data->operations->list[i], &data->operations->list[i + 1], (data->operations->count - i) * sizeof(Operation));			data->operations->list[i] = *operation;			break;		}	}	++data->operations->count;		return true;}ID Account::NewOperation(){	Operation			theOperation;	//Clear operation	BlockZero(&theOperation, sizeof(Operation));	XGetIndString(theOperation.description, kMiscStringResID, 12);	GetDateTime(&theOperation.date);	theOperation.flags |= kOperationFlag_Expense;	New:		//Edit operation	if(!EditOperation(&theOperation))	return kUndefinedID;		//Add operation to list	if(!AddOperation(&theOperation))	return kUndefinedID;		//Check for option down with last event	if(lastModalDialogEvent.modifiers & optionKey) {		application->windowServer->Invalidate(kUndefinedID, 1, &theOperation.id);		if(appPrefs->flags & kPreferencesFlag_AutoSave)		application->WriteAccountToDisk(this);		goto New;	}		return theOperation.id;}Boolean Account::DeleteOperation(ID id){	long				num = kUndefinedNum;	long				i;		//Find operation	for(i = 0; i < data->operations->count; ++i)	if(data->operations->list[i].id == id) {		num = i;		break;	}	if(num == kUndefinedNum)	return false;		//Remove operation from list	if(num != data->operations->count - 1)	BlockMoveData(&data->operations->list[num + 1], &data->operations->list[num], (data->operations->count - num - 1) * sizeof(Operation));	--data->operations->count;		//Shorten buffer	if(data->operations->bufferCount > data->operations->count + kOperationBlockSize) {		data->operations->bufferCount -= kOperationBlockSize;		SetPtrSize((Ptr) data->operations, sizeof(OperationList) + data->operations->bufferCount * sizeof(Operation));	}		return true;}OperationPtr Account::BuildOperationLinkedList(StringPtr filter){	PaymentListPtr		payments = appPrefs->payments;	CategoryListPtr		categories = appPrefs->categories;	Amount				balance = 0;	OperationPtr		list = NULL,						item = NULL;	long				i,						j;	Boolean				exchanged;	OperationPtr		operation;	Operation			temp;		//Sort operations by date then ID - required for progressive balance computations	if(!data->operationListSorted) {#if 1		long		pass = 0;				//2 directions bubble sort		while(1) {			exchanged = false;			for(j = pass; j < data->operations->count - 1 - pass; ++j) {				if((data->operations->list[j + 1].date < data->operations->list[j].date)					|| ((data->operations->list[j + 1].date == data->operations->list[j].date) && (data->operations->list[j + 1].id < data->operations->list[j].id))) {					temp = data->operations->list[j];					data->operations->list[j] = data->operations->list[j + 1];					data->operations->list[j + 1] = temp;					exchanged = true;				}			}			if(!exchanged)			break;						exchanged = false;			for(j = data->operations->count - 1 - pass; j > pass; --j) {				if((data->operations->list[j - 1].date > data->operations->list[j].date)					|| ((data->operations->list[j - 1].date == data->operations->list[j].date) && (data->operations->list[j - 1].id > data->operations->list[j].id))) {					temp = data->operations->list[j];					data->operations->list[j] = data->operations->list[j - 1];					data->operations->list[j - 1] = temp;					exchanged = true;				}			}			if(!exchanged)			break;		}#else		//Bubble sort		for(i = 0; i < data->operations->count - 1; ++i) {			exchanged = false;			for(j = 0; j < data->operations->count - 1 - i; ++j) {				if((data->operations->list[j + 1].date < data->operations->list[j].date)					|| ((data->operations->list[j + 1].date == data->operations->list[j].date) && (data->operations->list[j + 1].id < data->operations->list[j].id))) {					temp = data->operations->list[j];					data->operations->list[j] = data->operations->list[j + 1];					data->operations->list[j + 1] = temp;					exchanged = true;				}			}			if(!exchanged)			break;		}#endif	}		//Scan operations	operation = data->operations->list;	for(i = 0; i < data->operations->count; ++i, ++operation) {		//Cache values		operation->owner = this;		operation->categoryNum = IDToCategoryNum(categories, operation->category);		operation->paymentTypeNum = IDToPaymentTypeNum(payments, operation->paymentType);		operation->absoluteAmount = GetAbsoluteOperationAmount(operation);				//Update balance		balance += operation->absoluteAmount;				//Text filter operation		if(filter && !FilterOperation(operation, filter, categories, payments))		continue;				//Append operation		if(list == NULL)		list = operation;		if(item != NULL)		item->next = operation;		operation->prev = item;		operation->next = NULL;		operation->balance = balance;				item = operation;	}		return list;}Boolean Account::IsLocked(){	return _locked;}Amount Account::GetBalance(short balanceType){	long				i;	Amount				balance = 0;	OperationPtr		operation;		//Scan operations	operation = data->operations->list;	for(i = 0; i < data->operations->count; ++i, ++operation) {		if((balanceType == kBalanceType_Reconciled) && !(operation->flags & kOperationFlag_Checked))		continue;		if((balanceType == kBalanceType_Current) && (DateToDay(operation->date) > application->today))		continue;				if(operation->flags & kOperationFlag_Expense)		balance -= operation->amount;		else		balance += operation->amount;	}		return balance;}