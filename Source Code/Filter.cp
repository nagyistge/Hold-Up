/***************************************************************************** * Copyright (c) 1999-2002, Pierre-Olivier Latour * http://www.pol-online.net * info@pol-online.net * * This program is free software; you can redistribute it and/or modify * it under the terms of the GNU General Public License as published by * the Free Software Foundation; either version 2 of the License, or * (at your option) any later version. *  * This program is distributed in the hope that it will be useful, * but WITHOUT ANY WARRANTY; without even the implied warranty of * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the * GNU General Public License for more details. * * You should have received a copy of the GNU General Public License * along with this program; if not, write to the Free Software * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111, USA. *****************************************************************************/#include			"Filter.h"#include			"Utils.h"#include			"File Utils.h"#include			"Dialog Utils.h"#include			"Preferences.h"#if !__DEMO__ && !__DEBUG__#include			"Serial Number.h"#endif//CONSTANTS:#define				kEditDialogID				135#define				kTabItemID					3#define				kNumItems					3#define				kGeneralID					700#define				kCriterionID				701//ROUTINES:inline void XEnableControl(DialogPtr dialog, short itemNum){	ControlHandle			item;		GetDialogItemAsControl(dialog, itemNum, &item);	HiliteControl(item, 0);}inline void XDisableControl(DialogPtr dialog, short itemNum){	ControlHandle			item;		GetDialogItemAsControl(dialog, itemNum, &item);	HiliteControl(item, 255);}Filter::Filter(){	data = NULL;	_file.name[0] = 0;	_locked = true;}Filter::~Filter(){	//Release memory	_ReleaseFilterMemory();}void Filter::_ReleaseFilterMemory(){	if(data)	DisposePtr((Ptr) data);	data = NULL;}OSErr Filter::CreateNew(){	//Release memory	_ReleaseFilterMemory();		//Allocate memory	data = (FilterDataPtr) NewPtrClear(sizeof(FilterData));	if(data == NULL)	return MemError();		//Set data	data->version = kFilter_Version;	XGetIndString(data->name, kMiscStringResID, 15);	data->flags = kFilterFlag_RelativeDate;	data->firstLine = 0;	GetDateTime(&data->dateMin);	data->dateMax = data->dateMin;		//Create unique ID	data->id = application->GenerateUniqueID();		//Clear previous file	_file.name[0] = 0;		//Set lock	_locked = true;		return noErr;}OSErr Filter::WriteToDisk(FSSpec* folder){	OSErr			theError;	short			fileID;	FSSpec			tempFile;	Str63			newName;		if(data == NULL)	return paramErr;		//Create new file location	tempFile = *folder;	SetTempFileName(tempFile.name);		//Update save date	GetDateTime(&data->saveDate);		//Create temp file	theError = FSpCreate(&tempFile, kFilter_FileCreator, kFilter_FileType, smSystemScript);	if(theError)	return theError;		//Open file	theError = FSpOpenDF(&tempFile, fsRdWrPerm, &fileID);	if(theError)	return theError;		//Write data	SetFPos(fileID, fsFromStart, 0);	theError = WritePtr(fileID, data);		//Close file	FSClose(fileID);		//Swap files	if(theError)	FSpDelete(&tempFile);	else {		//Delete original file		if(_file.name[0])		FSpDelete(&_file);				//Build file name		BlockMove(data->name, newName, sizeof(Str63));		if(newName[0] > kMaxFileNameChars)		newName[0] = kMaxFileNameChars;				//Rename temp file		theError = FSpRename(&tempFile, newName);		_file = tempFile;		if(theError == noErr)		BlockMove(newName, _file.name, sizeof(Str63));	}		return theError;}OSErr Filter::ReadFromDisk(FSSpec* file){	OSErr		theError;	short		fileID;		//Release memory	_ReleaseFilterMemory();		//Open file	theError = FSpOpenDF(file, fsRdPerm, &fileID);	if(theError)	return theError;		//Read data	SetFPos(fileID, fsFromStart, 0);	theError = ReadPtr(fileID, (void**) &data);	if(theError)	_ReleaseFilterMemory();		//Close file	_file = *file;	FSClose(fileID);		//Check version	if(data->version != kFilter_Version) {		if(data->version == 0x0000) {			;		}		else {			_ReleaseFilterMemory();			return paramErr;		}	}		//Set lock	_locked = true;		return theError;}OSErr Filter::RemoveFromDisk(){	if(!_file.name[0])	return noErr;		return FSpDelete(&_file);}void Filter::_ShowPane_General(DialogPtr dialog, short offset){	ControlHandle		items[3];	long				i;		//Update menu	AccountMenu_Update(true);		//Append DITL pane	AppendDialogItemList(dialog, kGeneralID, overlayDITL);		//Get items	for(i = 0; i < 3; ++i)	GetDialogItemAsControl(dialog, offset + 1 + i, &items[i]);		//Set items	XSetDialogItemText(items[0], data->name);	SetControlValue(items[1], AccountMenu_SetChoice(data->targetAccount));	XSetDialogItemText(items[2], data->note);		SelectDialogItemText(dialog, offset + 1, 0, 32000);}void Filter::_HidePane_General(DialogPtr dialog, short offset){	ControlHandle		items[3];	long				i;		//Get items	for(i = 0; i < 3; ++i)	GetDialogItemAsControl(dialog, offset + 1 + i, &items[i]);		XGetDialogItemText(items[0], data->name, kStr255MaxLength);	data->targetAccount = AccountMenu_GetChoice(GetControlValue(items[1]));	XGetDialogItemText(items[2], data->note, kStr255MaxLength);		//Remove DITL pane	ShortenDITL(dialog, CountDITL(dialog) - offset);}void Filter::_ShowPane_Criterion(DialogPtr dialog, short offset){	ControlHandle		items[19];	long				i;		//Update menus	CategoriesMenu_Update(false);	PaymentTypesMenu_Update(false);		//Append DITL pane	AppendDialogItemList(dialog, kCriterionID, overlayDITL);		//Get items	for(i = 0; i < 19; ++i)	GetDialogItemAsControl(dialog, offset + 8 + i, &items[i]); //Warning: start at 8!		//Set items	XSetDialogItemText(items[0], data->descriptionMask);		SetControlMaximum(items[1], 2);	if(data->setFlagsMask & kOperationFlag_Expense)	SetControlValue(items[1], 1);	else if(!(data->clearFlagsMask & kOperationFlag_Expense))	SetControlValue(items[1], 2);		SetControlMaximum(items[2], 2);	if(data->setFlagsMask & kOperationFlag_Checked)	SetControlValue(items[2], 1);	else if(!(data->clearFlagsMask & kOperationFlag_Checked))	SetControlValue(items[2], 2);		SetControlMaximum(items[3], 2);	if(data->setFlagsMask & kOperationFlag_Warning)	SetControlValue(items[3], 1);	else if(!(data->clearFlagsMask & kOperationFlag_Warning))	SetControlValue(items[3], 2);		SetControlValue(items[4], CategoriesMenu_SetChoice(data->categoryMask));	SetControlValue(items[5], PaymentTypesMenu_SetChoice(data->paymentTypeMask));		XSetDialogItemAmount(items[6], data->amountMin, true);	XSetDialogItemAmount(items[7], data->amountMax, true);		SetControlValue(items[10], data->relativeDate);	SetClockDateTime(items[11], data->dateMin);	SetClockDateTime(items[12], data->dateMax);		if(data->flags & kFilterFlag_RelativeDate) {		SetControlValue(items[8], 1);		XDisableControl(dialog, offset + 6);		XDisableControl(dialog, offset + 7);		XDisableControl(dialog, offset + 19);		XDisableControl(dialog, offset + 20);	}	else {		SetControlValue(items[9], 1);		XDisableControl(dialog, offset + 18);	}		if(data->flags & kFilterFlag_Name)	SetControlValue(items[13], 1);	else {		XDisableControl(dialog, offset + 1);		XDisableControl(dialog, offset + 8);	}	if(data->flags & kFilterFlag_Flags)	SetControlValue(items[14], 1);	else {		XDisableControl(dialog, offset + 9);		XDisableControl(dialog, offset + 10);		XDisableControl(dialog, offset + 11);	}	if((data->flags & kFilterFlag_Category) && appPrefs->categories->count)	SetControlValue(items[15], 1);	else {		if(!appPrefs->categories->count)		HiliteControl(items[15], 255);		XDisableControl(dialog, offset + 2);		XDisableControl(dialog, offset + 12);	}	if((data->flags & kFilterFlag_PaymentType) && appPrefs->payments->count)	SetControlValue(items[16], 1);	else {		if(!appPrefs->payments->count)		HiliteControl(items[16], 255);		XDisableControl(dialog, offset + 3);		XDisableControl(dialog, offset + 13);	}	if(data->flags & kFilterFlag_Amount)	SetControlValue(items[17], 1);	else {		XDisableControl(dialog, offset + 4);		XDisableControl(dialog, offset + 5);		XDisableControl(dialog, offset + 14);		XDisableControl(dialog, offset + 15);	}	if(data->flags & kFilterFlag_Date)	SetControlValue(items[18], 1);	else {		XDisableControl(dialog, offset + 6);		XDisableControl(dialog, offset + 7);		XDisableControl(dialog, offset + 16);		XDisableControl(dialog, offset + 17);		XDisableControl(dialog, offset + 18);		XDisableControl(dialog, offset + 19);		XDisableControl(dialog, offset + 20);	}		SelectDialogItemText(dialog, offset + 8, 0, 32000);	InstallNumericKeyFilter(items[6]);	InstallNumericKeyFilter(items[7]);	#if TARGET_API_MAC_CARBON	DrawDialog(dialog);#endif}void Filter::_ClickPane_Criterion(DialogPtr dialog, short itemHit, short offset){	ControlHandle			item;		switch(itemHit) {				case 9:		case 10:		case 11:		GetDialogItemAsControl(dialog, offset + itemHit, &item);		SetControlValue(item, (GetControlValue(item) + 1) % 3);		break;				case 16:		GetDialogItemAsControl(dialog, offset + 16, &item);		SetControlValue(item, 1);		GetDialogItemAsControl(dialog, offset + 17, &item);		SetControlValue(item, 0);		XEnableControl(dialog, offset + 18);		XDisableControl(dialog, offset + 6);		XDisableControl(dialog, offset + 7);		XDisableControl(dialog, offset + 19);		XDisableControl(dialog, offset + 20);		break;				case 17:		GetDialogItemAsControl(dialog, offset + 16, &item);		SetControlValue(item, 0);		GetDialogItemAsControl(dialog, offset + 17, &item);		SetControlValue(item, 1);		XDisableControl(dialog, offset + 18);		XEnableControl(dialog, offset + 6);		XEnableControl(dialog, offset + 7);		XEnableControl(dialog, offset + 19);		XEnableControl(dialog, offset + 20);		break;				case 19:		GetDialogItemAsControl(dialog, offset + itemHit, &item);		GetClockDateTime(item, &data->dateMin);		break;				case 20:		GetDialogItemAsControl(dialog, offset + itemHit, &item);		GetClockDateTime(item, &data->dateMax);		break;				case 21:		GetDialogItemAsControl(dialog, offset + itemHit, &item);		if(GetControlValue(item)) {			SetControlValue(item, 0);			XDisableControl(dialog, offset + 1);			XDisableControl(dialog, offset + 8);		}		else {			SetControlValue(item, 1);			XEnableControl(dialog, offset + 1);			XEnableControl(dialog, offset + 8);		}		break;				case 22:		GetDialogItemAsControl(dialog, offset + itemHit, &item);		if(GetControlValue(item)) {			SetControlValue(item, 0);			XDisableControl(dialog, offset + 9);			XDisableControl(dialog, offset + 10);			XDisableControl(dialog, offset + 11);		}		else {			SetControlValue(item, 1);			XEnableControl(dialog, offset + 9);			XEnableControl(dialog, offset + 10);			XEnableControl(dialog, offset + 11);		}		break;				case 23:		GetDialogItemAsControl(dialog, offset + itemHit, &item);		if(GetControlValue(item)) {			SetControlValue(item, 0);			XDisableControl(dialog, offset + 2);			XDisableControl(dialog, offset + 12);		}		else {			SetControlValue(item, 1);			XEnableControl(dialog, offset + 2);			XEnableControl(dialog, offset + 12);		}		break;				case 24:		GetDialogItemAsControl(dialog, offset + itemHit, &item);		if(GetControlValue(item)) {			SetControlValue(item, 0);			XDisableControl(dialog, offset + 3);			XDisableControl(dialog, offset + 13);		}		else {			SetControlValue(item, 1);			XEnableControl(dialog, offset + 3);			XEnableControl(dialog, offset + 13);		}		break;				case 25:		GetDialogItemAsControl(dialog, offset + itemHit, &item);		if(GetControlValue(item)) {			SetControlValue(item, 0);			XDisableControl(dialog, offset + 4);			XDisableControl(dialog, offset + 5);			XDisableControl(dialog, offset + 14);			XDisableControl(dialog, offset + 15);		}		else {			SetControlValue(item, 1);			XEnableControl(dialog, offset + 4);			XEnableControl(dialog, offset + 5);			XEnableControl(dialog, offset + 14);			XEnableControl(dialog, offset + 15);		}		break;				case 26:		GetDialogItemAsControl(dialog, offset + itemHit, &item);		if(GetControlValue(item)) {			SetControlValue(item, 0);			XDisableControl(dialog, offset + 16);			XDisableControl(dialog, offset + 17);						XDisableControl(dialog, offset + 6);			XDisableControl(dialog, offset + 7);			XDisableControl(dialog, offset + 18);			XDisableControl(dialog, offset + 19);			XDisableControl(dialog, offset + 20);		}		else {			SetControlValue(item, 1);			XEnableControl(dialog, offset + 16);			XEnableControl(dialog, offset + 17);						GetDialogItemAsControl(dialog, offset + 16, &item);			if(GetControlValue(item))			XEnableControl(dialog, offset + 18);			else {				XEnableControl(dialog, offset + 6);				XEnableControl(dialog, offset + 7);				XEnableControl(dialog, offset + 19);				XEnableControl(dialog, offset + 20);			}		}		break;			}}void Filter::_HidePane_Criterion(DialogPtr dialog, short offset){	ControlHandle		items[19];	long				i;		//Get items	for(i = 0; i < 19; ++i)	GetDialogItemAsControl(dialog, offset + 8 + i, &items[i]); //Warning: start at 8!		data->flags = 0;	data->setFlagsMask = 0;	data->clearFlagsMask = 0;		XGetDialogItemText(items[0], data->descriptionMask, kStr63MaxLength);		if(GetControlValue(items[1]) == 1)	data->setFlagsMask |= kOperationFlag_Expense;	else if(GetControlValue(items[1]) == 0)	data->clearFlagsMask |= kOperationFlag_Expense;		if(GetControlValue(items[2]) == 1)	data->setFlagsMask |= kOperationFlag_Checked;	else if(GetControlValue(items[2]) == 0)	data->clearFlagsMask |= kOperationFlag_Checked;		if(GetControlValue(items[3]) == 1)	data->setFlagsMask |= kOperationFlag_Warning;	else if(GetControlValue(items[3]) == 0)	data->clearFlagsMask |= kOperationFlag_Warning;		data->categoryMask = CategoriesMenu_GetChoice(GetControlValue(items[4]));	data->paymentTypeMask = PaymentTypesMenu_GetChoice(GetControlValue(items[5]));		XGetDialogItemAmount(items[6], &data->amountMin);	XGetDialogItemAmount(items[7], &data->amountMax);		if(GetControlValue(items[8]))	data->flags |= kFilterFlag_RelativeDate;	data->relativeDate = GetControlValue(items[10]);		//Bug workaround	//GetClockDateTime(items[11], &data->dateMin);	//GetClockDateTime(items[12], &data->dateMax);		if(GetControlValue(items[13]))	data->flags |= kFilterFlag_Name;	if(GetControlValue(items[14]))	data->flags |= kFilterFlag_Flags;	if(GetControlValue(items[15]))	data->flags |= kFilterFlag_Category;	if(GetControlValue(items[16]))	data->flags |= kFilterFlag_PaymentType;	if(GetControlValue(items[17]))	data->flags |= kFilterFlag_Amount;	if(GetControlValue(items[18]))	data->flags |= kFilterFlag_Date;		//Remove DITL pane	ShortenDITL(dialog, CountDITL(dialog) - offset);}static Boolean FilterNameIsUnique(FilterPtr filter){	long					i;	Boolean					unique = true;		if(!filter->data->name[0])	return false;		for(i = 0; i < application->filterCount; ++i)	if(application->filterList[i] != filter) {		if(EqualFileNames(filter->data->name, application->filterList[i]->data->name)) {			unique = false;			break;		}	}		if(unique)	for(i = 0; i < application->accountCount; ++i)	if(EqualFileNames(filter->data->name, application->accountList[i]->data->name)) {		unique = false;		break;	}		return unique;}Boolean Filter::EditInfo(){	FilterData				copy;	GrafPtr					savePort;	DialogPtr				theDialog;	ControlHandle			tabItem;	short					itemHit,							curPane = 1;								//Backup current preferences	BlockMove(data, &copy, sizeof(FilterData));		//Display dialog	GetPort(&savePort);	theDialog = GetNewDialog(kEditDialogID, nil, (WindowPtr) -1);	SetPortDialogPort(theDialog);	NormalizeThemeDrawingState();	GetDialogItemAsControl(theDialog, kTabItemID, &tabItem);		_ShowPane_General(theDialog, kNumItems);	SetControlValue((ControlHandle) tabItem, 1);		SetDialogDefaultItem(theDialog, 1);	SetDialogCancelItem(theDialog, 2);		//Run	do {		//Get dialog events		ModalDialog(ModalDialogRoutine, &itemHit);		if(itemHit > kNumItems) {			if(curPane == 2)			_ClickPane_Criterion(theDialog, itemHit - kNumItems, kNumItems);		}		else if(itemHit == kTabItemID) { //Tab switch			if(curPane == 1) {				_HidePane_General(theDialog, kNumItems);				if(!FilterNameIsUnique(this)) {					SetControlValue(tabItem, 1);					_ShowPane_General(theDialog, kNumItems);					application->errorManager->StandardError(44, (void*) data->name);					itemHit = 0;					continue;				}			}			else if(curPane == 2)			_HidePane_Criterion(theDialog, kNumItems);						//Get new pane			curPane = GetControlValue(tabItem);						//Display			if(curPane == 1)			_ShowPane_General(theDialog, kNumItems);			else if(curPane == 2)			_ShowPane_Criterion(theDialog, kNumItems);		}		else if(itemHit == 1) {			if(curPane == 1) {				_HidePane_General(theDialog, kNumItems);				if(!FilterNameIsUnique(this)) {					SetControlValue(tabItem, 1);					_ShowPane_General(theDialog, kNumItems);					application->errorManager->StandardError(44, (void*) data->name);					itemHit = 0;					continue;				}			}			else if(curPane == 2)			_HidePane_Criterion(theDialog, kNumItems);		}	} while((itemHit != 1) && (itemHit != 2));		DisposeDialog(theDialog);	SetPort(savePort);		//Has the user clicked cancel?	if(itemHit == 2) {		BlockMove(&copy, data, sizeof(FilterData));		return false;	}		return true;}Boolean Filter::Unlock(long accountCount, AccountPtr accountList[]){	long				i;		if(!_locked)	return true;		//Make sure accounts the filter targets to are unlocked	for(i = 0; i < accountCount; ++i) {		if((data->targetAccount != kUndefinedID) && (accountList[i]->data->id != data->targetAccount))		continue;		if(!accountList[i]->Unlock())		return false;	}		_locked = false;	return true;}OperationPtr Filter::BuildOperationLinkedList(long accountCount, AccountPtr accountList[], StringPtr filter){	OperationPtr		list = NULL,						item = NULL;	PaymentListPtr		payments = appPrefs->payments;	CategoryListPtr		categories = appPrefs->categories;	Boolean				filterDate = false;	OperationPtr		operation;	long				i,						j;	DateTimeRec			temp;	Date				dateMin,						dateMax;		//Compute dates	if(data->flags & kFilterFlag_Date) {		if(data->flags & kFilterFlag_RelativeDate) {			GetDateTime(&dateMin);			SecondsToDate(dateMin, &temp);			switch(data->relativeDate) {								case kFilterRelativeDate_Day:				case kFilterRelativeDate_LastDay:				if(data->relativeDate == kFilterRelativeDate_LastDay)				temp.day -= 1;				break;								case kFilterRelativeDate_Week: //Week start on Monday!				case kFilterRelativeDate_LastWeek:				if(temp.dayOfWeek == 1)				temp.day -= 6;				else				temp.day -= temp.dayOfWeek - 2;				if(data->relativeDate == kFilterRelativeDate_LastWeek)				temp.day -= 7;				break;								case kFilterRelativeDate_Month:				case kFilterRelativeDate_LastMonth:				temp.day = 1;				if(data->relativeDate == kFilterRelativeDate_LastMonth)				temp.month -= 1;				break;								case kFilterRelativeDate_Year:				case kFilterRelativeDate_LastYear:				temp.month = 1;				temp.day = 1;				if(data->relativeDate == kFilterRelativeDate_LastYear)				temp.year -= 1;				break;							}			DateToSeconds(&temp, &dateMin);						switch(data->relativeDate) {								case kFilterRelativeDate_Day:				case kFilterRelativeDate_LastDay:				;				break;								case kFilterRelativeDate_Week:				case kFilterRelativeDate_LastWeek:				temp.day += 7;				temp.day -= 1;				break;								case kFilterRelativeDate_Month:				case kFilterRelativeDate_LastMonth:				temp.month += 1;				temp.day -= 1;				break;								case kFilterRelativeDate_Year:				case kFilterRelativeDate_LastYear:				temp.year += 1;				temp.day -= 1;				break;							}			DateToSeconds(&temp, &dateMax);		}		else {			dateMin = data->dateMin;			dateMax = data->dateMax;		}		dateMin = DateToDay(dateMin);		dateMax = DateToDay(dateMax);		filterDate = true;	}		//Scan accounts	for(i = 0; i < accountCount; ++i) {		//Find target account		if((data->targetAccount != kUndefinedID) && (accountList[i]->data->id != data->targetAccount))		continue;				//Scan operations		operation = accountList[i]->data->operations->list;		for(j = 0; j < accountList[i]->data->operations->count; ++j, ++operation) {			//Cache values			operation->owner = accountList[i];			operation->categoryNum = IDToCategoryNum(categories, operation->category);			operation->paymentTypeNum = IDToPaymentTypeNum(payments, operation->paymentType);			operation->absoluteAmount = GetAbsoluteOperationAmount(operation);					//Text filter operation			if(filter && !FilterOperation(operation, filter, categories, payments))			continue;						//Apply filtering			if((data->flags & kFilterFlag_Name) && !StringInString(operation->description, data->descriptionMask))			continue;			if(data->flags & kFilterFlag_Flags) {				if((operation->flags & data->setFlagsMask) != data->setFlagsMask)				continue;				if(operation->flags & data->clearFlagsMask)				continue;			}			if((data->flags & kFilterFlag_Category) && (operation->category != data->categoryMask))			continue;			if((data->flags & kFilterFlag_PaymentType) && (operation->paymentType != data->paymentTypeMask))			continue;			if((data->flags & kFilterFlag_Amount) && ((operation->absoluteAmount < data->amountMin) || (operation->absoluteAmount > data->amountMax)))			continue;			if(filterDate && ((DateToDay(operation->date) < dateMin) || (DateToDay(operation->date) > dateMax)))			continue;						//Append operation			if(list == NULL)			list = operation;			if(item != NULL)			item->next = operation;			operation->prev = item;			operation->next = NULL;						item = operation;		}	}	return list;}Boolean Filter::IsLocked(long accountCount, AccountPtr accountList[]){	long			i;		//Make sure accounts the filter targets to are unlocked	for(i = 0; i < accountCount; ++i) {		if((data->targetAccount != kUndefinedID) && (accountList[i]->data->id != data->targetAccount))		continue;		if(accountList[i]->IsLocked())		return true;	}		return false;}