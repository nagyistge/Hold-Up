/***************************************************************************** * Copyright (c) 1999-2002, Pierre-Olivier Latour * http://www.pol-online.net * info@pol-online.net * * This program is free software; you can redistribute it and/or modify * it under the terms of the GNU General Public License as published by * the Free Software Foundation; either version 2 of the License, or * (at your option) any later version. *  * This program is distributed in the hope that it will be useful, * but WITHOUT ANY WARRANTY; without even the implied warranty of * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the * GNU General Public License for more details. * * You should have received a copy of the GNU General Public License * along with this program; if not, write to the Free Software * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111, USA. *****************************************************************************/#include			"Dialog Utils.h"#include			"Numeric Utils.h"#include			"Keys.h"//LOCAL VARIABLES:ControlKeyFilterUPP				_KeyFilterRoutine = NULL;ControlEditTextValidationUPP	_ValidationRoutine = NULL;static unsigned char			_decimalChar = 0,								_thousandChar = 0;//ROUTINES:#if !TARGET_API_MAC_CARBON#define RESULT_OFFSET(type) ((sizeof(type) == 1) ? 3 : ((sizeof(type) == 2) ? 1 : 0))pascal OSErr AppendDialogItemList(DialogPtr dialog, short ditlID, DITLMethod method){	long	private_result;		private_result = CallUniversalProc((UniversalProcPtr) GetToolTrapAddress(0xAA68),		kD0DispatchedPascalStackBased		 | RESULT_SIZE(SIZE_CODE(sizeof(OSErr)))		 | DISPATCHED_STACK_ROUTINE_SELECTOR_SIZE(kTwoByteCode)		 | DISPATCHED_STACK_ROUTINE_PARAMETER(1, SIZE_CODE(sizeof(dialog)))		 | DISPATCHED_STACK_ROUTINE_PARAMETER(2, SIZE_CODE(sizeof(ditlID)))		 | DISPATCHED_STACK_ROUTINE_PARAMETER(3, SIZE_CODE(sizeof(method))),		0x0412,		dialog,		ditlID,		method );			return *(((OSErr*)&private_result) + RESULT_OFFSET(OSErr));}#endifpascal OSStatus GetListBoxListHandle(ControlHandle control, ListHandle* list){	Size		actualSize;	OSStatus	err;		if ( control == nil )		return paramErr;			if ( list == nil )		return paramErr;			err = GetControlData( control, 0, kControlListBoxListHandleTag, sizeof( ListHandle ),			 (Ptr)list, &actualSize );			return err;}pascal OSStatus GetEditTextPasswordText(ControlHandle control, Str255 text){	Size		actualSize;	OSStatus	err;		if(control == nil)	return paramErr;	if(text == nil)	return paramErr;	err = GetControlData(control, 0, kControlEditTextPasswordTag, 255, &text[1], &actualSize);	if(err == noErr) {		if(actualSize > 255)		text[0] = 255;		else		text[0] = actualSize;	}	else	text[0] = 0;		return err;}pascal OSStatus SetClockDateTime(ControlHandle control, unsigned long time){	OSStatus			err;	LongDateTime		seconds;	LongDateRec			date;		if(control == nil)	return paramErr;		BlockZero(&date, sizeof(LongDateRec));		seconds = time;	LongSecondsToDate(&seconds, &date);	err = SetControlData(control, 0, kControlClockLongDateTag, sizeof(LongDateRec), (Ptr) &date);		return err;}pascal OSStatus GetClockDateTime(ControlHandle control, unsigned long* time){	Size				actualSize;	OSStatus			err;	LongDateRec			date;	LongDateTime		seconds;		if(control == nil)	return paramErr;	if(time == nil)	return paramErr;		BlockZero(&date, sizeof(LongDateRec));		err = GetControlData(control, 0, kControlClockLongDateTag, sizeof(LongDateRec), (Ptr) &date, &actualSize);	if(err == noErr)	LongDateToSeconds(&date, &seconds);	*time = seconds;		return err;}pascal OSStatus GetEditTextText(ControlHandle control, StringPtr text){	Size		actualSize;	OSStatus	err;		if(control == nil)	return paramErr;	if(text == nil)	return paramErr;			err = GetControlData(control, 0, kControlEditTextTextTag, 255, (Ptr) &text[1], &actualSize);	if(err == noErr) {		if(actualSize > 255)		text[0] = 255;		else		text[0] = actualSize;	}	else	text[0] = 0;			return err;}pascal OSStatus SetEditTextText(ControlHandle control, ConstStr255Param text){	OSStatus	err;		if(control == nil)	return paramErr;	err = SetControlData(control, 0, kControlEditTextTextTag, text[0], (Ptr) &text[1]);	if((err == noErr))	DrawOneControl(control);		return err;}pascal OSStatus SetEditTextSelection(ControlHandle control, SInt16 selStart, SInt16 selEnd){	ControlEditTextSelectionRec	selection;	OSStatus					err;	if(control == nil)	return paramErr;		selection.selStart = selStart;	selection.selEnd = selEnd;	err = SetControlData(control, 0, kControlEditTextSelectionTag, sizeof(selection), (Ptr) &selection);	if(err == noErr)	DrawOneControl(control);		return err;}void XSetDialogItemText(ControlHandle item, StringPtr text){	SetDialogItemText((Handle) item, text);}void XGetDialogItemText(ControlHandle item, StringPtr text, long maxLength){	Str255			temp;		GetDialogItemText((Handle) item, temp);	if(temp[0] > maxLength)	temp[0] = maxLength;	BlockMove(temp, text, temp[0] + 1);}void XSetDialogItemNum(ControlHandle item, long num){	Str255			text;		NumToString(num, text);	SetDialogItemText((Handle) item, text);}long XGetDialogItemNum(ControlHandle item){	Str255			text;	long			num;		GetDialogItemText((Handle) item, text);	StringToNum(text, &num);		return num;}void XSetDialogItemAmount(ControlHandle item, Amount num, Boolean decimalPart){	Str255			text;		AmountToString(num, text, 0, 0, decimalPart);	SetDialogItemText((Handle) item, text);}void XGetDialogItemAmount(ControlHandle item, Amount* num){	Str255			text;		GetDialogItemText((Handle) item, text);	StringToAmount(text, num, 0);}inline Boolean KeyValid(unsigned char theChar){	if((theChar >= '0') && (theChar <= '9'))	return true;	if((theChar == _decimalChar) || (theChar == _thousandChar) || (theChar == '-'))	return true;		return false;}static pascal ControlKeyFilterResult KeyFilter(ControlRef theControl, SInt16 *keyCode, SInt16 *charCode, EventModifiers *modifiers){	if(*modifiers & cmdKey)	return kControlKeyFilterPassKey;	if(KeyValid(*charCode))	return kControlKeyFilterPassKey;	if((*keyCode == keyBackSpace) || (*keyCode == keyDelete) || (*keyCode == keyArrowLeft)		 || (*keyCode == keyArrowRight) || (*keyCode == keyArrowUp) || (*keyCode == keyArrowDown))	return kControlKeyFilterPassKey;		SysBeep(0);		return kControlKeyFilterBlockKey;}static pascal void Validation(ControlRef control){	Str255			input,					output;	long			i;		GetDialogItemText((Handle) control, input);	output[0] = 0;	for(i = 1; i <= input[0]; ++i) {		if(KeyValid(input[i]))		output[++output[0]] = input[i];	}	SetDialogItemText((Handle) control, output);}void InstallNumericKeyFilter(ControlHandle control){	Intl0Hndl			iuSettings = nil;		if(!_decimalChar || !_thousandChar) {		iuSettings = (Intl0Hndl) GetIntlResource(0);		if(iuSettings != nil) {			_decimalChar = (**iuSettings).decimalPt;			_thousandChar = (**iuSettings).thousSep;		}		//Reset to US format		else {			_decimalChar = kDefaultDecimalChar;			_thousandChar = ',';		}	}		if(!_KeyFilterRoutine)	_KeyFilterRoutine = NewControlKeyFilterUPP(KeyFilter);	SetControlData(control, 0, kControlEditTextKeyFilterTag, sizeof(_KeyFilterRoutine), (Ptr) &_KeyFilterRoutine);		if(!_ValidationRoutine)	_ValidationRoutine = NewControlEditTextValidationUPP(Validation);	SetControlData(control, 0, kControlEditTextValidationProcTag, sizeof(_ValidationRoutine), (Ptr) &_ValidationRoutine);}