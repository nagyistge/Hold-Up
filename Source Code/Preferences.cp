/***************************************************************************** * Copyright (c) 1999-2002, Pierre-Olivier Latour * http://www.pol-online.net * info@pol-online.net * * This program is free software; you can redistribute it and/or modify * it under the terms of the GNU General Public License as published by * the Free Software Foundation; either version 2 of the License, or * (at your option) any later version. *  * This program is distributed in the hope that it will be useful, * but WITHOUT ANY WARRANTY; without even the implied warranty of * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the * GNU General Public License for more details. * * You should have received a copy of the GNU General Public License * along with this program; if not, write to the Free Software * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111, USA. *****************************************************************************/#if TARGET_API_MAC_CARBONextern pascal double_t pow(double_t x, double_t y);#else#include			<fp.h>#endif#include			"Preferences.h"#include			"Error Manager.h"#include			"Dialog Utils.h"#include			"Account.h"#include			"Navigation Utils.h"#include			"File Utils.h"#include			"Window Server.h"#include			"Utils.h"#if !__DEMO__ && !__DEBUG__#include			"Serial Number.h"#endif//CONSTANTES:#define				kPaymentResType				'pymt'#define				kCategoryResType			'catg'#define				kMacroResType				'ccnv'#define				kPreferenceDialogID			128#define				kTabItemID					3#define				kNumItems					3#define				kGeneralID					500#define				kPaymentsID					501#define				kCategoriesID				502#define				kPrintID					503#define				kMacrosID					504#define				kSerialNumberDialogID		138#define				kColumnDefaultAttributeFlags	(kColumnFlag_Sortable | kColumnFlag_HasSeparator | kColumnFlag_Movable | kColumnFlag_Resizable)//ROUTINES:static void GetEmptyPaymentName(StringPtr text, ID id){	Str31					temp;		XGetIndString(text, kMiscStringResID, 32);	NumToString(id, temp);	if(temp[0] == 1)	text[++text[0]] = '0';	AppendString(text, temp);}static void GetEmptyCategoryName(StringPtr text, ID id){	Str31					temp;		XGetIndString(text, kMiscStringResID, 28);	NumToString(id, temp);	if(temp[0] == 1)	text[++text[0]] = '0';	AppendString(text, temp);}static void Sort_PaymentTypes(PaymentListPtr payments){	PaymentType			temp;	long				i,						j;		//Bubble sort	for(i = 0; i < payments->count - 1; ++i)	for(j = 0; j < payments->count - 1 - i; ++j) {		if(FastCompareString(payments->list[j].name, payments->list[j + 1].name) == 1) {			temp = payments->list[j];			payments->list[j] = payments->list[j + 1];			payments->list[j + 1] = temp;		}	}}static void Sort_Categories(CategoryListPtr categories){	Category			temp;	long				i,						j;		//Bubble sort	for(i = 0; i < categories->count - 1; ++i)	for(j = 0; j < categories->count - 1 - i; ++j) {		if(FastCompareString(categories->list[j].name, categories->list[j + 1].name) == 1) {			temp = categories->list[j];			categories->list[j] = categories->list[j + 1];			categories->list[j + 1] = temp;		}	}}#if !__DEMO__ && !__DEBUG__static Boolean GetSerialNumber(ErrorManagerPtr errorManager, StringPtr sn){	GrafPtr					savePort;	DialogPtr				theDialog;	ControlHandle			item;	short					itemHit;								//Display dialog	GetPort(&savePort);	theDialog = GetNewDialog(kSerialNumberDialogID, nil, (WindowPtr) -1);	SetPortDialogPort(theDialog);	NormalizeThemeDrawingState();		GetDialogItemAsControl(theDialog, 3, &item);		SetDialogDefaultItem(theDialog, 1);	SetDialogCancelItem(theDialog, 2);	SelectDialogItemText(theDialog, 3, 0, 32000);		//Run	do {		//Get dialog events		ModalDialog(ModalDialogRoutine, &itemHit);				//Check SN		if(itemHit == 1) {			XGetDialogItemText(item, sn, kStr31MaxLength);			if(!SNValid(sn, kSNMagic)) {				errorManager->StandardError(56);				SelectDialogItemText(theDialog, 3, 0, 32000);				itemHit = 0;			}		}	} while((itemHit != 1) && (itemHit != 2));		DisposeDialog(theDialog);	SetPort(savePort);		//Has the user clicked cancel?	if(itemHit == 2)	return false;		return true;}#endifPreferences::Preferences(ErrorManagerPtr errorManager, Handle* printSettings, Boolean* isTHPrint){	OSErr		theError;#if !__DEMO__	Str255		text;#endif	//Clear data	data = NULL;	*printSettings = NULL;	*isTHPrint = false;		//Read the prefs	theError = _ReadFromDisk(printSettings, isTHPrint);	if(theError) {		if(theError != fnfErr) {			if(theError == paramErr)			errorManager->StandardError(17);			else			errorManager->StandardError(16, (void*) theError);		}		data = _CreateDefaultPrefs();	}	if(data == NULL)	return;		//Find the account folder#if !__DEMO__	if(data->flags & kPreferencesFlag_CustomAccountFolder) {		if(FolderExists(data->accountFolder.vRefNum, data->accountFolder.parID))		theError = noErr;		else		theError = fnfErr;	}	else#endif	theError = GetDefaultAccountFolder(&data->accountFolder);#if !__DEMO__	if(theError) {		XGetIndString(text, kMiscStringResID, 10);		theError = NavigationChooseFolder(&data->accountFolder, text);	}#endif	if(theError)	errorManager->FatalError(12, (void*) theError);#if !__DEMO__ && !__DEBUG__	//Make sure user is registered	if(!SNValid(data->serialNumber, kSNMagic)) {		if(!GetSerialNumber(errorManager, data->serialNumber))		ExitToShell();		XGetIndString(text, kMiscStringResID, 7);		errorManager->Note(57, text);	}#endif}Preferences::~Preferences(){	//Release memory	if(data)	_ReleasePrefsMemory(data);}static Ptr ResourceToPtr(OSType type){	Handle			data;	Ptr				ptr;		data = Get1IndResource(type, 1);	if(data == NULL)	return NULL;		ptr = NewPtr(GetHandleSize(data));	if(ptr != NULL)	BlockMove(*data, ptr, GetHandleSize(data));	ReleaseResource(data);		return ptr;}PreferencesDataPtr Preferences::_CreateDefaultPrefs(){	Intl0Hndl				iuSettings = nil;	ColumnInfoPtr			accountsColumns;	ColumnInfoPtr			operationsColumns;	PreferencesDataPtr		prefs;	long					i;		//Allocate memory	prefs = (PreferencesDataPtr) NewPtrClear(sizeof(PreferencesData));	if(prefs == NULL)	return NULL;	accountsColumns = prefs->accountsColumns;	operationsColumns = prefs->operationsColumns;		//Set data	prefs->version = kPreferences_Version;	prefs->flags = kPreferencesFlag_DisplayNoteTags | kPreferencesFlag_DeleteConfirmation | kPreferencesFlag_AutoSave	 | kPreferencesFlag_DisplayCurrencySymbol;	prefs->serialNumber[0] = 0;	prefs->skinResID = kSkinStartResID;		//Create 2 account columns	accountsColumns[0].id = kAccountColumn_Icon;	accountsColumns[0].flags = kColumnFlag_Visible;	accountsColumns[0].width = 20;	accountsColumns[0].textAlignement = kTextAlign_Left;		accountsColumns[1].id = kAccountColumn_Name;	accountsColumns[1].flags = kColumnFlag_Visible;	accountsColumns[1].width = 110;	accountsColumns[1].textAlignement = kTextAlign_Left;		//Create 13 operation columns	operationsColumns[0].id = kOperationColumn_Warning;	operationsColumns[0].flags = kColumnFlag_Visible | kColumnFlag_Sortable;	operationsColumns[0].width = 20;	operationsColumns[0].textAlignement = kTextAlign_Left;		operationsColumns[1].id = kOperationColumn_Checked;	operationsColumns[1].flags = kColumnFlag_Visible | kColumnFlag_Sortable | kColumnFlag_HasSeparator;	operationsColumns[1].width = 20;	operationsColumns[1].textAlignement = kTextAlign_Left;		operationsColumns[2].id = kOperationColumn_Date;	operationsColumns[2].flags = kColumnDefaultAttributeFlags | kColumnFlag_Visible;	operationsColumns[2].width = 60;	operationsColumns[2].textAlignement = kTextAlign_Right;		operationsColumns[3].id = kOperationColumn_Description;	operationsColumns[3].flags = kColumnDefaultAttributeFlags | kColumnFlag_Visible | kColumnFlag_Adjustable;	operationsColumns[3].width = 160;	operationsColumns[3].textAlignement = kTextAlign_Left;		operationsColumns[4].id = kOperationColumn_Category;	operationsColumns[4].flags = kColumnDefaultAttributeFlags | kColumnFlag_Visible | kColumnFlag_Adjustable;	operationsColumns[4].width = 100;	operationsColumns[4].textAlignement = kTextAlign_Left;		operationsColumns[5].id = kOperationColumn_PaymentType;	operationsColumns[5].flags = kColumnDefaultAttributeFlags | kColumnFlag_Adjustable;	operationsColumns[5].width = 100;	operationsColumns[5].textAlignement = kTextAlign_Left;		operationsColumns[6].id = kOperationColumn_Custom;	operationsColumns[6].flags = kColumnDefaultAttributeFlags | kColumnFlag_Adjustable;	operationsColumns[6].width = 120;	operationsColumns[6].textAlignement = kTextAlign_Left;		operationsColumns[7].id = kOperationColumn_Amount;	operationsColumns[7].flags = kColumnDefaultAttributeFlags | kColumnFlag_Visible;	operationsColumns[7].width = 100;	operationsColumns[7].textAlignement = kTextAlign_Right;		operationsColumns[8].id = kOperationColumn_Income;	operationsColumns[8].flags = kColumnDefaultAttributeFlags;	operationsColumns[8].width = 100;	operationsColumns[8].textAlignement = kTextAlign_Right;		operationsColumns[9].id = kOperationColumn_Expense;	operationsColumns[9].flags = kColumnDefaultAttributeFlags;	operationsColumns[9].width = 100;	operationsColumns[9].textAlignement = kTextAlign_Right;		operationsColumns[10].id = kOperationColumn_Balance;	operationsColumns[10].flags = kColumnDefaultAttributeFlags;	operationsColumns[10].width = 100;	operationsColumns[10].textAlignement = kTextAlign_Right;		operationsColumns[11].id = kOperationColumn_Account;	operationsColumns[11].flags = kColumnDefaultAttributeFlags;	operationsColumns[11].width = 100;	operationsColumns[11].textAlignement = kTextAlign_Left;		operationsColumns[12].id = kOperationColumn_Note;	operationsColumns[12].flags = kColumnDefaultAttributeFlags | kColumnFlag_Adjustable;	operationsColumns[12].width = 160;	operationsColumns[12].textAlignement = kTextAlign_Left;		//Set data	prefs->windowFlags = kWindowFlag_AccountList;	GetWindowDefaultBounds(&prefs->windowPosition, &prefs->windowContent);	prefs->windowBalanceType = kBalanceType_Current;	prefs->windowSortingColumn = kOperationColumn_Date;	BlockMove("\pArial", prefs->printFontName, sizeof(Str31));	prefs->printFontSize = 10;	//Set tabulated text import options	iuSettings = (Intl0Hndl) GetIntlResource(0);	if((iuSettings != NULL) && ((**iuSettings).dateOrder == mdy))	prefs->importTabText_monthBefore = true;	else	prefs->importTabText_monthBefore = false;	prefs->importTabText_decimalChar = '.';	prefs->importTabText_startLine = 2;	prefs->importTabText_dateIndex = 1;	prefs->importTabText_descriptionIndex = 2;	prefs->importTabText_incomeIndex = 3;	prefs->importTabText_expenseIndex = 4;	prefs->importTabText_customIndex = 0;	prefs->importTabText_categoryIndex = 0;	prefs->importTabText_paymentIndex = 0;		//Set QIF import options	prefs->importQIF_monthBefore = true;	prefs->importQIF_mode = kImportMode_PayeeIsDescription;				//Get default payment list	prefs->payments = (PaymentListPtr) ResourceToPtr(kPaymentResType);	if(prefs->payments == NULL) {		_ReleasePrefsMemory(prefs);		return NULL;	}	for(i = 0; i < prefs->payments->count; ++i)	if(!prefs->payments->list[i].name[0])	GetEmptyPaymentName(prefs->payments->list[i].name, prefs->payments->list[i].id);	Sort_PaymentTypes(prefs->payments);		//Get default category list	prefs->categories = (CategoryListPtr) ResourceToPtr(kCategoryResType);	if(prefs->categories == NULL) {		_ReleasePrefsMemory(prefs);		return NULL;	}	for(i = 0; i < prefs->categories->count; ++i)	if(!prefs->categories->list[i].name[0])	GetEmptyCategoryName(prefs->categories->list[i].name, prefs->categories->list[i].id);	Sort_Categories(prefs->categories);		//Get default macro list	prefs->macros = (MacroListPtr) ResourceToPtr(kMacroResType);	if(prefs->macros == NULL) {		_ReleasePrefsMemory(prefs);		return NULL;	}		return prefs;}OSErr Preferences::_ReadFromDisk(Handle* printSettings, Boolean* isTHPrint){	OSErr			theError;	short			volumeID;	long			folderNum;	short			fileID;	Str63			fileName;	CategoryListPtr	tempList;	long			i;		//Find preference folder	theError = FindFolder(kOnSystemDisk, kPreferencesFolderType, kCreateFolder, &volumeID, &folderNum);	if(theError)	return theError;		//Open preference file	XGetIndString(fileName, kMiscStringResID, 1);	theError = HOpen(volumeID, folderNum, fileName, fsRdPerm, &fileID);	if(theError)	return theError;	SetFPos(fileID, fsFromStart, 0);		//Read preferences	theError = ReadPtr(fileID, (void**) &data);	if(theError)	goto End;	data->payments = NULL;	data->categories = NULL;		//Convert preferences	if(data->version == 0x0121) {		data->version = kPreferences_Version;				data->importTabText_monthBefore = false;		data->importTabText_decimalChar = '.';		data->importTabText_startLine = 2;		data->importTabText_dateIndex = 1;		data->importTabText_descriptionIndex = 2;		data->importTabText_incomeIndex = 3;		data->importTabText_expenseIndex = 4;		data->importTabText_customIndex = 0;		data->importTabText_categoryIndex = 0;		data->importTabText_paymentIndex = 0;				data->importQIF_monthBefore = true;		data->importQIF_mode = kImportMode_PayeeIsDescription;	}		//Check version	if(data->version != kPreferences_Version) {		DisposePtr((Ptr) data);		data = _CreateDefaultPrefs();		if(data == NULL) {			theError = paramErr;			goto End;		}		DisposePtr((Ptr) data->payments);		data->payments = NULL;		DisposePtr((Ptr) data->categories);		data->categories = NULL;				//Read payment list		theError = ReadPtr(fileID, (void**) &data->payments);		if(theError)		goto End;				//Read category list		theError = ReadPtr(fileID, (void**) &data->categories);		if(theError)		goto End;				//Make sure category list has at least 30 items		if(data->categories->count < 30) {			tempList = (CategoryListPtr) ResourceToPtr(kCategoryResType);			if(tempList) {				for(i = 0; i < data->categories->count; ++i)				BlockMove(&data->categories->list[i], &tempList->list[i], sizeof(Category));				DisposePtr((Ptr) data->categories);				data->categories = tempList;								for(i = 0; i < data->categories->count; ++i)				if(!data->categories->list[i].name[0])				GetEmptyCategoryName(data->categories->list[i].name, data->categories->list[i].id);				Sort_Categories(data->categories);			}		}	}	else {		//Read payment list		theError = ReadPtr(fileID, (void**) &data->payments);		if(theError)		goto End;				//Read category list		theError = ReadPtr(fileID, (void**) &data->categories);		if(theError)		goto End;				//Read macro list		theError = ReadPtr(fileID, (void**) &data->macros);		if(theError)		goto End;	}		//Read print settings	if(data->flags & (kPreferencesFlag_HasClassicPrintSettings | kPreferencesFlag_HasCarbonPrintSettings)) {		if(data->flags & kPreferencesFlag_HasClassicPrintSettings)		*isTHPrint = true;		else		*isTHPrint = false;				theError = ReadHandle(fileID, (void***) printSettings);	}	else	*printSettings = NULL;	End:	if(theError) {		_ReleasePrefsMemory(data);		data = NULL;	}		//Close file	FSClose(fileID);		return theError;}OSErr Preferences::WriteToDisk(Handle printSettings){	OSErr				theError;	short				volumeID;	long				folderNum;	short				fileID;	Str63				fileName;		//Make sure we have prefs	if(data == NULL)	return paramErr;		//Find preference folder	theError = FindFolder(kOnSystemDisk, kPreferencesFolderType, kCreateFolder, &volumeID, &folderNum);	if(theError)	return theError;		//Open preference file - create one if necessary	XGetIndString(fileName, kMiscStringResID, 1);	theError = HOpen(volumeID, folderNum, fileName, fsRdWrPerm, &fileID);	if(theError) {		theError = HCreate(volumeID, folderNum, fileName, kPreferences_FileCreator, kPreferences_FileType);		if(theError)		return theError;		theError = HOpen(volumeID, folderNum, fileName, fsRdWrPerm, &fileID);		if(theError)		return theError;	}		//Update printsettings flag	data->flags &= ~(kPreferencesFlag_HasClassicPrintSettings | kPreferencesFlag_HasCarbonPrintSettings);	if(printSettings)#if TARGET_API_MAC_CARBON	data->flags |= kPreferencesFlag_HasCarbonPrintSettings;#else	data->flags |= kPreferencesFlag_HasClassicPrintSettings;#endif		//Write data	SetFPos(fileID, fsFromStart, 0);	theError = WritePtr(fileID, data);	if(theError)	goto End;	theError = WritePtr(fileID, data->payments);	if(theError)	goto End;	theError = WritePtr(fileID, data->categories);	if(theError)	goto End;	theError = WritePtr(fileID, data->macros);	if(theError)	goto End;	if(printSettings)	theError = WriteHandle(fileID, (void**) printSettings);	End:	//Close file	FSClose(fileID);		return theError;}void Preferences::_ReleasePrefsMemory(PreferencesDataPtr prefs){	if(prefs) {		if(prefs->payments)		DisposePtr((Ptr) prefs->payments);		if(prefs->categories)		DisposePtr((Ptr) prefs->categories);		if(prefs->macros)		DisposePtr((Ptr) prefs->macros);				DisposePtr((Ptr) prefs);	}}static ColumnInfoPtr GetOperationColumnFromID(PreferencesDataPtr prefs, ID id){	long			i;		for(i = 0; i < kOperationNumColumns; ++i)	if(prefs->operationsColumns[i].id == id)	return &prefs->operationsColumns[i];		return NULL;}void Preferences::_ShowPane_General(DialogPtr dialog, short offset){	ControlHandle		items[12];	long				i;	Str255				text;		//Append DITL pane	AppendDialogItemList(dialog, kGeneralID, overlayDITL);		//Get items	for(i = 0; i < 12; ++i)	GetDialogItemAsControl(dialog, offset + 1 + i, &items[i]);		//Set items	_skinMenuItem = data->skinResID - kSkinStartResID + 1;	SetControlValue(items[0], _skinMenuItem);#if __DEMO__	HiliteControl(items[0], 255);#endif	if(data->flags & kPreferencesFlag_DisplayNoteTags)	SetControlValue(items[1], 1);	if(data->flags & kPreferencesFlag_DisplayCategoryColor)	SetControlValue(items[2], 1);	if(data->flags & kPreferencesFlag_DetailedSum)	SetControlValue(items[3], 1);		if(data->flags & kPreferencesFlag_AutoSave)	SetControlValue(items[4], 1);	if(data->flags & kPreferencesFlag_DeleteConfirmation)	SetControlValue(items[5], 1);	if(data->flags & kPreferencesFlag_FilterNotes)	SetControlValue(items[6], 1);	if(data->flags & kPreferencesFlag_SecureOperationCheck)	SetControlValue(items[7], 1);	#if __DEMO__	XGetIndString(text, kMiscStringResID, 26);	XSetDialogItemText(items[9], text);	HiliteControl(items[10], 255);	HiliteControl(items[11], 255);#else	GetFolderNameFromID(data->accountFolder.vRefNum, data->accountFolder.parID, text);	XSetDialogItemText(items[9], text);	if(!(data->flags & kPreferencesFlag_CustomAccountFolder))	HiliteControl(items[10], 255);#endif}void Preferences::_ClickPane_General(DialogPtr dialog, short itemHit, short offset){	ControlHandle			item;	Str255					text;		switch(itemHit) {				case 1:		GetDialogItemAsControl(dialog, offset + 1, &item);		if(GetControlValue(item) != _skinMenuItem)		application->errorManager->Note(42);		break;				case 2:		case 3:		case 4:		case 5:		case 6:		case 7:		case 8:		GetDialogItemAsControl(dialog, offset + itemHit, &item);		SetControlValue(item, !GetControlValue(item));		if((itemHit == 5) && !GetControlValue(item)) {			if(!application->errorManager->Warning(46))			SetControlValue(item, 1);		}		break;				case 11:		if(GetDefaultAccountFolder(&data->accountFolder) == noErr) {			data->flags &= ~kPreferencesFlag_CustomAccountFolder;						GetFolderNameFromID(data->accountFolder.vRefNum, data->accountFolder.parID, text);			GetDialogItemAsControl(dialog, offset + 10, &item);			XSetDialogItemText(item, text);						GetDialogItemAsControl(dialog, offset + 11, &item);			HiliteControl(item, 255);						application->errorManager->Note(30, text);		}		break;				case 12:		XGetIndString(text, kMiscStringResID, 9);		if(NavigationChooseFolder(&data->accountFolder, text) == noErr) {			data->flags |= kPreferencesFlag_CustomAccountFolder;						GetFolderNameFromID(data->accountFolder.vRefNum, data->accountFolder.parID, text);			GetDialogItemAsControl(dialog, offset + 10, &item);			XSetDialogItemText(item, text);						GetDialogItemAsControl(dialog, offset + 11, &item);			HiliteControl(item, 0);						application->errorManager->Note(29, text);		}		break;			}}void Preferences::_HidePane_General(DialogPtr dialog, short offset){	ControlHandle		items[8];	long				i;		//Get items	for(i = 0; i < 8; ++i)	GetDialogItemAsControl(dialog, offset + 1 + i, &items[i]);		data->flags &= 0xFFFFFF00;		data->skinResID = GetControlValue(items[0]) + kSkinStartResID - 1;	if(GetControlValue(items[1]))	data->flags |= kPreferencesFlag_DisplayNoteTags;	if(GetControlValue(items[2]))	data->flags |= kPreferencesFlag_DisplayCategoryColor;	if(GetControlValue(items[3]))	data->flags |= kPreferencesFlag_DetailedSum;		if(GetControlValue(items[4]))	data->flags |= kPreferencesFlag_AutoSave;	if(GetControlValue(items[5]))	data->flags |= kPreferencesFlag_DeleteConfirmation;	if(GetControlValue(items[6]))	data->flags |= kPreferencesFlag_FilterNotes;	if(GetControlValue(items[7]))	data->flags |= kPreferencesFlag_SecureOperationCheck;		//Remove DITL pane	ShortenDITL(dialog, CountDITL(dialog) - offset);}void Preferences::_ShowPane_Payments(DialogPtr dialog, short offset){	ControlHandle		items[2];	long				i;	Cell				theCell;		//Append DITL pane	AppendDialogItemList(dialog, kPaymentsID, overlayDITL);		//Get items	for(i = 0; i < 2; ++i)	GetDialogItemAsControl(dialog, offset + 1 + i, &items[i]);		//Set items	GetListBoxListHandle(items[0], &_theList);	LSetDrawingMode(true, _theList);	(**_theList).selFlags |= lNoExtend | lOnlyOne;	LAddRow(data->payments->count, 1000, _theList);	theCell.h = 0;	for(i = 0; i < data->payments->count; ++i) {		theCell.v = i;		LSetCell(&data->payments->list[i].name[1], data->payments->list[i].name[0], theCell, _theList);	}		_currentCell.h = 0;	_currentCell.v = 0;	LSetSelect(true, _currentCell, _theList);		XSetDialogItemText(items[1], data->payments->list[_currentCell.v].name);	SelectDialogItemText(dialog, offset + 2, 0, 32000);}void Preferences::_ClickPane_Payments(DialogPtr dialog, short itemHit, short offset){	ControlHandle			item;	Str63					text;		GetDialogItemAsControl(dialog, offset + 2, &item);	BackColor(whiteColor);		switch(itemHit) {				//User has selected another payment mode		case 1:		_currentCell.v = 0;		if(!LGetSelect(true, &_currentCell, _theList))		_currentCell.v = data->payments->count - 1;		XSetDialogItemText(item, data->payments->list[_currentCell.v].name);		SelectDialogItemText(dialog, offset + 2, 0, 32000);		break;				//User has changed a payment mode name		case 2:		XGetDialogItemText(item, text, kStr63MaxLength);		if(!text[0]) {			GetEmptyPaymentName(text, data->payments->list[_currentCell.v].id);			XSetDialogItemText(item, text);			SelectDialogItemText(dialog, offset + 2, 0, 32000);		}		BlockMove(text, data->payments->list[_currentCell.v].name, sizeof(Str63));		LSetCell(&data->payments->list[_currentCell.v].name[1], data->payments->list[_currentCell.v].name[0], _currentCell, _theList);		break;				}		LSetSelect(true, _currentCell, _theList);	LDraw(_currentCell, _theList);}void Preferences::_HidePane_Payments(DialogPtr dialog, short offset){	//Remove DITL pane	ShortenDITL(dialog, CountDITL(dialog) - offset);		//Sort payments	Sort_PaymentTypes(data->payments);}void Preferences::_ShowPane_Categories(DialogPtr dialog, short offset){	ControlHandle		items[2];	long				i;	Cell				theCell;		//Append DITL pane	AppendDialogItemList(dialog, kCategoriesID, overlayDITL);		//Get items	for(i = 0; i < 2; ++i)	GetDialogItemAsControl(dialog, offset + 1 + i, &items[i]);		//Set items	GetListBoxListHandle(items[0], &_theList);	LSetDrawingMode(true, _theList);	(**_theList).selFlags |= lNoExtend | lOnlyOne;	LAddRow(data->categories->count, 1000, _theList);	theCell.h = 0;	for(i = 0; i < data->categories->count; ++i) {		theCell.v = i;		LSetCell(&data->categories->list[i].name[1], data->categories->list[i].name[0], theCell, _theList);	}		_currentCell.h = 0;	_currentCell.v = 0;	LSetSelect(true, _currentCell, _theList);		XSetDialogItemText(items[1], data->categories->list[_currentCell.v].name);	SelectDialogItemText(dialog, offset + 2, 0, 32000);}void Preferences::_ClickPane_Categories(DialogPtr dialog, short itemHit, short offset){	Point					where = {-1,-1};	ControlHandle			item;	Str255					text;		GetDialogItemAsControl(dialog, offset + 2, &item);	BackColor(whiteColor);		switch(itemHit) {				//User has selected another category		case 1:		_currentCell.v = 0;		if(!LGetSelect(true, &_currentCell, _theList))		_currentCell.v = data->categories->count - 1;		XSetDialogItemText(item, data->categories->list[_currentCell.v].name);		SelectDialogItemText(dialog, offset + 2, 0, 32000);		break;				//User has changed a category		case 2:		XGetDialogItemText(item, text, kStr63MaxLength);		if(!text[0]) {			GetEmptyCategoryName(text, data->categories->list[_currentCell.v].id);			XSetDialogItemText(item, text);			SelectDialogItemText(dialog, offset + 2, 0, 32000);		}		BlockMove(text, data->categories->list[_currentCell.v].name, sizeof(Str63));		LSetCell(&data->categories->list[_currentCell.v].name[1], data->categories->list[_currentCell.v].name[0], _currentCell, _theList);		break;				//User wants to change a color		case 3:		XGetIndString(text, kMiscStringResID, 8);		GetColor(where, text, &data->categories->list[_currentCell.v].color, &data->categories->list[_currentCell.v].color);		break;			}		LSetSelect(true, _currentCell, _theList);	LDraw(_currentCell, _theList);}void Preferences::_HidePane_Categories(DialogPtr dialog, short offset){	//Remove DITL pane	ShortenDITL(dialog, CountDITL(dialog) - offset);		//Sort	Sort_Categories(data->categories);}void Preferences::_ShowPane_Macros(DialogPtr dialog, short offset){	ControlHandle		items[3];	long				i;	Cell				theCell;	Str31				text;	ControlHandle		item;		//Append DITL pane	AppendDialogItemList(dialog, kMacrosID, overlayDITL);		//Get items	for(i = 0; i < 3; ++i)	GetDialogItemAsControl(dialog, offset + 1 + i, &items[i]);		//Set items	GetListBoxListHandle(items[0], &_theList);	LSetDrawingMode(true, _theList);	(**_theList).selFlags |= lNoExtend | lOnlyOne;	LAddRow(data->macros->count, 1000, _theList);	theCell.h = 0;	for(i = 0; i < data->macros->count; ++i) {		theCell.v = i;		LSetCell(&data->macros->list[i].name[1], data->macros->list[i].name[0], theCell, _theList);	}		_currentCell.h = 0;	if(data->macros->count) {		_currentCell.v = 0;		LSetSelect(true, _currentCell, _theList);		XSetDialogItemText(items[1], data->macros->list[_currentCell.v].name);		CurrencyFactorToString(data->macros->list[_currentCell.v].factor, text, 0, 0);		XSetDialogItemText(items[2], text);		SelectDialogItemText(dialog, offset + 2, 0, 32000);	}	else {		XSetDialogItemText(items[1], "\p");		XSetDialogItemText(items[2], "\p");		GetDialogItemAsControl(dialog, offset + 2, &item);		HiliteControl(item, 255);		GetDialogItemAsControl(dialog, offset + 3, &item);		HiliteControl(item, 255);		GetDialogItemAsControl(dialog, offset + 5, &item);		HiliteControl(item, 255);	}	InstallNumericKeyFilter(items[2]);}void Preferences::_ClickPane_Macros(DialogPtr dialog, short itemHit, short offset){	ControlHandle			item,							item2;	Str63					text;	MacroListPtr			tempList;	long					i;		GetDialogItemAsControl(dialog, offset + 2, &item);	GetDialogItemAsControl(dialog, offset + 3, &item2);	BackColor(whiteColor);		switch(itemHit) {				//User has selected another conversion		case 1:		if(!data->macros->count)		break;		_currentCell.v = 0;		if(!LGetSelect(true, &_currentCell, _theList))		_currentCell.v = data->macros->count - 1;		XSetDialogItemText(item, data->macros->list[_currentCell.v].name);		CurrencyFactorToString(data->macros->list[_currentCell.v].factor, text, 0, 0);		XSetDialogItemText(item2, text);		SelectDialogItemText(dialog, offset + 2, 0, 32000);		break;				//User has changed a conversion mode name		case 2:		if(!data->macros->count)		break;		XGetDialogItemText(item, text, kStr63MaxLength);		if(text[0]) {			BlockMove(text, data->macros->list[_currentCell.v].name, sizeof(Str63));			LSetCell(&data->macros->list[_currentCell.v].name[1], data->macros->list[_currentCell.v].name[0], _currentCell, _theList);		}		break;				//User has changed a conversion value		case 3:		if(!data->macros->count)		break;		XGetDialogItemText(item2, text, kStr63MaxLength);		if(text[0])		StringToCurrencyFactor(text, &data->macros->list[_currentCell.v].factor, 0);		break;				//User want to add a conversion		case 4:		tempList = (MacroListPtr) NewPtr(sizeof(MacroList) + (data->macros->count + 1) * sizeof(Macro));		if(tempList != NULL) {			BlockMove(data->macros, tempList, sizeof(MacroList) + data->macros->count * sizeof(Macro));			DisposePtr((Ptr) data->macros);			data->macros = tempList;						XGetIndString(data->macros->list[data->macros->count].name, kMiscStringResID, 33);			data->macros->list[data->macros->count].factor = pow(10.0, kCurrencyFactorPrecision);						LSetSelect(false, _currentCell, _theList);			LAddRow(1, 1000, _theList);			_currentCell.v = data->macros->count;			LSetCell(&data->macros->list[_currentCell.v].name[1], data->macros->list[_currentCell.v].name[0], _currentCell, _theList);			LSetSelect(true, _currentCell, _theList);						XSetDialogItemText(item, data->macros->list[_currentCell.v].name);			CurrencyFactorToString(data->macros->list[_currentCell.v].factor, text, 0, 0);			XSetDialogItemText(item2, text);			SelectDialogItemText(dialog, offset + 2, 0, 32000);						data->macros->count += 1;			if(data->macros->count == 1) {				GetDialogItemAsControl(dialog, offset + 2, &item);				HiliteControl(item, 0);				GetDialogItemAsControl(dialog, offset + 3, &item);				HiliteControl(item, 0);				GetDialogItemAsControl(dialog, offset + 5, &item);				HiliteControl(item, 0);			}		}		break;				//User want to delete selected conversion		case 5:		tempList = (MacroListPtr) NewPtr(sizeof(MacroList) + (data->macros->count - 1) * sizeof(Macro));		if(tempList != NULL) {			for(i = _currentCell.v; i < data->macros->count - 1; ++i)			data->macros->list[i] = data->macros->list[i + 1];			BlockMove(data->macros, tempList, sizeof(MacroList) + (data->macros->count - 1) * sizeof(Macro));			DisposePtr((Ptr) data->macros);			data->macros = tempList;						LDelRow(1, _currentCell.v, _theList);			data->macros->count -= 1;			if(data->macros->count) {				if(_currentCell.v >= data->macros->count) {					_currentCell.v = data->macros->count - 1;					LSetSelect(true, _currentCell, _theList);				}								XSetDialogItemText(item, data->macros->list[_currentCell.v].name);				CurrencyFactorToString(data->macros->list[_currentCell.v].factor, text, 0, 0);				XSetDialogItemText(item2, text);				SelectDialogItemText(dialog, offset + 2, 0, 32000);			}			else {				LSetSelect(false, _currentCell, _theList);				XSetDialogItemText(item, "\p");				XSetDialogItemText(item2, "\p");								GetDialogItemAsControl(dialog, offset + 2, &item);				HiliteControl(item, 255);				GetDialogItemAsControl(dialog, offset + 3, &item);				HiliteControl(item, 255);				GetDialogItemAsControl(dialog, offset + 5, &item);				HiliteControl(item, 255);			}		}		break;			}		LSetSelect(true, _currentCell, _theList);	LDraw(_currentCell, _theList);}void Preferences::_HidePane_Macros(DialogPtr dialog, short offset){	//Remove DITL pane	ShortenDITL(dialog, CountDITL(dialog) - offset);}void Preferences::_ShowPane_Operations(DialogPtr dialog, short offset){	ControlHandle		items[11];	long				i;	MenuHandle			menu;	Str255				text;		menu = GetMenuHandle(kFontMenuID);		//Append DITL pane	AppendDialogItemList(dialog, kPrintID, overlayDITL);		//Get items	for(i = 0; i < 11; ++i)	GetDialogItemAsControl(dialog, offset + 1 + i, &items[i]);		//Set items	if(data->flags & kPreferencesFlag_DisplayCurrencySymbol)	SetControlValue(items[0], 1);	if(data->flags & kPreferencesFlag_LongDates)	SetControlValue(items[1], 1);	if(data->flags & kPreferencesFlag_IncomesInBold)	SetControlValue(items[2], 1);	if(!(GetOperationColumnFromID(data, kOperationColumn_Amount)->flags & kColumnFlag_Visible))	SetControlValue(items[3], 1);		for(i = 1; i <= CountMenuItems(menu); ++i) {		GetMenuItemText(menu, i, text);		if(FastEqualString(data->printFontName, text, false)) {			SetControlValue(items[4], i);			break;		}	}	XSetDialogItemNum(items[5], data->printFontSize);	if(GetOperationColumnFromID(data, kOperationColumn_Note)->flags & kColumnFlag_Visible)	SetControlValue(items[6], 1);		MesureToString(data->marginLeft, text, 0, 0);	XSetDialogItemText(items[7], text);	MesureToString(data->marginRight, text, 0, 0);	XSetDialogItemText(items[8], text);	MesureToString(data->marginTop, text, 0, 0);	XSetDialogItemText(items[9], text);	MesureToString(data->marginBottom, text, 0, 0);	XSetDialogItemText(items[10], text);		if(UseMetricSystem())	XGetIndString(text, 135, 1);	else	XGetIndString(text, 135, 2);	GetDialogItemAsControl(dialog, offset + 20, &items[0]);	SetControlTitle(items[0], text);	DrawDialog(dialog);		SelectDialogItemText(dialog, offset + 6, 0, 32000);	InstallNumericKeyFilter(items[7]);	InstallNumericKeyFilter(items[8]);	InstallNumericKeyFilter(items[9]);	InstallNumericKeyFilter(items[10]);}void Preferences::_ClickPane_Operations(DialogPtr dialog, short itemHit, short offset){	ControlHandle			item;		switch(itemHit) {				case 1:		case 2:		case 3:		case 4:		case 7:		GetDialogItemAsControl(dialog, offset + itemHit, &item);		SetControlValue(item, !GetControlValue(item));		break;			}}void Preferences::_HidePane_Operations(DialogPtr dialog, short offset){	ControlHandle		items[11];	long				i;	Str63				text;		//Get items	for(i = 0; i < 11; ++i)	GetDialogItemAsControl(dialog, offset + 1 + i, &items[i]);		data->flags &= 0xFFFF00FF;		if(GetControlValue(items[0]))	data->flags |= kPreferencesFlag_DisplayCurrencySymbol;	if(GetControlValue(items[1])) {		data->flags |= kPreferencesFlag_LongDates;		GetOperationColumnFromID(data, kOperationColumn_Date)->textAlignement = kTextAlign_Left;	}	else	GetOperationColumnFromID(data, kOperationColumn_Date)->textAlignement = kTextAlign_Right;	if(GetControlValue(items[2]))	data->flags |= kPreferencesFlag_IncomesInBold;	if(GetControlValue(items[3])) {		GetOperationColumnFromID(data, kOperationColumn_Amount)->flags &= ~kColumnFlag_Visible;		GetOperationColumnFromID(data, kOperationColumn_Income)->flags |= kColumnFlag_Visible;		GetOperationColumnFromID(data, kOperationColumn_Expense)->flags |= kColumnFlag_Visible;	}	else {		GetOperationColumnFromID(data, kOperationColumn_Amount)->flags |= kColumnFlag_Visible;		GetOperationColumnFromID(data, kOperationColumn_Income)->flags &= ~kColumnFlag_Visible;		GetOperationColumnFromID(data, kOperationColumn_Expense)->flags &= ~kColumnFlag_Visible;	}		GetMenuItemText(GetMenuHandle(kFontMenuID), GetControlValue(items[4]), data->printFontName);	data->printFontSize = XGetDialogItemNum(items[5]);		if(GetControlValue(items[6]))	GetOperationColumnFromID(data, kOperationColumn_Note)->flags |= kColumnFlag_Visible;	else	GetOperationColumnFromID(data, kOperationColumn_Note)->flags &= ~kColumnFlag_Visible;		XGetDialogItemText(items[7], text, kStr63MaxLength);	if(text[0])	StringToMesure(text, &data->marginLeft, 0);	XGetDialogItemText(items[8], text, kStr63MaxLength);	if(text[0])	StringToMesure(text, &data->marginRight, 0);	XGetDialogItemText(items[9], text, kStr63MaxLength);	if(text[0])	StringToMesure(text, &data->marginTop, 0);	XGetDialogItemText(items[10], text, kStr63MaxLength);	if(text[0])	StringToMesure(text, &data->marginBottom, 0);	if(data->marginLeft < 0)	data->marginLeft = 0;	if(data->marginRight < 0)	data->marginRight = 0;	if(data->marginTop < 0)	data->marginTop = 0;	if(data->marginBottom < 0)	data->marginBottom = 0;		//Remove DITL pane	ShortenDITL(dialog, CountDITL(dialog) - offset);}Boolean Preferences::Edit(){	PreferencesData			dataBackUp;	PaymentListPtr			paymentListBackUp;	CategoryListPtr			categoryListBackUp;	MacroListPtr			macroListBackUp;	GrafPtr					savePort;	DialogPtr				theDialog;	ControlHandle			tabItem;	short					itemHit,							curPane = 1;								//Backup current preferences	BlockMove(data, &dataBackUp, sizeof(PreferencesData));	paymentListBackUp = (PaymentListPtr) NewPtr(GetPtrSize((Ptr) data->payments));	if(paymentListBackUp == NULL)	return false;	BlockMove(data->payments, paymentListBackUp, GetPtrSize((Ptr) data->payments));	categoryListBackUp = (CategoryListPtr) NewPtr(GetPtrSize((Ptr) data->categories));	if(categoryListBackUp == NULL)	return false;	BlockMove(data->categories, categoryListBackUp, GetPtrSize((Ptr) data->categories));	macroListBackUp = (MacroListPtr) NewPtr(GetPtrSize((Ptr) data->macros));	if(macroListBackUp == NULL)	return false;	BlockMove(data->macros, macroListBackUp, GetPtrSize((Ptr) data->macros));		//Display dialog	GetPort(&savePort);	theDialog = GetNewDialog(kPreferenceDialogID, nil, (WindowPtr) -1);	SetPortDialogPort(theDialog);	NormalizeThemeDrawingState();	GetDialogItemAsControl(theDialog, kTabItemID, &tabItem);		_ShowPane_General(theDialog, kNumItems);	SetControlValue((ControlHandle) tabItem, 1);		SetDialogDefaultItem(theDialog, 1);	SetDialogCancelItem(theDialog, 2);		//Run	do {		//Get dialog events		ModalDialog(ModalDialogRoutine, &itemHit);		if(itemHit > kNumItems) {			if(curPane == 1)			_ClickPane_General(theDialog, itemHit - kNumItems, kNumItems);			else if(curPane == 2)			_ClickPane_Operations(theDialog, itemHit - kNumItems, kNumItems);			else if(curPane == 3)			_ClickPane_Payments(theDialog, itemHit - kNumItems, kNumItems);			else if(curPane == 4)			_ClickPane_Categories(theDialog, itemHit - kNumItems, kNumItems);			else if(curPane == 5)			_ClickPane_Macros(theDialog, itemHit - kNumItems, kNumItems);		}		else if(itemHit == kTabItemID) { //Tab switch			if(curPane == 1)			_HidePane_General(theDialog, kNumItems);			else if(curPane == 2)			_HidePane_Operations(theDialog, kNumItems);			else if(curPane == 3)			_HidePane_Payments(theDialog, kNumItems);			else if(curPane == 4)			_HidePane_Categories(theDialog, kNumItems);			else if(curPane == 5)			_HidePane_Macros(theDialog, kNumItems);						//Get new pane			curPane = GetControlValue(tabItem);						//Display			if(curPane == 1)			_ShowPane_General(theDialog, kNumItems);			else if(curPane == 2)			_ShowPane_Operations(theDialog, kNumItems);			else if(curPane == 3)			_ShowPane_Payments(theDialog, kNumItems);			else if(curPane == 4)			_ShowPane_Categories(theDialog, kNumItems);			else if(curPane == 5)			_ShowPane_Macros(theDialog, kNumItems);		}		else if(itemHit == 1) {			if(curPane == 1)			_HidePane_General(theDialog, kNumItems);			else if(curPane == 2)			_HidePane_Operations(theDialog, kNumItems);			else if(curPane == 3)			_HidePane_Payments(theDialog, kNumItems);			else if(curPane == 4)			_HidePane_Categories(theDialog, kNumItems);			else if(curPane == 5)			_HidePane_Macros(theDialog, kNumItems);		}	} while((itemHit != 1) && (itemHit != 2));		DisposeDialog(theDialog);	SetPort(savePort);		//Has the user clicked cancel?	if(itemHit == 2) {		DisposePtr((Ptr) data->payments);		DisposePtr((Ptr) data->categories);		DisposePtr((Ptr) data->macros);		BlockMove(&dataBackUp, data, sizeof(PreferencesData));		data->payments = paymentListBackUp;		data->categories = categoryListBackUp;		data->macros = macroListBackUp;		return false;	}		return true;}