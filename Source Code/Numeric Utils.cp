/***************************************************************************** * Copyright (c) 1999-2002, Pierre-Olivier Latour * http://www.pol-online.net * info@pol-online.net * * This program is free software; you can redistribute it and/or modify * it under the terms of the GNU General Public License as published by * the Free Software Foundation; either version 2 of the License, or * (at your option) any later version. *  * This program is distributed in the hope that it will be useful, * but WITHOUT ANY WARRANTY; without even the implied warranty of * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the * GNU General Public License for more details. * * You should have received a copy of the GNU General Public License * along with this program; if not, write to the Free Software * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111, USA. *****************************************************************************/#if TARGET_API_MAC_CARBONextern pascal double_t pow(double_t x, double_t y);#else#include			<fp.h>#endif#include			"Numeric Utils.h"//VARIABLES:static unsigned char		_decimalChar = 0,							_thousandChar = 0;//ROUTINES:static void GetFormatingChars(){	Intl0Hndl			iuSettings = nil;		iuSettings = (Intl0Hndl) GetIntlResource(0);	if(iuSettings != nil) {		_decimalChar = (**iuSettings).decimalPt;		_thousandChar = (**iuSettings).thousSep;	}	//Reset to US format	else {		_decimalChar = kDefaultDecimalChar;		_thousandChar = ',';	}}void AmountToCurrencyString(Amount amount, StringPtr text, StringPtr currencySymbol, Boolean decimalPart, Boolean symbolLeads){	if(symbolLeads) {		if(currencySymbol[0]) {			text[1] = currencySymbol[1];			if(currencySymbol[0] > 1)			text[2] = currencySymbol[2];			if(currencySymbol[0] > 2)			text[3] = currencySymbol[3];						AmountToString(amount, &text[currencySymbol[0] + 1], 0, 0, decimalPart);			text[0] = currencySymbol[0] + text[currencySymbol[0] + 1] + 1;			text[currencySymbol[0] + 1] = ' ';		}		else		AmountToString(amount, text, 0, 0, decimalPart);	}	else {		AmountToString(amount, text, 0, 0, decimalPart);		if(currencySymbol[0]) {			text[++text[0]] = ' ';			text[++text[0]] = currencySymbol[1];			if(currencySymbol[0] > 1)			text[++text[0]] = currencySymbol[2];			if(currencySymbol[0] > 2)			text[++text[0]] = currencySymbol[3];		}	}}void FixedRealToString(FixedReal num, long numDigits, StringPtr out, unsigned char decimalChar, unsigned char thousandChar, Boolean decimalPart){	long				factor = pow(10.0, numDigits);	unsigned char		p;	Str31				temp;	long				i;		//Make sure we have the formating chars	if(!decimalChar) {		if(!_decimalChar)		GetFormatingChars();		decimalChar = _decimalChar;	}	if(!thousandChar) {		if(!_thousandChar)		GetFormatingChars();		thousandChar = _thousandChar;	}	//Convert interger part	if(num < 0) {		num = -num;		NumToString(num / factor, temp);		out[0] = 1;		out[1] = '-';	}	else {		NumToString(num / factor, temp);		out[0] = 0;	}		//Insert separators	if(thousandChar != kNoThousandSeparator) {		for(p = 1; p <= temp[0]; ++p) {			if((p > 1) && ((p - temp[0] % 3 - 1) % 3 == 0)) {				++out[0];				out[out[0]] = thousandChar;			}			out[++out[0]] = temp[p];		}	}	else {		for(p = 1; p <= temp[0]; ++p)		out[++out[0]] = temp[p];	}		//Append decimal part	if(decimalPart) {		out[++out[0]] = decimalChar;		NumToString(num - (num / factor) * factor, temp);		if(temp[0] >= numDigits) {			for(i = 1; i <= numDigits; ++i)			out[out[0] + i] = temp[i];		}		else {			for(i = numDigits; i >= 1; --i) {				if(temp[0] >= 1)				out[out[0] + i] = temp[temp[0]--];				else				out[out[0] + i] = '0';			}		}		out[0] += numDigits;	}}void StringToFixedReal(StringPtr in, FixedReal* num, long numDigits, unsigned char decimalChar){	long				factor = pow(10.0, numDigits);	unsigned char		p;	Str31				temp;	long				num2;	Boolean				minus;	long				i;		//Make sure we have the formating chars	if(!decimalChar) {		if(!_decimalChar)		GetFormatingChars();		decimalChar = _decimalChar;	}		//Check for empty string	if(!in[0]) {		*num = 0;		return;	}		//Extract minus	if(in[1] == '-') {		p = 2;		minus = true;	}	else {		p = 1;		minus = false;	}		//Extract integer part	temp[0] = 0;	while((in[p] != decimalChar) && (p <= in[0])) {		if((in[p] >= '0') && (in[p] <= '9'))		temp[++temp[0]] = in[p];		++p;	}	StringToNum(temp, &num2);	*num = num2 * factor;		//Extract decimal part	if((p < in[0]) && (in[p] == decimalChar)) {		++p;		temp[0] = 0;		while(p <= in[0]) {			if((in[p] >= '0') && (in[p] <= '9'))			temp[++temp[0]] = in[p];			++p;		}		if(temp[0]) {			for(i = temp[0] + 1; i <= numDigits; ++i)			temp[i] = '0';			temp[0] = numDigits;			StringToNum(temp, &num2);			if(num2)			*num += num2;		}	}		if(minus)	*num = -*num;}Amount AmountByCurrencyFactor(Amount amount, CurrencyFactor factor){	double				r;	long long			l;	long				d;		//Compute multiplication	r = (double) amount * (double) factor / (double) pow(10.0, kCurrencyFactorPrecision);		//Do rounding	l = r * 10;	d = l % 10;	if(d >= 5)	r += 1;		return r;}float MesureToFloat(Mesure value){	return (float) value / pow(10.0, kMesurePrecision);}Mesure FloatToMesure(float value){	return value * pow(10.0, kMesurePrecision);}