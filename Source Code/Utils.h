/***************************************************************************** * Copyright (c) 1999-2002, Pierre-Olivier Latour * http://www.pol-online.net * info@pol-online.net * * This program is free software; you can redistribute it and/or modify * it under the terms of the GNU General Public License as published by * the Free Software Foundation; either version 2 of the License, or * (at your option) any later version. *  * This program is distributed in the hope that it will be useful, * but WITHOUT ANY WARRANTY; without even the implied warranty of * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the * GNU General Public License for more details. * * You should have received a copy of the GNU General Public License * along with this program; if not, write to the Free Software * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111, USA. *****************************************************************************/#ifndef __UTILS__#define __UTILS__#ifndef __ACCOUNT__#include "Account.h"#endif#ifndef __NUMERIC_UTILS__#include "Numeric Utils.h"#endif#ifndef __SKIN__#include "Skin.h"#endif#ifdef __cplusplusextern "C" {#endif//Constants#define		kSecondsPerDay					(24 * 60 * 60)#define		kCharSortingTableSize			256//Macros#define	DateToDay(d) ((d) / kSecondsPerDay)#define	DayToDate(d) ((d) * kSecondsPerDay)#if TARGET_API_MAC_CARBON#define IUDateString(d, p, t) DateString(d, p, t, NULL)#else#define IUDateString(d, p, t) IUDateString(d, p, t)#define	SetPortWindowPort(w) SetPort(w)#define	SetPortDialogPort(w) SetPort(w)#endif#define TroncateText(s, w) TruncString(w, s, smTruncEnd)//Variablesextern unsigned char		sortingTable[kCharSortingTableSize];//Inlineinline long IDToPaymentTypeNum(PaymentListPtr list, ID id){	long					i;		if(id != kUndefinedID) {		for(i = 0; i < list->count; ++i)		if(list->list[i].id == id)		return i;	}		return kUndefinedNum;}inline long IDToCategoryNum(CategoryListPtr list, ID id){	long					i;		if(id != kUndefinedID) {		for(i = 0; i < list->count; ++i)		if(list->list[i].id == id)		return i;	}		return kUndefinedNum;}inline Amount GetAbsoluteOperationAmount(OperationPtr p){	if(p->flags & kOperationFlag_Expense)	return -1.0 * p->amount;		return p->amount;}inline Boolean EqualChar_CaseUnsensitive(unsigned char a, unsigned char b){	if((a >= 'a') && (a <= 'z') && (b >= 'A') && (b <= 'Z')) {		if(a != (b - 'A' + 'a'))		return false;	}	else if((a >= 'A') && (a <= 'Z') && (b >= 'a') && (b <= 'z')) {		if((a - 'A' + 'a') != b)		return false;	}	else if(a != b)	return false;		return true;}inline Boolean StringInString(StringPtr in, StringPtr check) //Works only in Roman script{	long				i,						j;		for(i = 0; i < in[0] - check[0] + 1; ++i) {		for(j = 1; j <= check[0]; ++j) {			if(!EqualChar_CaseUnsensitive(check[j], in[j + i]))			break;		}		if(j > check[0])		return true;	}		return false;}inline Boolean FastEqualString(StringPtr a, StringPtr b, Boolean caseSensitive)  //Works only in Roman script{	long				count;		if(a[0] != b[0])	return false;		count = a[0];	++a;	++b;	if(caseSensitive) {		while(count--)		if(*a++ != *b++)		return false;	}	else {		while(count--)		if(!EqualChar_CaseUnsensitive(*a++, *b++))		return false;	}		return true;}inline Boolean FastEqualText(long count, unsigned char* a, unsigned char* b, Boolean caseSensitive)  //Works only in Roman script{	if(caseSensitive) {		while(count--)		if(*a++ != *b++)		return false;	}	else {		while(count--)		if(!EqualChar_CaseUnsensitive(*a++, *b++))		return false;	}		return true;}/* FastCompareString returns -1 if the first string is less than the second string, 0 if thefirst string is equal to the second string, and 1 if the first string is greater thanthe second string.Note: Works only in Roman script */inline short FastCompareString(StringPtr a, StringPtr b){	unsigned char		*table = sortingTable;	long				la = a[0],						lb = b[0],						count;		if(la < lb)	count = la;	else	count = lb;		while(count--) {		++a;		++b;		if(*a != *b) {			if(table[*a] < table[*b])			return -1;			else			return 1;		}	}		if(la == lb)	return 0;	if(la < lb)	return -1;		return 1;}//Prototypesvoid PanicError(long num);OSErr GetFolderNameFromID(short vRefNum, long folderID, Str255 name);Boolean FolderExists(short vRefNum, long folderID);OSErr GetDefaultAccountFolder(FSSpec* folder);Point GetWindowPosition(WindowPtr window);void GetWindowMaxSize(Rect* content, Point* position);Boolean EqualFileNames(StringPtr a, StringPtr b);void AppendString(StringPtr dest, StringPtr add);void GetWindowDefaultBounds(Point* position, Rect* content);void SetTempFileName(Str31 name);Boolean FilterOperation(OperationPtr operation, StringPtr filter, CategoryListPtr categories, PaymentListPtr payments);void XGetIndString(StringPtr text, short resID, short index);void CategoriesMenu_Update(Boolean includeNoneItem);short CategoriesMenu_SetChoice(ID id);ID CategoriesMenu_GetChoice(short item);void PaymentTypesMenu_Update(Boolean includeNoneItem);short PaymentTypesMenu_SetChoice(ID id);ID PaymentTypesMenu_GetChoice(short item);void AccountMenu_Update(Boolean includeAllItem);short AccountMenu_SetChoice(ID id);ID AccountMenu_GetChoice(short item);void MacroMenu_Update();void InitFastCompareStringCacheTable();Boolean UseMetricSystem();#ifdef __cplusplus}#endif#endif //__UTILS__